#+TITLE: Pattern workflows
:PROPERTIES:
:DOC_ID: futon4-ec46e35bad95
:ENTRY_ID: futon4-ec46e35bad95::org
:VERSION: org
:OUTLINE_PATH: Pattern workflows
:PATH_STRING: Pattern workflows
:REPLACES: 
:END:

* Context
The reanimation plan calls out pattern tooling as the last literate piece: we need both the pattern editing helpers and the ingest shims (see docs/reanimation-plan.org) inside the new spine so contributors change Org first and then tangle.

** Editing Futon pattern entries

These commands let Emacs users work with Futon patterns without leaving Org buffers.

- `M-x arxana-patterns-open` â fetch a Futon pattern (e.g., `mojo/center`) into an Org buffer, complete with the component identifiers.
- Edit the buffer like any other Org document; the Futon ids stay in the headings so provenance survives.
- `g` (`arxana-patterns-refresh-buffer`) refetches the same slug; `C-c C-s` (`arxana-patterns-save`) pushes the updated text back to Futon.
- Run `dev/run-tests.sh` before publishing to confirm the pattern helpers and storage shims still behave.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-patterns.el
;;; arxana-patterns.el --- Futon pattern importer/editor -*- lexical-binding: t; -*-

;;; Commentary:
;; Fetch pattern-library entries from Futon1 (patterns ingested from Futon3) and
;; render them as editable Org buffers.  Each buffer exposes the pattern summary
;; and component passages so Emacs users can review and update pattern text
;; without dropping into the Futon CLI.

;;; Code:

(require 'cl-lib)
(require 'seq)
(require 'subr-x)
(require 'org)

(require 'arxana-store)

(defgroup arxana-patterns nil
  "Utilities for browsing Futon pattern entities in Emacs."
  :group 'arxana)

(defcustom arxana-patterns-ego-limit 64
  "Number of neighbor links to request when fetching Futon pattern data."
  :type 'integer
  :group 'arxana-patterns)

(defvar-local arxana-patterns--pattern nil
  "Buffer-local plist describing the currently loaded pattern.")

(defconst arxana-patterns--summary-begin "#+BEGIN_SUMMARY")
(defconst arxana-patterns--summary-end "#+END_SUMMARY")

(defvar arxana-patterns-view-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-s") #'arxana-patterns-save)
    (define-key map (kbd "g") #'arxana-patterns-refresh-buffer)
    map)
  "Keymap for `arxana-patterns-view-mode'.")

(define-minor-mode arxana-patterns-view-mode
  "Minor mode for pattern editing buffers."
  :lighter " Pattern"
  :keymap arxana-patterns-view-mode-map
  (when arxana-patterns-view-mode
    (setq header-line-format "C-c C-s to sync changes; g to refetch from Futon")))

(defun arxana-patterns--ensure-sync ()
  (unless (arxana-store-sync-enabled-p)
    (user-error "Futon sync is disabled; enable futon4-enable-sync first")))

(defun arxana-patterns--alist (key alist)
  (alist-get key alist))

(defun arxana-patterns--alist-like-p (value)
  (and (listp value)
       (let ((first (car-safe value)))
         (and first (consp first)))))

(defun arxana-patterns--entity-value (entity &rest keys)
  "Return the first matching value in ENTITY for the provided :entity/* KEYS."
  (when (arxana-patterns--alist-like-p entity)
    (seq-some (lambda (key)
                (let ((cell (assoc key entity)))
                  (when cell (cdr cell))))
              keys)))

(defun arxana-patterns--entity-from-version (entity)
  "Return the entity payload stored inside ENTITY's version data, if any."
  (when (arxana-patterns--alist-like-p entity)
    (let* ((version (arxana-patterns--alist :version entity))
           (data (and (arxana-patterns--alist-like-p version)
                      (arxana-patterns--alist :data version)))
           (payload (and (arxana-patterns--alist-like-p data)
                         (arxana-patterns--alist :entity data))))
      (and (arxana-patterns--alist-like-p payload) payload))))

(defun arxana-patterns--find-entity (tree target-id)
  "Locate the entity with TARGET-ID inside TREE (direct or linked payloads)."
  (let ((match nil))
    (cl-labels ((entity-matches-p (entity)
                  (let ((id (arxana-patterns--entity-value entity :id :entity/id)))
                    (and id target-id (equal id target-id))))
                (walk (node)
                  (when (and node (not match))
                    (cond
                     ((arxana-patterns--alist-like-p node)
                      (when (entity-matches-p node)
                        (setq match node))
                      (dolist (pair node)
                        (when (and (consp pair) (not match))
                          (walk (cdr pair)))))
                     ((listp node)
                      (dolist (item node)
                        (walk item)))))))
      (walk tree)
      match)))

(defun arxana-patterns--pattern-entity (ego)
  (arxana-patterns--alist :entity ego))

(defun arxana-patterns--resolve-entity-by-name (name)
  "Return the Futon entity alist for NAME via `/ego`."
  (let* ((ego-response (arxana-store-ego name 1))
         (ego (and ego-response (arxana-patterns--alist :ego ego-response))))
    (and ego (arxana-patterns--alist :entity ego))))

(defun arxana-patterns--relation-text (value)
  "Return VALUE as a normalized relation string without the leading colon."
  (let ((text (cond
               ((keywordp value) (symbol-name value))
               ((symbolp value) (symbol-name value))
               ((stringp value) value)
               (t nil))))
    (when text
      (if (and (> (length text) 0)
               (eq (aref text 0) ?:))
          (substring text 1)
        text))))

(defun arxana-patterns--relation-match-p (value target)
  "Return non-nil when VALUE (keyword/string) matches TARGET (string/keyword)."
  (let ((lhs (arxana-patterns--relation-text value))
        (rhs (arxana-patterns--relation-text target)))
    (and lhs rhs (string= lhs rhs))))

(defun arxana-patterns--component-links (ego)
  (when (arxana-patterns--alist-like-p ego)
    (let* ((links (arxana-patterns--alist :links ego))
           (link-outgoing (and (arxana-patterns--alist-like-p links)
                               (arxana-patterns--alist :outgoing links)))
           (outgoing (or (arxana-patterns--alist :outgoing ego) link-outgoing)))
      (seq-filter (lambda (entry)
                    (arxana-patterns--relation-match-p
                     (arxana-patterns--alist :relation entry)
                     ":pattern/includes"))
                  outgoing))))

(defun arxana-patterns--component-slug-base (name)
  (when (and name (string-match "\\`\\(.+\\)/[0-9]+-[^/]+\\'" name))
    (match-string 1 name)))

(defun arxana-patterns--component-link-name (link)
  (let ((entity (arxana-patterns--alist :entity link)))
    (or (arxana-patterns--entity-value entity :name :entity/name)
        (arxana-patterns--entity-value entity :ident :entity/ident))))

(defun arxana-patterns--lookup-component-by-name (component-name)
  (let ((base (arxana-patterns--component-slug-base component-name)))
    (when base
      (let* ((ego-response (arxana-store-ego base arxana-patterns-ego-limit))
             (ego (and ego-response (arxana-patterns--alist :ego ego-response)))
             (links (and (arxana-patterns--alist-like-p ego)
                         (arxana-patterns--component-links ego)))
             (matching (and links
                            (cl-find-if (lambda (link)
                                          (string= (arxana-patterns--component-link-name link)
                                                   component-name))
                                        links))))
        (when matching
          (arxana-patterns--fetch-component matching))))))

(defun arxana-patterns--lookup-component-by-prefix (component-name)
  (let ((base (arxana-patterns--component-slug-base component-name)))
    (when base
      (let* ((ego-response (arxana-store-ego base arxana-patterns-ego-limit))
             (ego (and ego-response (arxana-patterns--alist :ego ego-response)))
             (links (and (arxana-patterns--alist-like-p ego)
                        (arxana-patterns--component-links ego)))
             (matching (and links
                            (cl-find-if (lambda (link)
                                          (let ((name (arxana-patterns--component-link-name link)))
                                            (and name (string-prefix-p name component-name))))
                                        links))))
        (when matching
          (arxana-patterns--fetch-component matching))))))

(defun arxana-patterns--extract-summary ()
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (if (re-search-forward (concat "^" (regexp-quote arxana-patterns--summary-begin) "\\s-*$") nil t)
          (let ((start (progn (forward-line 1) (point))))
            (if (re-search-forward (concat "^" (regexp-quote arxana-patterns--summary-end) "\\s-*$") nil t)
                (string-trim (buffer-substring-no-properties start (match-beginning 0)))
              ""))
        ""))))

(defun arxana-patterns--read-header-field (label)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t)
          (rx (format "^#\\+%s: \\(.*\\)$" (regexp-quote label))))
      (when (re-search-forward rx nil t)
        (string-trim (match-string 1))))))

(defun arxana-patterns--component-name-info (name)
  (if (and name (string-match "/\\([0-9]+\\)-\\([^/]+\\)$" name))
      (list :order (string-to-number (match-string 1 name))
            :kind (match-string 2 name))
    (list :order 0 :kind (or name "component"))))

(defun arxana-patterns--component-parent-id (component-name)
  (when component-name
    (let* ((ego-response (ignore-errors (arxana-store-ego component-name arxana-patterns-ego-limit)))
           (ego (and ego-response (arxana-patterns--alist :ego ego-response)))
           (incoming (and ego (arxana-patterns--alist :incoming ego)))
           (parent-link (and incoming
                             (cl-find-if (lambda (entry)
                                           (arxana-patterns--relation-match-p
                                            (arxana-patterns--alist :relation entry)
                                            ":pattern/component-parent"))
                                         incoming))))
      (when parent-link
        (let* ((entity (arxana-patterns--alist :entity parent-link)))
          (or (arxana-patterns--alist :entity/id entity)
              (arxana-patterns--alist :id entity)))))))

(defun arxana-patterns--fetch-entity-source (entity-id)
  (when entity-id
    (let* ((response (ignore-errors (arxana-store-fetch-entity entity-id)))
           (entity (and response (arxana-patterns--alist :entity response)))
           (linked (and response (arxana-patterns--find-entity response entity-id)))
           (version-entity (or (arxana-patterns--entity-from-version entity)
                               (arxana-patterns--entity-from-version linked)))
           (candidates (delq nil (list entity version-entity linked))))
      (cl-labels ((value (&rest keys)
                    (seq-some (lambda (candidate)
                                (apply #'arxana-patterns--entity-value candidate keys))
                              candidates)))
        (when (or candidates (plist-get (car candidates) :id))
          (list :source (or (value :source :entity/source) "")
                :external-id (value :external-id :entity/external-id)
                :name (value :name :entity/name)
                :id (or (value :id :entity/id) entity-id)))))))

(defun arxana-patterns--fetch-component (link)
  (let* ((entity (arxana-patterns--alist :entity link))
         (component-id (or (arxana-patterns--alist :entity/id entity)
                           (arxana-patterns--alist :id entity)))
         (component-name (or (arxana-patterns--alist :entity/name entity)
                             (arxana-patterns--alist :name entity)))
         (details (arxana-patterns--fetch-entity-source component-id))
         (order-info (arxana-patterns--component-name-info component-name))
         (parent-id (arxana-patterns--component-parent-id component-name)))
    (when component-id
      (list :id component-id
            :name (or component-name (plist-get details :name) "component")
            :text (or (plist-get details :source) "")
            :order (plist-get order-info :order)
            :kind (plist-get order-info :kind)
            :parent-id parent-id))))

(defun arxana-patterns--compute-levels (components)
  (let ((table (make-hash-table :test 'equal)))
    (dolist (component components)
      (puthash (plist-get component :id)
               (copy-sequence component)
               table))
    (cl-labels ((level-of (component-id)
                  (let ((entry (gethash component-id table)))
                    (if (not entry)
                        0
                      (let ((existing (plist-get entry :level)))
                        (if existing
                            existing
                          (let* ((parent-id (plist-get entry :parent-id))
                                 (computed (if parent-id
                                               (1+ (level-of parent-id))
                                             0))
                                 (updated (plist-put entry :level computed)))
                            (puthash component-id updated table)
                            computed)))))))
      (mapcar (lambda (component)
                (let ((id (plist-get component :id)))
                  (level-of id)
                  (gethash id table)))
              components))))

(defun arxana-patterns--fetch-pattern-data (name)
  (arxana-patterns--ensure-sync)
  (let* ((ego-response (arxana-store-ego name arxana-patterns-ego-limit))
         (ego (and ego-response (arxana-patterns--alist :ego ego-response)))
         (entity (and ego (arxana-patterns--pattern-entity ego)))
         (pattern-id (or (and entity (arxana-patterns--alist :id entity))
                         (arxana-patterns--alist :entity/id entity)))
         (pattern-details (arxana-patterns--fetch-entity-source pattern-id))
         (summary (or (plist-get pattern-details :source) ""))
         (title (or (plist-get pattern-details :external-id) name))
         (component-links (arxana-patterns--component-links ego))
         (component-entries (delq nil (mapcar #'arxana-patterns--fetch-component
                                              component-links)))
         (leveled-components (arxana-patterns--compute-levels component-entries))
         (components (cl-sort (copy-sequence leveled-components)
                              #'< :key (lambda (comp)
                                         (or (plist-get comp :order) 0)))))
    (unless pattern-id
      (user-error "Pattern %s was not found in Futon" name))
    (list :id pattern-id
          :name name
          :title title
          :summary summary
          :components components)))

(defun arxana-patterns--insert-summary (summary)
  (insert arxana-patterns--summary-begin "\n")
  (insert (string-trim (or summary "")) "\n")
  (insert arxana-patterns--summary-end "\n\n"))

(defun arxana-patterns--insert-component (component)
  (let* ((level (max 0 (or (plist-get component :level) 0)))
         (stars (make-string (max 1 (1+ level)) ?*))
         (label (capitalize (or (plist-get component :kind) "component")))
         (name (plist-get component :name))
         (component-id (plist-get component :id))
         (text (string-trim (or (plist-get component :text) ""))))
    (insert (format "%s %s\n" stars label))
    (insert ":PROPERTIES:\n")
    (insert (format ":COMPONENT-ID: %s\n" component-id))
    (insert (format ":COMPONENT-NAME: %s\n" name))
    (insert (format ":COMPONENT-KIND: %s\n" (plist-get component :kind)))
    (insert (format ":COMPONENT-ORDER: %s\n" (or (plist-get component :order) 0)))
    (insert (format ":COMPONENT-PARENT: %s\n"
                    (or (plist-get component :parent-id) "")))
    (insert ":END:\n\n")
    (insert text "\n\n")))

(defun arxana-patterns--render-pattern (pattern)
  (let* ((name (plist-get pattern :name))
         (buffer (get-buffer-create (format "*Arxana Pattern: %s*" name))))
    (with-current-buffer buffer
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert (format "#+TITLE: Pattern %s\n" name))
        (insert (format "#+PATTERN: %s\n" name))
        (insert (format "#+PATTERN-ID: %s\n" (plist-get pattern :id)))
        (insert (format "#+PATTERN-TITLE: %s\n\n" (plist-get pattern :title)))
        (arxana-patterns--insert-summary (plist-get pattern :summary))
        (dolist (component (plist-get pattern :components))
          (arxana-patterns--insert-component component))
        (goto-char (point-min))
        (org-mode)
        (arxana-patterns-view-mode 1)
        (setq-local arxana-patterns--pattern pattern)))
    (pop-to-buffer buffer)))

;;;###autoload
(defun arxana-patterns-open (name)
  "Fetch the Futon pattern NAME and render it in an Org buffer."
  (interactive (list (read-string "Pattern name: " (thing-at-point 'symbol t))))
  (let ((pattern (arxana-patterns--fetch-pattern-data name)))
    (arxana-patterns--render-pattern pattern)))

;;;###autoload
(defun arxana-patterns-inspect-entity (name)
  "Show the Futon source text for entity NAME (pattern or component)."
  (interactive (list (read-string "Entity name: " (thing-at-point 'symbol t))))
  (arxana-patterns--ensure-sync)
  (let* ((entity (arxana-patterns--resolve-entity-by-name name))
         (component (and (not entity)
                          (or (arxana-patterns--lookup-component-by-name name)
                              (arxana-patterns--lookup-component-by-prefix name))))
         (direct-id (and (not (or entity component))
                         (arxana-patterns--fetch-entity-source name)))
         (details (cond
                    (entity
                     (let ((entity-id (or (arxana-patterns--entity-value entity :id :entity/id)
                                          (arxana-patterns--entity-value entity :ident :entity/ident))))
                       (unless entity-id
                         (user-error "Entity %s not found" name))
                       (arxana-patterns--fetch-entity-source entity-id)))
                    (component component)
                    (direct-id direct-id)
                    (t nil))))
    (unless details
      (user-error "Entity %s was not found" name))
    (let* ((text (string-trim (or (plist-get details :text)
                                  (plist-get details :summary)
                                  (plist-get details :source)
                                  "")))
           (buffer (get-buffer-create "*Arxana Pattern Snippet*")))
      (with-current-buffer buffer
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (format "Name: %s\n" (or (plist-get details :name) name)))
          (insert (format "Id: %s\n" (or (plist-get details :id) "?")))
          (when-let ((title (plist-get details :external-id)))
            (insert (format "Title: %s\n" title)))
          (when-let ((order (plist-get details :order)))
            (insert (format "Order: %s\n" order)))
          (when-let ((kind (plist-get details :kind)))
            (insert (format "Kind: %s\n" kind)))
          (insert "\n")
          (insert text)
          (goto-char (point-min))
          (view-mode 1)))
      (pop-to-buffer buffer))))

(defun arxana-patterns-refresh-buffer ()
  "Re-fetch the current pattern from Futon and replace the buffer contents."
  (interactive)
  (unless (and (boundp 'arxana-patterns--pattern)
               arxana-patterns--pattern)
    (user-error "No pattern is loaded in this buffer"))
  (arxana-patterns-open (plist-get arxana-patterns--pattern :name)))

(defun arxana-patterns--collect-components ()
  (let (results)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\*+ " nil t)
        (let ((component-id (org-entry-get (point) "COMPONENT-ID")))
          (when component-id
            (let* ((component-name (org-entry-get (point) "COMPONENT-NAME"))
                   (begin (save-excursion
                            (org-back-to-heading t)
                            (forward-line)
                            (while (looking-at "^[ \\t]*$\|^[ \\t]*:\\|^[ \\t]*#")
                              (forward-line))
                            (point)))
                   (end (save-excursion
                          (org-end-of-subtree t t)
                          (point)))
                   (text (if (and begin end)
                             (string-trim (buffer-substring-no-properties begin end))
                           "")))
              (push (list :id component-id
                          :name component-name
                          :text text)
                    results))))))
    (nreverse results)))

(defun arxana-patterns-save ()
  "Sync the current pattern buffer back to Futon.
Only existing components are updated; new headings without component ids
are ignored for now."
  (interactive)
  (arxana-patterns--ensure-sync)
  (unless (and (boundp 'arxana-patterns--pattern)
               arxana-patterns--pattern)
    (user-error "No pattern metadata found in this buffer"))
  (save-excursion
    (widen)
    (let* ((pattern-id (plist-get arxana-patterns--pattern :id))
           (pattern-name (or (plist-get arxana-patterns--pattern :name)
                             (arxana-patterns--read-header-field "PATTERN")))
           (pattern-title (arxana-patterns--read-header-field "PATTERN-TITLE"))
           (summary (arxana-patterns--extract-summary))
           (components (arxana-patterns--collect-components)))
      (arxana-store-ensure-entity :id pattern-id
                                  :name pattern-name
                                  :type "pattern/library"
                                  :source summary
                                  :external-id pattern-title)
      (dolist (component components)
        (let ((cid (plist-get component :id))
              (cname (plist-get component :name))
              (ctext (plist-get component :text)))
          (when (and cid cname)
            (arxana-store-ensure-entity :id cid
                                        :name cname
                                        :type "pattern/component"
                                        :source ctext))))
      (message "Synced %s (%d components)" pattern-name (length components)))))

(provide 'arxana-patterns)

;;; arxana-patterns.el ends here
(defcustom arxana-patterns-library-root nil
  "Path to the Futon3 pattern library checkout.
When nil the browser attempts to locate a \"futon3/library\" directory
relative to the current buffer or this file."
  :type '(choice (const :tag "Auto-detect" nil)
                 directory)
  :group 'arxana-patterns)

(defvar arxana-patterns--browser-buffer "*Arxana Pattern Browser*")
(defvar-local arxana-patterns--browser-stack nil)
(defvar-local arxana-patterns--browser-items nil)
(defconst arxana-patterns--browser-header-lines 2)

(defun arxana-patterns--locate-library-root ()
  (let ((explicit arxana-patterns-library-root))
    (cond
     ((and explicit (file-directory-p explicit)) (expand-file-name explicit))
     (t
      (let* ((current (or load-file-name buffer-file-name default-directory))
             (root (locate-dominating-file current "futon3")))
        (when root
          (let ((candidate (expand-file-name "futon3/library" root)))
            (and (file-directory-p candidate) candidate))))))))

(defun arxana-patterns--library-directories ()
  (when-let ((root (arxana-patterns--locate-library-root)))
    (seq-sort #'string<
              (seq-filter
               (lambda (entry)
                 (let ((full (expand-file-name entry root)))
                   (and (file-directory-p full)
                        (not (member entry '("." ".."))))))
               (directory-files root)))))

(defun arxana-patterns--flexiarg-file-for (library)
  (when-let ((root (arxana-patterns--locate-library-root)))
    (let ((file (expand-file-name (format "%s/%s.flexiarg" library library) root)))
      (when (file-regular-p file)
        file))))

(defun arxana-patterns--parse-flexiarg (file)
  (let ((lines (split-string (with-temp-buffer
                               (insert-file-contents file)
                               (buffer-string))
                             "\n" t))
        (current nil)
        (results nil))
    (dolist (line lines)
      (cond
       ((string-match "^@arg\\s-+\\(.+\\)$" line)
        (when current
          (push current results))
        (setq current (list :name (match-string 1 line))))
       ((and current (string-match "^@title\\s-+\\(.+\\)$" line))
        (setq current (plist-put current :title (match-string 1 line))))))
    (when current
      (push current results))
    (nreverse results)))

(defun arxana-patterns--browser-root-items ()
  (mapcar (lambda (dir)
            (list :type 'library
                  :label dir))
          (or (arxana-patterns--library-directories) '())))

(defun arxana-patterns--browser-pattern-items (library)
  (when-let ((file (arxana-patterns--flexiarg-file-for library)))
    (mapcar (lambda (entry)
              (list :type 'pattern
                    :label (plist-get entry :name)
                    :title (plist-get entry :title)))
            (arxana-patterns--parse-flexiarg file))))

(defun arxana-patterns--browser-current-items ()
  (if (not arxana-patterns--browser-stack)
      (arxana-patterns--browser-root-items)
    (arxana-patterns--browser-pattern-items (car arxana-patterns--browser-stack))))

(defun arxana-patterns--browser-render ()
  (let ((buffer (get-buffer-create arxana-patterns--browser-buffer)))
    (with-current-buffer buffer
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert (propertize (if arxana-patterns--browser-stack
                                (format "Library: %s" (car arxana-patterns--browser-stack))
                              "Pattern Libraries")
                            'face 'bold)
                "\n\n")
        (setq arxana-patterns--browser-items (arxana-patterns--browser-current-items))
        (if (seq-empty-p arxana-patterns--browser-items)
            (insert "(no entries)\n")
          (dolist (item arxana-patterns--browser-items)
            (let ((label (plist-get item :label))
                  (title (plist-get item :title))
                  (type (plist-get item :type)))
              (insert (format "%-12s %s%s\n"
                              (if (eq type 'library) "Library" "Pattern")
                              label
                              (if (and title (not (string-empty-p title)))
                                  (format " â %s" title)
                                ""))))))
        (goto-char (point-min))
        (forward-line arxana-patterns--browser-header-lines)
        (arxana-patterns-browser-mode)
        (hl-line-mode 1))
      (display-buffer buffer))))

(defun arxana-patterns--browser-item-at-point ()
  (let ((line (line-number-at-pos))
        (min-line (1+ arxana-patterns--browser-header-lines)))
    (when (>= line min-line)
      (nth (- line min-line) arxana-patterns--browser-items))))

(defun arxana-patterns--browser--move (delta)
  (let* ((line (line-number-at-pos))
         (count (length arxana-patterns--browser-items))
         (min-line (1+ arxana-patterns--browser-header-lines))
         (max-line (+ arxana-patterns--browser-header-lines count))
         (target (min max-line (max min-line (+ line delta)))))
    (goto-char (point-min))
    (forward-line (1- target))
    (hl-line-highlight)
    (when (> (count-lines (window-start) (point)) 0)
      (set-window-start (selected-window) (save-excursion
                                           (forward-line (- (window-height) 3))
                                           (point))))
    (when (>= (line-number-at-pos (window-end)) target)
      (set-window-start (selected-window) (save-excursion
                                           (goto-char (point-min))
                                           (forward-line (- target arxana-patterns--browser-header-lines 2))
                                           (point))))))

(defun arxana-patterns--browser-scroll-up (_event)
  (interactive "e")
  (arxana-patterns--browser--move -1))

(defun arxana-patterns--browser-scroll-down (_event)
  (interactive "e")
  (arxana-patterns--browser--move 1))

(defun arxana-patterns--browser-visit ()
  (interactive)
  (let ((item (arxana-patterns--browser-item-at-point)))
    (unless item
      (user-error "No entry on this line"))
    (pcase (plist-get item :type)
      ('library
       (setq arxana-patterns--browser-stack (list (plist-get item :label)))
       (arxana-patterns--browser-render))
      ('pattern
       (arxana-patterns-open (plist-get item :label))))))

(defun arxana-patterns--browser-up ()
  (interactive)
  (if (not arxana-patterns--browser-stack)
      (user-error "Already at top level")
    (setq arxana-patterns--browser-stack nil)
    (arxana-patterns--browser-render)))

(defun arxana-patterns--browser-refresh ()
  (interactive)
  (arxana-patterns--browser-render))

(defvar arxana-patterns-browser-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") #'arxana-patterns--browser-visit)
    (define-key map (kbd "n") (lambda () (interactive) (arxana-patterns--browser--move 1)))
    (define-key map (kbd "p") (lambda () (interactive) (arxana-patterns--browser--move -1)))
    (define-key map (kbd "<down>") (lambda () (interactive) (arxana-patterns--browser--move 1)))
    (define-key map (kbd "<up>") (lambda () (interactive) (arxana-patterns--browser--move -1)))
    (define-key map [wheel-down] #'arxana-patterns--browser-scroll-down)
    (define-key map [wheel-up] #'arxana-patterns--browser-scroll-up)
    (define-key map [double-wheel-down] #'arxana-patterns--browser-scroll-down)
    (define-key map [double-wheel-up] #'arxana-patterns--browser-scroll-up)
    (define-key map [triple-wheel-down] #'arxana-patterns--browser-scroll-down)
    (define-key map [triple-wheel-up] #'arxana-patterns--browser-scroll-up)
    (define-key map [mouse-5] #'arxana-patterns--browser-scroll-down)
    (define-key map [mouse-4] #'arxana-patterns--browser-scroll-up)
    (define-key map [wheel-left] #'arxana-patterns--browser-up)
    (define-key map [wheel-right] #'arxana-patterns--browser-visit)
    (define-key map (kbd "b") #'arxana-patterns--browser-up)
    (define-key map (kbd "g") #'arxana-patterns--browser-refresh)
    (define-key map (kbd "q") #'quit-window)
    map))

(define-derived-mode arxana-patterns-browser-mode special-mode "Pattern-Browse"
  "Mode for browsing Futon pattern libraries."
  (local-set-key (kbd "<wheel-up>") #'previous-line)
  (local-set-key (kbd "<wheel-down>") #'next-line)
  (local-set-key (kbd "<mouse-4>") #'previous-line)
  (local-set-key (kbd "<mouse-5>") #'next-line)
  (local-set-key (kbd "<double-wheel-up>") #'previous-line)
  (local-set-key (kbd "<double-wheel-down>") #'next-line)
  (local-set-key (kbd "<triple-wheel-up>") #'previous-line)
  (local-set-key (kbd "<triple-wheel-down>") #'next-line)
  (local-set-key (kbd "<wheel-left>") #'arxana-patterns--browser-up)
  (local-set-key (kbd "<wheel-right>") #'arxana-patterns--browser-visit))

;;;###autoload
(defun arxana-patterns-browse ()
  "Open the pattern library browser buffer."
  (interactive)
  (setq arxana-patterns--browser-stack nil)
  (arxana-patterns--browser-render))
#+END_SRC

** Importing pattern libraries

Pattern data usually starts in the flexiarg collections from Futon3.  The ingest shim converts every `.flexiarg` entry into Futon entities, links them to pattern languages, and registers each language inside the shared catalog so `/ego` lookups stay consistent.

- `M-x arxana-patterns-list-languages` lists languages plus the number of linked patterns.
- `M-x arxana-patterns-ingest-directory` ingests an entire directory and optionally wires the results into a named language.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-patterns-ingest.el
;;; arxana-patterns-ingest.el --- Import flexiarg pattern libraries -*- lexical-binding: t; -*-

;;; Commentary:
;; Read pattern `.flexiarg` files from a directory, convert each entry
;; into Futon pattern/component entities, and wire them together using
;; `:pattern/includes` relations.  An optional pattern-language entity
;; can also be created so callers can browse the ordered collection via
;; Futon's `/ego` endpoint.

;;; Code:

(require 'cl-lib)
(require 'seq)
(require 'subr-x)

(require 'arxana-store)

(defgroup arxana-patterns-ingest nil
  "Settings for ingesting flexiarg pattern libraries."
  :group 'arxana)

(defcustom arxana-patterns-ingest-ego-limit 128
  "How many links to request when fetching `/ego` data during ingest."
  :type 'integer
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-relation ":pattern-language/includes"
  "Relation label used when wiring languages to their member patterns."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-source-relation ":language/source"
  "Relation label used when tagging pattern languages with their source."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-status-relation ":language/status"
  "Relation label used when tagging pattern languages with their status."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-catalog-name "pattern-language/catalog"
  "Entity name that collects every known pattern language."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-catalog-relation ":language/catalog"
  "Relation label used when linking languages into the catalog."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-default-ad-hoc-status "pattern-language/status/draft"
  "Default status entity name for ad-hoc pattern languages."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-default-canonical-status "pattern-language/status/published"
  "Default status entity name for canonical pattern languages (futon3/library)."
  :type 'string
  :group 'arxana-patterns-ingest)

(defun arxana-patterns-ingest--flexiarg-files (directory)
  "Return absolute `.flexiarg` paths under DIRECTORY sorted by mtime (desc)."
  (let* ((dir (file-name-as-directory (expand-file-name directory)))
         (candidates (directory-files dir t "\\.flexiarg\\'" t)))
    (seq-sort (lambda (a b)
                (let ((ta (nth 5 (file-attributes a 'string)))
                      (tb (nth 5 (file-attributes b 'string))))
                  (time-less-p tb ta)))
              candidates)))

(defun arxana-patterns-ingest--canonical-directory-p (directory)
  "Return non-nil when DIRECTORY appears to live under futon3/library."
  (let ((path (file-name-as-directory (expand-file-name directory))))
    (string-match-p (regexp-quote "/futon3/library/") path)))

(defun arxana-patterns-ingest--language-source-name (directory)
  "Return the classification entity name for DIRECTORY's source."
  (if (arxana-patterns-ingest--canonical-directory-p directory)
      "pattern-language/source/futon3-library"
    "pattern-language/source/ad-hoc"))

(defun arxana-patterns-ingest--language-status-name (directory explicit)
  "Return the classification entity for language status.
When EXPLICIT is non-nil, return it; otherwise derive from DIRECTORY."
  (cond
   ((and explicit (not (string-empty-p explicit))) explicit)
   ((arxana-patterns-ingest--canonical-directory-p directory)
    arxana-patterns-ingest-default-canonical-status)
   (t arxana-patterns-ingest-default-ad-hoc-status)))

(defun arxana-patterns-ingest--trim-empty-lines (lines)
  "Remove blank lines from the start/end of LINES."
  (let ((result lines))
    (while (and result (string-match-p "\\`[[:space:]]*\\'" (car result)))
      (setq result (cdr result)))
    (let ((rev (nreverse result)))
      (while (and rev (string-match-p "\\`[[:space:]]*\\'" (car rev)))
        (setq rev (cdr rev)))
      (nreverse rev))))

(defun arxana-patterns-ingest--slugify (text)
  "Return a lowercase slug derived from TEXT."
  (let* ((lower (downcase (or text "component")))
         (clean (replace-regexp-in-string "[^a-z0-9]+" "-" lower))
         (trimmed (string-trim clean "-" "-")))
    (if (string-empty-p trimmed)
        "component"
      trimmed)))

(defun arxana-patterns-ingest--extract-id (node)
  "Recursively locate an :id/:entity/id entry inside NODE."
  (cond
   ((null node) nil)
   ((and (consp node) (keywordp (car node))
         (memq (car node) '(:id :entity/id)))
    (cdr node))
   ((consp node)
    (or (arxana-patterns-ingest--extract-id (car node))
        (arxana-patterns-ingest--extract-id (cdr node))))
   (t nil)))

(defun arxana-patterns-ingest--lookup-id (name)
  "Fetch NAME via `/ego` and return the associated entity id."
  (when name
    (let* ((response (ignore-errors (arxana-store-ego name 1)))
           (ego (and response (alist-get :ego response)))
           (entity (and ego (alist-get :entity ego))))
      (arxana-patterns-ingest--extract-id entity))))

(defun arxana-patterns-ingest--relation-text (value)
  (let ((raw (cond
              ((keywordp value) (symbol-name value))
              ((symbolp value) (symbol-name value))
              ((stringp value) value)
              (t nil))))
    (when raw
      (if (and (> (length raw) 0) (eq (aref raw 0) ?:))
          (substring raw 1)
        raw))))

(defun arxana-patterns-ingest--relation-match-p (value target)
  "Return non-nil when VALUE and TARGET represent the same relation label."
  (let ((lhs (arxana-patterns-ingest--relation-text value))
        (rhs (arxana-patterns-ingest--relation-text target)))
    (and lhs rhs (string= lhs rhs))))

(defun arxana-patterns-ingest--existing-targets (name relation)
  "Return a hash table of entity ids linked from NAME via RELATION."
  (let* ((response (ignore-errors (arxana-store-ego name arxana-patterns-ingest-ego-limit)))
         (ego (and response (alist-get :ego response)))
         (links (and ego (or (alist-get :outgoing ego)
                             (let ((l (alist-get :links ego)))
                               (and l (alist-get :outgoing l))))))
         (table (make-hash-table :test 'equal)))
    (dolist (link links)
      (when (arxana-patterns-ingest--relation-match-p (alist-get :relation link) relation)
        (let* ((entity (alist-get :entity link))
               (id (arxana-patterns-ingest--extract-id entity)))
          (when id
            (puthash id t table)))))
    table))

(defun arxana-patterns-ingest--ensure-tag (language-name language-id relation target-name target-type)
  "Ensure LANGUAGE-ID points at TARGET-NAME via RELATION."
  (when (and language-name language-id relation target-name)
    (let* ((target-response (arxana-store-ensure-entity :name target-name
                                                        :type target-type
                                                        :source (format "%s classification" relation)
                                                        :external-id target-name))
           (target-id (or (arxana-patterns-ingest--extract-id target-response)
                          (arxana-patterns-ingest--lookup-id target-name)))
           (existing (arxana-patterns-ingest--existing-targets language-name relation)))
      (when (and target-id (not (gethash target-id existing)))
        (arxana-store-create-relation :src language-id
                                      :dst target-id
                                      :label relation)
        (puthash target-id t existing)))))

(defun arxana-patterns-ingest--ensure-catalog-link (language-name language-id)
  "Ensure LANGUAGE-ID is reachable from the central catalog."
  (when (and language-name language-id)
    (let* ((catalog-name arxana-patterns-ingest-language-catalog-name)
           (response (arxana-store-ensure-entity :name catalog-name
                                                 :type "pattern/language-catalog"
                                                 :source "Pattern languages"))
           (catalog-id (or (arxana-patterns-ingest--extract-id response)
                           (arxana-patterns-ingest--lookup-id catalog-name)))
           (existing (when catalog-id
                       (arxana-patterns-ingest--existing-targets
                        catalog-name arxana-patterns-ingest-language-catalog-relation))))
      (when (and catalog-id existing (not (gethash language-id existing)))
        (arxana-store-create-relation :src catalog-id
                                      :dst language-id
                                      :label arxana-patterns-ingest-language-catalog-relation)
        (puthash language-id t existing)))))

(defun arxana-patterns-ingest--ego-outgoing (ego)
  (or (alist-get :outgoing ego)
      (let ((links (alist-get :links ego)))
        (and links (alist-get :outgoing links)))))

(defun arxana-patterns-ingest--link-target-name (link)
  (let* ((entity (alist-get :entity link)))
    (or (alist-get :name entity)
        (alist-get :entity/name entity)
        (alist-get :ident entity)
        (alist-get :entity/ident entity))))

(defun arxana-patterns-ingest--language-metadata (language-name)
  "Return plist of metadata for LANGUAGE-NAME using `/ego`."
  (let* ((response (ignore-errors (arxana-store-ego language-name arxana-patterns-ingest-ego-limit)))
         (ego (and response (alist-get :ego response)))
         (entity (and ego (alist-get :entity ego)))
         (title (or (alist-get :external-id entity)
                    (alist-get :entity/external-id entity)
                    language-name))
         (outgoing (arxana-patterns-ingest--ego-outgoing ego))
         (source nil)
         (status nil)
         (count 0))
    (dolist (link outgoing)
      (let ((rel (alist-get :relation link)))
        (cond
         ((arxana-patterns-ingest--relation-match-p rel arxana-patterns-ingest-language-relation)
          (setq count (1+ count)))
         ((and (not source)
               (arxana-patterns-ingest--relation-match-p rel arxana-patterns-ingest-language-source-relation))
          (setq source (arxana-patterns-ingest--link-target-name link)))
         ((and (not status)
               (arxana-patterns-ingest--relation-match-p rel arxana-patterns-ingest-language-status-relation))
          (setq status (arxana-patterns-ingest--link-target-name link))))))
    (list :name language-name
          :title title
          :source source
          :status status
          :count count)))

;;;###autoload
(defun arxana-patterns-list-languages ()
  "Display a summary of known pattern languages and their status."
  (interactive)
  (unless (arxana-store-sync-enabled-p)
    (user-error "Futon sync is disabled; enable futon4-enable-sync first"))
  (let* ((catalog arxana-patterns-ingest-language-catalog-name)
         (response (ignore-errors (arxana-store-ego catalog arxana-patterns-ingest-ego-limit)))
         (ego (and response (alist-get :ego response)))
         (outgoing (and ego (arxana-patterns-ingest--ego-outgoing ego)))
         (language-names (delq nil
                               (mapcar (lambda (link)
                                         (when (arxana-patterns-ingest--relation-match-p
                                                (alist-get :relation link)
                                                arxana-patterns-ingest-language-catalog-relation)
                                           (arxana-patterns-ingest--link-target-name link)))
                                       outgoing))))
    (if (seq-empty-p language-names)
        (message "No pattern languages are registered yet")
      (let* ((rows (mapcar #'arxana-patterns-ingest--language-metadata language-names))
             (buffer (get-buffer-create "*Arxana Pattern Languages*")))
        (with-current-buffer buffer
          (let ((inhibit-read-only t))
            (erase-buffer)
            (insert (format "%-32s %-24s %-24s %s\n"
                            "Language" "Source" "Status" "Patterns"))
            (insert (make-string 90 ?-) "\n")
            (dolist (row rows)
              (insert (format "%-32s %-24s %-24s %d\n"
                              (plist-get row :name)
                              (or (plist-get row :source) "?")
                              (or (plist-get row :status) "?")
                              (plist-get row :count))))
            (goto-char (point-min))
            (special-mode)))
        (display-buffer buffer)))))

(defun arxana-patterns-ingest--section (label lines)
  (let* ((clean-lines (arxana-patterns-ingest--trim-empty-lines (nreverse lines)))
         (text (string-trim-right (mapconcat #'identity clean-lines "\n"))))
    (list :label label
          :slug (arxana-patterns-ingest--slugify label)
          :text text)))

(defun arxana-patterns-ingest--parse-flexiarg (path)
  "Parse PATH and return a plist describing the pattern contents."
  (with-temp-buffer
    (insert-file-contents path)
    (goto-char (point-min))
    (let ((meta nil)
          (sections nil)
          (current nil))
      (while (not (eobp))
        (let ((line (buffer-substring-no-properties (line-beginning-position)
                                                    (line-end-position))))
          (cond
           ((string-match "^@\\([^[:space:]]+\\)\\s-+\\(.*\\)$" line)
            (let ((key (intern (concat ":" (downcase (match-string 1 line)))))
                  (value (string-trim (match-string 2 line))))
              (setq meta (plist-put meta key value))))
           ((string-match "^[[:space:]]*\([!+]\)\\s-*\\([^:]+\\):?\\s*$" line)
            (when current
              (push (arxana-patterns-ingest--section (plist-get current :label)
                                                     (plist-get current :lines))
                    sections))
            (setq current (list :label (string-trim (match-string 2 line))
                                :lines nil)))
           ((and current)
            (setf (plist-get current :lines)
                  (cons line (plist-get current :lines))))))
        (forward-line 1))
      (when current
        (push (arxana-patterns-ingest--section (plist-get current :label)
                                               (plist-get current :lines))
              sections))
      (let ((name (plist-get meta :arg)))
        (unless (and name (not (string-empty-p name)))
          (user-error "Missing @arg in %s" path))
        (let* ((title (plist-get meta :title))
               (ordered (nreverse sections))
               (first (car ordered)))
          (list :name name
                :title title
                :summary (or (plist-get first :text) "")
                :components ordered
                :meta meta))))))

(defun arxana-patterns-ingest--component-name (pattern index component)
  (format "%s/%02d-%s" pattern index (plist-get component :slug)))

(defun arxana-patterns-ingest--ensure-pattern (pattern)
  (let* ((response (arxana-store-ensure-entity :name (plist-get pattern :name)
                                               :type "pattern/library"
                                               :source (plist-get pattern :summary)
                                               :external-id (plist-get pattern :title)))
         (id (or (arxana-patterns-ingest--extract-id response)
                 (arxana-patterns-ingest--lookup-id (plist-get pattern :name)))))
    id))

(defun arxana-patterns-ingest--ensure-component (pattern-id pattern-name component index existing)
  (let* ((component-name (arxana-patterns-ingest--component-name pattern-name index component))
         (response (arxana-store-ensure-entity :name component-name
                                               :type "pattern/component"
                                               :source (plist-get component :text)
                                               :external-id (plist-get component :label)))
         (component-id (or (arxana-patterns-ingest--extract-id response)
                           (arxana-patterns-ingest--lookup-id component-name))))
    (when (and pattern-id component-id
               (or (not existing) (not (gethash component-id existing))))
      (arxana-store-create-relation :src pattern-id
                                    :dst component-id
                                    :label ":pattern/includes")
      (when existing
        (puthash component-id t existing)))
    component-id))

(defun arxana-patterns-ingest--ingest-file (path)
  "Ingest a single flexiarg PATH, returning plist with :name and :id."
  (let* ((data (arxana-patterns-ingest--parse-flexiarg path))
         (pattern-id (arxana-patterns-ingest--ensure-pattern data))
         (existing (arxana-patterns-ingest--existing-targets (plist-get data :name)
                                                             ":pattern/includes"))
         (index 1))
    (dolist (component (plist-get data :components))
      (arxana-patterns-ingest--ensure-component pattern-id (plist-get data :name)
                                                component index existing)
      (setq index (1+ index)))
    (list :name (plist-get data :name)
          :id pattern-id)))

(defun arxana-patterns-ingest--ensure-language (language-name language-title patterns directory language-status)
  "Ensure LANGUAGE-NAME exists and links to PATTERNS in order."
  (let* ((summary (format "Imported from %s" directory))
         (response (arxana-store-ensure-entity :name language-name
                                              :type "pattern/language"
                                              :source summary
               :external-id (or language-title language-name)))
         (language-id (or (arxana-patterns-ingest--extract-id response)
                          (arxana-patterns-ingest--lookup-id language-name)))
         (existing (when language-id
                     (or (arxana-patterns-ingest--existing-targets
                          language-name arxana-patterns-ingest-language-relation)
                         (make-hash-table :test 'equal))))
         (source-name (arxana-patterns-ingest--language-source-name directory))
         (status-name (arxana-patterns-ingest--language-status-name directory language-status)))
    (when (and language-id existing)
      (cl-loop for pattern in patterns
               for order from 1
               for pid = (plist-get pattern :id)
               when (and pid (not (gethash pid existing)))
               do (progn
                    (arxana-store-create-relation :src language-id
                                                  :dst pid
                                                  :label arxana-patterns-ingest-language-relation
                                                  :props (list (cons 'order order)))
                    (puthash pid t existing))))
      (arxana-patterns-ingest--ensure-tag language-name language-id
                                          arxana-patterns-ingest-language-source-relation
                                          source-name "pattern/language-source")
      (arxana-patterns-ingest--ensure-tag language-name language-id
                                          arxana-patterns-ingest-language-status-relation
                                          status-name "pattern/language-status")
      (arxana-patterns-ingest--ensure-catalog-link language-name language-id)))

;;;###autoload
(defun arxana-patterns-ingest-directory (directory &optional language-name language-title language-status)
  "Ingest `.flexiarg` files under DIRECTORY.
When LANGUAGE-NAME is non-nil, ensure a pattern-language entity links to
all imported patterns using reverse modification time order. LANGUAGE-TITLE
becomes the entity's external id. LANGUAGE-STATUS lets callers override the
auto-detected status classification."
  (interactive
   (let* ((dir (read-directory-name "Flexiarg directory: " nil nil t))
          (raw-name (string-trim (read-string "Pattern language name (blank to skip): ")))
          (name (unless (string-empty-p raw-name) raw-name))
          (title (when name
                   (let ((val (string-trim (read-string "Pattern language title (optional): "))))
                     (unless (string-empty-p val) val))))
          (status (when name
                    (let* ((default (arxana-patterns-ingest--language-status-name dir nil))
                           (prompt (format "Pattern language status (default %s): " default))
                           (val (string-trim (read-string prompt nil nil default))))
                      (unless (string-empty-p val) val)))))
     (list dir name title status)))
  (unless (arxana-store-sync-enabled-p)
    (user-error "Futon sync is disabled; enable futon4-enable-sync first"))
  (let* ((dir directory)
         (files (arxana-patterns-ingest--flexiarg-files dir)))
    (unless files
      (user-error "No .flexiarg files found in %s" dir))
    (let ((results nil))
      (dolist (file files)
        (push (arxana-patterns-ingest--ingest-file file) results))
      (setq results (nreverse results))
      (when language-name
        (arxana-patterns-ingest--ensure-language language-name language-title
                                                 results dir language-status))
      (message "Ingested %d patterns from %s" (length results) dir)
      (when language-name
        (message "Language %s id %s" language-name
                 (or (arxana-patterns-ingest--extract-id
                      (arxana-store-ensure-entity :name language-name))
                     (arxana-patterns-ingest--lookup-id language-name))))
      results)))

(provide 'arxana-patterns-ingest)

;;; arxana-patterns-ingest.el ends here
#+END_SRC


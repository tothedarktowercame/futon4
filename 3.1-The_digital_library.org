** The digital library
:PROPERTIES:
:LATEX_LABEL: digital-library
:ID: digital-library
:END:

*** On `article-table'
:PROPERTIES:
:LATEX_LABEL: article-table
:ID: article-table
:END:

We begin with an empty library.


#+BEGIN_SRC elisp
(defvar article-table
  (make-hash-table :test 'equal))
#+END_SRC

*** Structure of articles                                          :noexport:
:PROPERTIES:
:LATEX_LABEL: structure-of-articles
:ID: structure-of-articles
:END:

Every article has a \inp{name}, which can be any LISP object (but is
most frequently a string).  They also have various other standard
sorts of data associated with them; see Note
[[id:definition-of-scholium]] for the particulars.  This data is
referred to by `put-article' collectively as the article's \inp{value}
(but this name is somewhat misleading, because the \inp{name} too is
an important part of the article).  One special sort of article is a
``library subcollection'' -- see Section [[id:subcollections]] for more
information on these things.


*** On `put-article'
:PROPERTIES:
:LATEX_LABEL: put-article
:ID: put-article
:END:

This destructively adjusts the values on the hash table (see
documentation for `puthash').  To \emph{intelligently manage} the
values in the table takes more work, so we typically `get-article'
before to make various comparions and adjustments to existing values
before making changes.


#+BEGIN_SRC elisp
(defun put-article (name value)
  (puthash name value article-table))
#+END_SRC

*** On `get-article'

Basically just `gethash', but since the article table is indexed by
\inp{name} and we don't want to pass \inp{name} around all the time,
we add it to the recalled value.


#+BEGIN_SRC elisp
(defun get-article (name)
  (let ((content (gethash name article-table)))
    (when content
      (cons name content))))
#+END_SRC

*** On `name-of-current-article'
:PROPERTIES:
:LATEX_LABEL: name-of-current-article
:ID: name-of-current-article
:END:

The ``current article'' is of special importance for display (an
article is made ``current'' when `display-article' displays it).  The
name of this article is stored in this variable.


#+BEGIN_SRC elisp
(defvar name-of-current-article nil)

(defun current-article ()
  (get-article name-of-current-article))
#+END_SRC

*** Futon1 synchronization primitives
:PROPERTIES:
:LATEX_LABEL: futon1-sync-primitives
:ID: futon1-sync-primitives
:END:

Arxana can treat Futon1 as the backing graph service.  The helpers
below provide lightweight HTTP glue that other commands can call when
they want to mirror in-memory operations to Futon1's API.


#+BEGIN_SRC elisp
(require 'json)
(require 'url)

(defgroup futon4 nil
  "Arxana <-> Futon1 integration."
  :group 'tools)

(defcustom futon4-base-url "http://localhost:8080/api/alpha"
  "Base URL for Futon1 API (ASCII alias for /api/Î±)."
  :type 'string)

(defcustom futon4-enable-sync t
  "When non-nil, mirror article and relation edits to Futon1."
  :type 'boolean)

(defcustom futon4-log-requests nil
  "When non-nil, log each Futon1 POST and its JSON payload."
  :type 'boolean)

(defun futon4--post-json (path payload &optional cb)
  "POST PAYLOAD as JSON to Futon1 PATH and run CB on the decoded body."
  (when futon4-enable-sync
    (let* ((json-body (json-encode payload))
           (url-request-method "POST")
           (url-request-extra-headers '(("Content-Type" . "application/json")))
           (url-request-data (encode-coding-string json-body 'utf-8)))
      (when futon4-log-requests
        (message "futon4 POST %s %s" path json-body))
      (condition-case err
          (url-retrieve
           (concat futon4-base-url path)
           (lambda (_status)
            (goto-char (point-min))
            (when (re-search-forward "\n\n" nil t)
               (let* ((json-object-type 'alist)
                      (json-array-type 'list)
                      (json-key-type 'keyword)
                      (body (ignore-errors (json-read))))
                 (when cb (funcall cb body))))
             (let ((buf (current-buffer)))
               (when (buffer-live-p buf)
                 (kill-buffer buf)))))
        (error
         (message "futon4 request to %s failed: %S" path err))))))

(defun futon4--canonical-path (path)
  "Return a canonicalized representation of PATH, or nil."
  (when path
    (convert-standard-filename (expand-file-name path))))

(defun futon4--article-id (path)
  "Build a stable Futon1 article id from PATH or BUFFER name."
  (when path
    (concat "arxana:article:" (format "%s" path))))

(defvar futon4--article-id-cache (make-hash-table :test 'equal)
  "Cache mapping scholium names to Futon1 ids.")

(defun futon4-register-article (name id)
  "Remember that NAME corresponds to Futon1 article ID."
  (when (and name id)
    (puthash name id futon4--article-id-cache)
    id))

(defun futon4-lookup-article-id (name)
  "Return Futon1 article id cached for NAME, if any."
  (and name (gethash name futon4--article-id-cache)))

(defun futon4--article-id-for (name &optional path)
  "Return or derive the Futon1 id for NAME, optionally using PATH."
  (or (futon4-lookup-article-id name)
      (let ((derived (futon4--article-id (or path name))))
        (when derived
          (futon4-register-article name derived)))))

(defun futon4--link-label (link)
  "Return a readable label string for LINK's metadata."
  (let ((meta (cdr-safe link)))
    (if meta
        (mapconcat (lambda (piece)
                     (cond
                      ((stringp piece) piece)
                      ((symbolp piece) (symbol-name piece))
                      (t (format "%S" piece))))
                   meta
                   " | ")
      "")))

(defun futon4--sync-about-links (source-name about)
  "Mirror ABOUT links for SOURCE-NAME into Futon1."
  (when (and futon4-enable-sync about)
    (let ((src-id (futon4-lookup-article-id source-name)))
      (when src-id
        (dolist (link about)
          (let* ((target (car-safe link))
                 (dst-id (and target
                              (futon4--article-id-for target))))
            (when dst-id
              (futon4-store-nema-simple src-id dst-id
                                        (futon4--link-label link)))))))))

(defun futon4--article-context-for-buffer (buffer)
  "Return plist with :id, :name, and :path for BUFFER."
  (let* ((path (or (futon4--canonical-path (buffer-file-name buffer))
                   (buffer-name buffer)))
         (id (futon4--article-id path))
         (name (buffer-name buffer)))
    (list :id id :name name :path path)))

(defun futon4-ensure-article-entity (id name path &optional spine-p cb)
  "Ensure Futon1 has an article entity with ID, NAME, and PATH.
SPINE-P marks the article as belonging to the current spine when non-nil.
CB is an optional callback that receives the decoded response body."
  (when id
    (let* ((props-alist (delq nil (list (when path
                                          (cons 'path path))
                                        (when spine-p
                                          (cons 'spine t)))))
           (payload (delq nil (list (cons 'id id)
                                    (cons 'name (if (symbolp name)
                                                    (symbol-name name)
                                                  name))
                                    (cons 'type "arxana/article")
                                    (when props-alist
                                      (cons 'props props-alist))))))
      (futon4--post-json "/entity" payload cb))))

(defun futon4-store-nema-simple (src-id dst-id &optional label cb)
  "Store a simple scholium-style relation between SRC-ID and DST-ID."
  (when (and src-id dst-id)
    (futon4--post-json
     "/relation"
     `((type . "arxana/scholium")
       (src . ,src-id)
       (dst . ,dst-id)
       (props . ((label . ,(or label "")))))
     cb)))
#+END_SRC

*** What about using the file system?                              :noexport:

If the library is being updated by many people at different times, it
may also make sense to read documents from a file system on the fly.
Indeed, the program does support files and buffers.  But the article
table is still a decent \emph{model} -- similar in nature to a
library's \emph{catalog}.

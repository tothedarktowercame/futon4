** Sorting scholia for markup purposes
:PROPERTIES:
:LATEX_LABEL: sorting
:ID: sorting
:END:

*** Introduction to sorting scholia                                :noexport:

The main function in this section is `sort-scholia-by-beg-position',
which is called by `mark-things-up'.

The use for this function is to put scholia in the order in which they
will be rendered; the order is given by sorting the scholia on their
\inp{about} data.  Since there are several different kinds of
\inp{about} data, the sorting criteria are a little complicated.  For
one thing, each scholium may be about several different articles, but
here we only want to sort relative to their relationship to one given
article.

The criterion we use when sorting is: scholia that are about the whole
article go first; then, we rank any other scholia according to their
\emph{first} beginning position.  (Thus, any scholia that are about
several regions within the same article need to have a subsidiary sort
done to order the indicated regions; this is accomplished, as
needed, by the function `first-beginning-about-article', below.)


*** On `first-beginning-about-article'

Return 0 if \inp{about} is about all of \inp{article}, i.e., otherwise
return the character position of the first region within \inp{article}
that \inp{about} is actually about.  If there is none, return nil.
(Actually, let me note that in the usage we have established so far,
we would already know that in the case that \inp{about} is a string,
it is about the article here, and in the case that \inp{about} is a
one-layer list, similarly; so some of the tests we do here are as yet
unneeded.)

Here we're assuming that if there is \emph{some} link to the article
that isn't a passage link, then we treat the link as about the article
as a whole.  The case in which the link is about the whole article
\emph{and} some part of the article might possibly be better treated
some other way; but I'll leave that case for subsequent work.


#+BEGIN_SRC elisp
(defun first-beginning-about-article (about article)
  (cond
   ;; condition for the scholium to be about the article as a whole.
   ;; The condition is that there is _some_ link to the article that
   ;; is NOT a ``passage''-type link.  In this case, we just return 0.
   ((member-if (lambda (link) 
                 (and (equal (car link) article)
                      (not (link-type-accessor link 'passage))))
               about)
    0)
   ;; else, collect the regions of `article' that `about' indicates,
   ;; and sort them.
   (t
    (let* ((marking-links
            (let (marked)
              (mapc (lambda (elt)
                      (when (and
                             (typedata-includes-passage (link-type elt))
                             (equal (linked-to-article elt) article))
                        (setq marked (cons elt marked))))
                    about)
              marked))
           (earliest-link
            (car (sort
                  marking-links
                  (lambda (link1 link2)
                    (< (link-beginning link1)
                       (link-beginning link2)))))))
      (link-beginning earliest-link)))))
#+END_SRC

*** On `sort-scholia-by-beg-position'
:PROPERTIES:
:LATEX_LABEL: sort-scholia-by-beg-position
:ID: sort-scholia-by-beg-position
:END:

This function orders \inp{scholia} according to the magnitude of the
smallest beginning a region of \inp{article} that the input scholia
mark.  All links are considered when finding the first marked region.


#+BEGIN_SRC elisp
(defun sort-scholia-by-beg-position (scholia article)
  (setq
   scholia
   (sort scholia
         (lambda (scholium1 scholium2)
           (let ((beg1 (first-beginning-about-article 
                        (scholium-about scholium1)
                        article))
                 (beg2 (first-beginning-about-article
                        (scholium-about scholium2)
                        article)))
             (and beg1
                  beg2
                  (< beg1 beg2)))))))
#+END_SRC

*** Incremental markup                                             :noexport:
:PROPERTIES:
:LATEX_LABEL: incremental-markup
:ID: incremental-markup
:END:

Instead of sorting everything each time we display, it would be nice
to handle things incrementally: just add new markup for the newly
created scholium, and store things in their natural order after
reparsing.  I think that this approach should work, but it would
involve making a number of changes to the code.  (Note that
in the setup we're using, updates to metadata may have to be
wholesale, even if updates to text properties are incremental.)


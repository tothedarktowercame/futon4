** Committing edits
:PROPERTIES:
:LATEX_LABEL: committing
:ID: committing
:END:

*** Themes for committing                                          :noexport:

(1) Store stuff to metadata articles;
(2) Prefer these for rendering purposes.


*** Committing implications                                        :noexport:

Edits to any part of a scholium (in particular, to its \inp{name},
\inp{text}, \inp{about}, or \inp{type} data) need to be saved and
otherwise processed.  Sometimes changes in one article will result in
changes to other articles, e.g., \emph{changing \inp{about} data may
  lead to changes in backlinks}; and changes to \inp{text} may lead to
changes in one or more attached scholium's \inp{about} data (Note
[[id:set-updated-about-info]]).


*** Bookkeeping and version managing                               :noexport:

When articles have been modified, \inp{bookkeeping} data needs to be
updated.  In particular, we are supposed save sufficient data to move
back and forth between article versions.  This is true of both
\inp{text} data and the other data that make up articles (\inp{name}
may be handled somewhat differently, but in general we need to store
enough data to move between all versions of the article).


*** Setting updated `about' information                            :noexport:
:PROPERTIES:
:LATEX_LABEL: set-updated-about-info
:ID: set-updated-about-info
:END:

The idea of preferring metadata articles when rendering has been
discussed in the section on metadata articles (Section
[[id:metadata-articles]] and Note [[id:updating-link-extent]] in
particular), and is reflected in the way `mark-things-up' is written
(Note [[id:mark-things-up]]).  For this all to work, it is necessary
for `commit-edits' to store updated \inp{about} data when it runs.


*** On `store-link-masks'
:PROPERTIES:
:LATEX_LABEL: store-link-masks
:ID: store-link-masks
:END:

This function runs within the scope of `commit-edits', after
`adjusted-markup' has been found by parsing (Note [[id:commit-edits]]).
Indeed, so far, this is the only significant default action of
`commit-edits' (cf. Note [[id:set-updated-about-info]]).

The function compares the elements of `current-markup' (Note
[[id:current-markup]]) to the elements of `adjusted-markup'.  When
changes are present in the markup data, `store-link-masks' adds or
changes masks.

More precisely, for each element of `current-markup', we select
from `adjusted-markup' those elements with the same link-id
(or maybe mask-id).   These are the `matching-regions' corresponding
to that markup element.  Unless there is only one matching region
and this matching region happen to point to extend over exactly
the range specified by the original link, we execute an operation
on masks.

This operation is to swap in a replacement mask, if the markup
element was coming from a mask already, or to create a brand new
mask otherwise.  If we're doing a replacement, we look for the
\emph{one} mask that corresponds to the link-id borne by the
current markup element.  We then substitute \emph{all} of the
matching regions, for whatever was previously stored in this mask.

Otherwise, we just create a new mask with the appropriate link-id,
containing the relevant regions.


#+BEGIN_SRC elisp
(defun store-link-masks ()
  (dolist (link-ext current-markup)
    (let* ((matching-regions (remove-if
                              (lambda (markup-item)
                                (not (equal (car markup-item)
                                            (car link-ext))))
                              adjusted-markup))
           (num-matching-regions (length matching-regions))
           (name-of-linking-article (if (eq (first
                                             (car link-ext)) 'mask)
                                        (first (second
                                                (first link-ext)))
                                      (first (first link-ext)))))
      (unless (and (eq num-matching-regions 1)
                   (equal (cdr (first matching-regions))
                          (cdr link-ext)))
        (if (eq (caar link-ext) 'mask)
            ;; swap in a different mask
            (let* ((masks
                    (get-metadata-field 'masks
                                        name-of-linking-article))
                   (current-mask-headed
                    (member-if (lambda (item)
                                 (equal (second (car link-ext))
                                        (car item)))
                               masks)))
              (setcdr (car current-mask-headed)
                      (mapcar (lambda (ided-reg) 
                                (cdr ided-reg))
                              matching-regions))
              (put-metadata-field 'masks
                                  masks
                                  name-of-linking-article))
          ;; create a new mask
          (let ((masks (or (get-metadata-field
                            'masks
                            name-of-linking-article)
                           (list 'masks))))
            (put-metadata-field
             'masks
             (setcdr
              masks
              (add-to-or-start-list
               (cdr masks)
               `(,(car link-ext)
                 ,@(mapcar (lambda (ided-reg) (cdr ided-reg))
                           matching-regions))))
             name-of-linking-article)))))))
#+END_SRC

*** Adding new markup to rendered articles                         :noexport:
:PROPERTIES:
:LATEX_LABEL: adding-new-markup-to-rendered-articles
:ID: adding-new-markup-to-rendered-articles
:END:

Adding new markup to rendered articles
will introduce a discrepancy
between `adjusted-markup' and `current-markup', i.e., items
will be found that weren't there before.  This shouldn't,
be a problem, because `store-link-masks' iterates through the
members of `current-markup' looking for matches.  So, anything
completely new in `adjusted-markup' will be ignored by
the `store-link-masks' phase of the commit process.  This
is relevant to Section [[id:derivative]], and any other code
that modifies the markup of rendered articles.


*** On `commit-edits-hook'
:PROPERTIES:
:LATEX_LABEL: commit-edits-hook
:ID: commit-edits-hook
:END:

This is the single point of customization for the commit function,
to be used in future sections.  It runs within the scope of
`commit-edits', after `adjusted-markup' has been found
by parsing.  Thus, functions that are added to this hook can
take advantage of this knowledge about the current state of
markup.


#+BEGIN_SRC elisp
(defvar commit-edits-hook nil)
#+END_SRC

*** On `after-committing-edits-hook'
:PROPERTIES:
:LATEX_LABEL: after-committing-edits-hook
:ID: after-committing-edits-hook
:END:

This facilitates additional actions after the main committing
routines are finished.


#+BEGIN_SRC elisp
(defvar after-committing-edits-hook nil)
#+END_SRC

*** Summary of idea behind `commit-edits'                          :noexport:

When you edit the buffer, the text properties showing where scholia
are attached move around.  When you run `commit-edits', metadata
indicating the new position of these regions is stored; it will be
used subsequently so that the correct regions are highlighted.  (These
suggestions coming can later be incorporated into the scholia by their
authors.)  Furthermore, `commit-edits' stores a version of the article
for subsequent browsing.


*** On `commit-edits'
:PROPERTIES:
:LATEX_LABEL: commit-edits
:ID: commit-edits
:END:

Anything run by the `commit-edits-hook' that changes the text of the
article being committed should store the desired value on
`adjusted-text'.  It is going to take a bit of thinking about how to
make several functions (particularly functions having to do with
derivatives) run properly, in serial.  (But I'm pretty sure it can be
done.)

Note that when committing we currently make sure that exactly one
newline is attached to the end of the page when the text is
saved.  This has a beneficial effect on exporting the scholium
system (see [[id:export-scholium-system]]).

We may at some point want one or more commit functions that will store
more different kinds of edits from more different places.  For
example, we'll want to be able to commit edits that take place in the
Scholia Display buffer.  Similarly for edits to `about' data, and so
forth (see Note [[id:editing-about-data]]).


#+BEGIN_SRC elisp
(defun commit-edits ()
  (interactive)
  (let* ((adjusted-markup (copy-tree (detect-scholia-structure)))
         (old-contents (get-article name-of-current-article))
         (adjusted-text (buffer-substring-no-properties (point-min)
                                                        (point-max)))
         (old-text (scholium-text old-contents)))
    (store-link-masks)
    (run-hooks 'commit-edits-hook)
    ;; here is where the criterion for checking that some change has
    ;; actually been made would be inserted
    (when (not (equal adjusted-text old-text))
      (scholium name-of-current-article
                (with-temp-buffer (insert adjusted-text)
                                  (goto-char (point-max))
                                  (insert "\n")
                                  (delete-blank-lines)
                                  (buffer-substring-no-properties
                                   (point-min)
                                   (point-max)))
                ;; of course, for more advanced versions of
                ;; this code, these won't be static
                (scholium-about old-contents)
                (scholium-type old-contents)
                ;; this should be reformatted to store the old
                ;; version!
                (scholium-bookkeeping old-contents)))
    (run-hooks 'after-committing-edits-hook)))
#+END_SRC

*** After committing, redisplay article

Hopefully this won't cause any problems.  The one concerning point I
can think of might come up when committing fully rendered and
identified compilations (Section [[id:quick-compilations]]), but we
haven't worked out the major details of that yet, so there's no reason
to worry about this one minor one.


#+BEGIN_SRC elisp
(add-hook 'after-committing-edits-hook 'redisplay-article)
#+END_SRC

*** Shortcomings of the basic commit implementation                :noexport:

Old comments should continue to apply verbatim to the old version of
the document -- and also, tentatively, to the new version.  Maybe
masks should contain information about which version of the article
they apply to.  A given link could have a collection of masks, each
relevant to a different version of the article being linked to
(perhaps recycling content when the masks are known to be the same).

And, of course, commiting is going to have to store a version of the
article on the \inp{bookkeeping} list (or equivalent; see Note
[[id:vc-and-filesystem-support]]).  We will then want support for
\emph{version browsing} -- hopefully the browsing functions can be
made to ``just work'' on data coming in with an explicit version
number.

And, in addition, we should be updating backlinks as needed.

(These items should be assessed to see how critical they are; it seems
to me that we can probably work with things roughly as they are, if we
aren't doing anything too wild.  It would be interesting to document
the process of coming to rely more heavily on the system as time goes
by.)

Another nice thing would be to make sure that there is a
newline at the end of the committed text.


*** Assigning masks after reparsing                                :noexport:
:PROPERTIES:
:LATEX_LABEL: send-messages-to-redirected-scholia
:ID: send-messages-to-redirected-scholia
:END:

We send a message to each of the scholia that have been redirected
after editing has taken place (cf. Note [[id:masks]]).  In order to do
this, we have to compare the new markup data with the old markup data
to figure out what will change.  We may want to keep a buffer-local
record of the original markup data in order to figure out precisely
what has changed.  (I think for now we just assume that there is one
rendered article at a time, so we only keep track of one set of old
markup data.  But don't quote me on that.)

Alternatively, we could mask \emph{everything}, regardless of whether
or not this data has actually changed, but this seems rather silly,
and potentially very inefficient besides.  So we don't do that.


*** Similarity of deleting and committing                          :noexport:
:PROPERTIES:
:LATEX_LABEL: similarity-of-deleting-and-committing
:ID: similarity-of-deleting-and-committing
:END:

Note that deleting is probably going to be similar to committing, in
terms of the way changes to \inp{about} data are reported and stored.
(See Section [[id:deletion]].)


*** Where to store committed edits                                 :noexport:

One thing I'm somewhat curious about is whether it is ever safe to
assume that we can make changes to an attached scholium
\emph{directly}, without waiting for its owner's input.  It seems more
likely that we would want to put the updated information on that
scholium's \emph{metadata article}, which is its ``world-writable''
space (see Note [[id:metadata-article-overview]]).  If we do this,
that means that the routine we use to find a scholium's \inp{about}
data when rendering a given article may have to look at the scholium's
metadata article.  (The case in which the same person owns both
articles might be one case in which we would wish to make changes
directly.)


*** The role of metadata                                           :noexport:
:PROPERTIES:
:LATEX_LABEL: role-of-metadata
:ID: role-of-metadata
:END:

If we assume that changes aren't made directly, then the owner of the
scholium whose metadata article has been changed will have the
opportunity to accept or decline the suggested changes.  Note that if
the author doesn't accept the changes, then the rest of the world may
still have the option to use \inp{about} data from the metadata
article instead of from the article itself.  Also note that even if a
commentator retracts remarks for some updated version of the article,
they may continue to apply to earlier versions.

When a commentator accepts changes, most likely what will happen is
that a new version of the scholium will be created, and the specific
suggestions removed from its metadata article.  However, if the
suggestion is declined, most likely the suggestions will stay on the
metadata article.  (This situation seems a bit backwards.)
Alternatively, if the suggestions are declined, the author might just
delete them (if we make it so that anyone can make changes to the
metadata article -- which might be reasonable).

For more on this topic, see Section
[[id:responding-to-incoming-metadata]].


*** The possibility for conflicts in backpropagated `about' data   :noexport:
:PROPERTIES:
:LATEX_LABEL: conflicts-in-masks
:ID: conflicts-in-masks
:END:

The potential for conflicts in suggested changes coming from edits to
various different articles exists, in theory, but I think it is
dispatched by the fact that each region is drawn from exactly one
article. So, as long as each link is kept up-to-date with respect to
any changes in the one article that it applies to, there won't be any
conflict.


*** Conflicts in a distributed environment                         :noexport:
:PROPERTIES:
:LATEX_LABEL: conflicts-in-a-distributed-environment
:ID: conflicts-in-a-distributed-environment
:END:

Of course it is the case that if the same article is being changed or
even just talked about in several different places, or if it is a
scholium that applies to several articles that reside in different
repositories, many different sorts of conflicts could arise.  The task
of assimilating changes from various locations should be given at
least partial support in code.


*** Committing and reverting                                       :noexport:

Note that ``revert'' is in some weak sense an opposite action to
``commit''.  (See also Note
[[id:similarity-of-deleting-and-committing]].)


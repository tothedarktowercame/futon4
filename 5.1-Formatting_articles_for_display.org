** Formatting articles for display
:PROPERTIES:
:LATEX_LABEL: formatting-articles
:ID: formatting-articles
:END:

*** ``Formatting'' versus ``display'' versus ``rendering''         :noexport:
:PROPERTIES:
:LATEX_LABEL: why-we-say-rendering
:ID: why-we-say-rendering
:END:

The term ``formatting'' seems to capture a specific notion of
producing a user-visible version of an arbitrary article, that is then
``displayed''.  ``Rendering'' is meant to capture a more general idea,
which includes non-user-visable features (e.g. invisible text
properties).  Some sorts of articles will require further work to
``render'' (see Note [[id:transformative]] and Note
[[id:functional]]).


*** Generality, or lack thereof, in the rendering system developed here :noexport:

It woulb be great to have all sorts of different kinds of rendering
systems.  (For one example additional to those mentioned in
[[id:why-we-say-rendering]], see Note
[[id:interactive-and-actionable-scholia]]; we could supply other
examples!)  For now, we have limited ourselves to something pretty
basic.


*** Producing plain text                                           :noexport:

The function `sch-plain-text' uses various criteria to render scholium
system objects as a string (the collection of acceptable objects is
the same as the collection of link targets, plus articles specified
simply by name).  Its behavior can be fine-tuned by changing the
variable `sch-plain-text-hook'.


*** On `sch-plain-text-hook'
:PROPERTIES:
:LATEX_LABEL: sch-plain-text-hook
:ID: sch-plain-text-hook
:END:

Alternative ways of setting the return value of `sch-plain-text'.


#+BEGIN_SRC elisp
(defvar sch-plain-text-hook nil)
#+END_SRC

*** On `sch-plain-text'
:PROPERTIES:
:LATEX_LABEL: sch-plain-text
:ID: sch-plain-text
:END:

This function is called by `mark-up-scholium' to render scholia that
are to be displayed alongside the main article, and also by
`transclude-article' (see Note [[id:transclude-article]]) and other
functions in Section [[id:transclusion]].

Its goal is to turn arbitrary articles into strings.  This will be
done in different ways depending on the sort of article in question.
(And could be done in other ways depending on other stuff.)  Compare
Note [[id:user-crafted-semantics]].

Here's how it works: different kinds of ``objects'' are to be
distinguished from one another by simple tests -- is the `car' equal
to \verb|passage|?  Does looking up the object in the article table
produce anything?  Then act as appropriate, grabbing the text that is
specified.  Currently it works on input \emph{article names} or
input \emph{articles}.  (If input is both the name of an article
and an article, it will be treated as a name.)

Another thing that might be handy to be able to process is
\emph{simple strings}, which aren't article names, or articles
(obviously).

Note that links are rendered differently depending on context.

Links can't actually run from arbitrary object to arbitrary
object within the current version of the system.  That can
probably be fixed easily.

Converting the function to render scholium system objects in general
is a step towards answering the request in Note
[[id:name-of-current-article]] about extending the purview of
`display-article'.  At that point, it will take more than just a
\inp{title} as argument, certainly; and it will need a ``triage''
phase in order to figure out what sort of object it has been applied
to; various modifications will have to be made so that it can be
applied to various sorts of objects.


#+BEGIN_SRC elisp
(defun sch-plain-text (title-or-article)
  ;; this overloading of the input & reliance upon `get-article' to
  ;; sort things out... could probably be revised into something
  ;; better
  (let* ((obj (or (get-article title-or-article)
                  title-or-article))
         (text (scholium-text obj))
         (type (scholium-type obj))
         ret)
    ;; This seems like the correct way to override a `cond' form.
    (run-hooks 'sch-plain-text-hook)
    (when (not ret)
      (cond
       ((bufferp text)
        (save-excursion (set-buffer (get-buffer text))
                        (setq ret (buffer-string))))
       ((typedata-includes type 'file)
        (let ((bufs (buffer-list))
              (live nil))
          (while (and bufs (not live))
            (when (equal (buffer-file-name (car bufs))
                         (expand-file-name text))
              (setq live (car bufs)))
            (setq bufs (cdr bufs)))
          (if live
              (progn (set-buffer live)
                     (setq ret (buffer-string)))
            (find-file text)
            (setq ret (buffer-string))
            (kill-buffer (current-buffer)))))
       ;; these quoted things should presumably themselves be rendered
       ;; as links (and we probably don't need the crazy markup for
       ;; things about the whole buffer, ever)
       ((typedata-includes type 'reference)
        (if (equal (reference-to-article obj)
                   name-of-current-article)
            (setq ret
                  ;; it might be kind of cool to at least include a
                  ;; snippet of the context of this link, say 3 lines
                  ;; worth
                  (format "\"%s\" links here."
                          (reference-from-article obj)))
          (setq ret
                (format "This is a link from \"%s\" to \"%s\"."
                        (reference-from-article obj)
                        (reference-to-article obj)
                        obj))))
       ((stringp text)
        (setq ret text))
       (t
        (setq ret (format "%S" text)))))
    ret))
#+END_SRC

*** Turn list of ``links here'' items into listing                 :noexport:

It would be nice to be able to view all of the ``links here''
articles in a listing (as in Section [[id:catalog]]), and from
there in a compilation (Note [[id:making-a-compilation]]).


*** Rendering special list forms                                   :noexport:

With a small loss of transparency (note
[[id:principle-of-transparency]]), we can set up some specially-encoded
\inp{text} fields.  See, e.g., Section [[id:transclusion]].


*** Strategy for `cond's                                           :noexport:

Any time we see a `cond' in this code, we could wrap it in a backquote
and unquote a variable that says how to deal with things that come up
later in the code (see Note [[id:principle-of-order]]).


*** Actionable references                                          :noexport:
:PROPERTIES:
:LATEX_LABEL: actionable-references
:ID: actionable-references
:END:

When displaying a reference as the main article, it would be nice to
have the names of the articles (or other objects) themselves rendered
as references to the articles (or other objects) in question.  These
wouldn't officially be ``references'' from the point of view of the
system (unless they were temporary ones), but they would act like
references for the user.

Some examples of this sort of thing appear in Section [[id:linear-browsing]],
and are hooked in by `scholia-display-extras-hook' 
(Note [[id:scholia-display-extras-hook]]).


*** Render the names of articles?                                  :noexport:

Depending on the value of a variable like `sch-use-names' or something
of that sort, this could print the names of the scholia above their
text contents.  We might also want to print a list of articles that
this article is ``about'' (assuming there is more than one).


% Created 2025-11-12 Wed 18:16
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{fontspec}
\usepackage[margin=2cm]{geometry}
\setmainfont{NewCM10-Regular}[Path=/usr/local/texlive/2025/texmf-dist/fonts/opentype/public/newcomputermodern/,Extension=.otf]
\newcommand{\kw}[1]{{\tt #1}}
\usepackage{tocloft}
\setlength{\cftsecnumwidth}{3em}      % for \section in toc
\setlength{\cftsubsecnumwidth}{4em}   % for \subsection
\setlength{\cftsubsubsecnumwidth}{5em}% etc., if needed
\author{Joe Corneli}
\date{\today}
\title{Arxana spine}
\hypersetup{
 pdfauthor={Joe Corneli},
 pdftitle={Arxana spine},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 30.0.50 (Org mode 9.6.8)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\begin{ABSTRACT}
This spine collects the Arxana material into fourteen Parts, grouping related
modules so the whole is easier to navigate. The grouping is non-destructive:
filenames and internal structure are unchanged and can be further refined.
\end{ABSTRACT}

\begin{verbatim}
    ;; Quickstart
(require 'org)
(require 'ob-tangle)
(require 'cl-lib)

(add-to-list 'org-src-lang-modes '("elisp" . emacs-lisp))
(add-to-list 'org-babel-load-languages '(emacs-lisp . t))
(org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)

;; Treat 'elisp' blocks as Emacs Lisp when tangling.
(add-to-list 'org-babel-tangle-lang-exts '("elisp" . "el"))

;; Default: tangle elisp blocks unless :tangle no
(setq org-babel-default-header-args:elisp
      (org-babel-merge-params
       org-babel-default-header-args:elisp
       '((:tangle . "yes"))))

(defun arxana-spine-files (spine-file)
  "Return the list of files included by SPINE-FILE via #+INCLUDE."
  (with-temp-buffer
    (insert-file-contents spine-file)
    (let (files)
      (goto-char (point-min))
      (while (re-search-forward "^#\\+INCLUDE: \"\\([^\"]+\\)\"" nil t)
        (push (expand-file-name (match-string 1)
                                (file-name-directory spine-file))
              files))
      (nreverse files))))

(defun arxana-tangle-spine-concat (spine-file)
  "Tangle Org files listed in SPINE-FILE, concat their tangled .el into
arxana-tangled.el (in order), then load it.

Respects existing :tangle / :tangle no semantics.
Only deletes .el files that were created by this function."
  (interactive "fSpine file: ")
  (let* ((spine-file (expand-file-name spine-file))
         (base-dir  (file-name-directory spine-file))
         (org-files (arxana-spine-files spine-file))
         ;; Snapshot existing .el files so we know what is new later.
         (before-el (directory-files-recursively base-dir "\\.el$"))
         (tangled-files '()))

    ;; 1. Tangle each Org file, record resulting .el files.
    (dolist (org-file org-files)
      (dolist (f (org-babel-tangle-file org-file))
        (let* ((abs (if (file-name-absolute-p f)
                        f
                      (expand-file-name f (file-name-directory org-file)))))
          (push abs tangled-files))))

    ;; Preserve order of first occurrence.
    (setq tangled-files
          (cl-remove-duplicates (nreverse tangled-files)
                                :test #'string=))

    ;; 2. Build arxana-tangled.el from all tangled files.
    (let ((out (expand-file-name "arxana-tangled.el" base-dir)))
      (with-temp-file out
        (insert ";; Autogenerated from Arxana spine\n\n")
        (dolist (f tangled-files)
          (when (file-exists-p f)
            (insert ";; from " (file-relative-name f base-dir) "\n")
            ;; IMPORTANT: read from the file's own temp buffer,
            ;; not from the output buffer.
            (insert
             (with-temp-buffer
               (insert-file-contents f)
               (buffer-substring-no-properties (point-min) (point-max))))
            (insert "\n\n"))))

      ;; 3. Delete only .el files that are new (created by this run),
      ;; never the combined arxana-tangled.el itself.
      (let* ((after-el (directory-files-recursively base-dir "\\.el$"))
             (new-el (cl-set-difference after-el before-el :test #'string=)))
        (dolist (f new-el)
          (unless (string=
                   (file-truename f)
                   (file-truename out))
            (delete-file f))))

      ;; 4. Load the unified file.
      (load-file out))))

\end{verbatim}

\setcounter{tocdepth}{1}
\tableofcontents

\section{Part I — Reintroduction and Preface}
\label{sec:orgb84872f}
\subsection{Logical model}
\label{sec:orgdca6398}

Arxana manages a single logical hypergraph. The core primitives are:

\begin{description}
\item[{Nema}] Universal node record with stable id, labels, optional endpoints, and payload.
\item[{Article}] A nema labeled :label/article, holding text and core metadata.
\item[{Metadata scholium}] A nema paired 1–1 with an article, caching backlinks, labels, and indexes.
\item[{Event (hyperedge)}] A nema representing a relation or annotation, with :hx/type and N endpoints.
\item[{Plexus}] A nema that names a working set or profile and carries configuration.
\end{description}

Classic Arxana entities, relations, and scholia embed cleanly:

\begin{itemize}
\item Entities → article nemas with derived identifiers.
\item Relations → 2-end events (:hx/*) between nemas.
\item Scholia → events and/or metadata nemas attached to articles.
\item Inclusion / clusion / provenance → multi-end events with appropriate :role values.
\end{itemize}

\subsubsection{Storage substrates}
\label{sec:org1587524}

All storage backends implement the same logical model.

\begin{enumerate}
\item In-memory storage of one form or another
\label{sec:org0d3c5d3}
\begin{itemize}
\item Historically, nemas, articles, events, and plexuses were held in hash tables / HONEY-style networks.
\item This is the reference representation; other substrates hydrate/dehydrate it.
\end{itemize}

\item Document-based substrates
\label{sec:org9198a54}
\begin{itemize}
\item Literate sources (e.g., \LaTeX{}, Org, Markdown, TEI) could be parsed into nemas and events.
\item Arxana can — in principle and, increasingly, in practice — both read \textbf{and write} these formats, keeping ids and links stable across round-trips.
\end{itemize}

\item Historical: Relational substrate
\label{sec:org22785fd}
\begin{itemize}
\item Common Lisp provided a bridge to SQL that encode relations in tables.
\item Semantics are those of a structured triple store: subjects, predicates, objects, plus spans and provenance.
\item Suitable for durability, multi-user access, and heavy queries.
\end{itemize}

\item Possible future: Triple-store substrate
\label{sec:org182c9f9}
\begin{itemize}
\item Direct RDF/quad representation of the same model — not implemented but it could be if we want it.
\item Again, we could in principle read and write external knowledge graphs (and integrate SPARQL tooling).
\end{itemize}

\item Current reality: EAV in Clojure (Datascript + XTDB)
\label{sec:org496d234}

Instead of going the triple route, all storage backends in the current
‘beta’ generation converge on an open \textbf{\textbf{entity–attribute–value (EAV)}}
model.  Each record—whether an article, event, or plexus—is
represented as a set of attribute–value pairs attached to a unique
entity id.  This design keeps the schema \textbf{open}, so new attributes or
link types can appear dynamically without migration.

The canonical implementation uses:

\begin{itemize}
\item \textbf{\textbf{Datascript}} for in-memory, client-side operation.  
\begin{itemize}
\item Pure Clojure; lightweight and immutable.
\item Supports live queries, undo/redo, and fast incremental updates.
\item Ideal for interactive use inside Emacs or JVM clients.
\end{itemize}

\item \textbf{\textbf{XTDB}} for durable, time-traveling storage.  
\begin{itemize}
\item Schemaless documents mirror the same EAV keys verbatim.
\item Transactions are append-only; every version of the graph is queryable.
\item Perfect for provenance, journaling, and long-term archives.
\end{itemize}
\end{itemize}

Together these give Arxana an \textbf{open-schema substrate}: a graph database where nemas, events, and
plexuses are all entities, and attributes such as `:hx/type`, `:article/text`, or `:plexus/members`
are just first-class keys.  Queries can run over the generic EAV view, or use higher-level helpers
that expose structured projections (e.g., “articles”, “hyperedges”, “plexuses”).

> \textbf{\textbf{Design posture:}} Start open (EAV); specialize only when scale or semantics demand it.  
> Structured views—relational tables, triple stores, materialized indexes—can be layered on
> demand without altering the underlying data model.

This approach keeps computational properties stable: query complexity
and transaction semantics stay identical whether data are viewed as
triples, hash maps, or SQL rows.  It also makes cross-substrate
replication trivial: each backend stores the same `(entity attribute
value)` facts, differing only in query language and persistence model.
\end{enumerate}

\subsubsection{Emacs client (Arxana classic)}
\label{sec:org3e9b013}

The Emacs Lisp implementation in this repository provides:

\begin{itemize}
\item Interactive creation and editing of articles and scholia.
\item Browsing modes over the in-memory graph.
\item Operations for inclusion, derivation, and provenance as events.
\item Import/export for specific document formats (historically \LaTeX{}/Org).
\end{itemize}

Internally, it maintains the logical model in memory and (optionally)
syncs with external substrates (files, SQL backend).

\section{Part II — System Introduction}
\label{sec:org0b8f320}
\subsection{Elisp requirements}
\label{sec:org2c9fd3e}

\subsubsection{Packages}
\label{sec:org8de2d6d}

I'm not sure we actually need align any more, but cl is
of course very helpful.


\begin{verbatim}
(require 'align)
(require 'cl)
(load "cl-seq")
(load "cl-extra")
\end{verbatim}
\subsection{Lisp preliminaries}
\label{sec:orgd6c4989}

\subsubsection{On `add-or-replace'}
\label{sec:orgfab8f41}

It seems that this function is no longer used.


\begin{verbatim}
(defun add-or-replace (lis elt pred)
  (let ((found nil)
        (n 0)
        (len (length lis)))
    (while (and (not found)
                (< n len))
      (when (funcall pred (nth n lis))
        (setcar (nthcdr n lis) elt)
        (setq found t))
      (setq n (1+ n)))
    (if found
        (1- n)
      (nconc lis (list elt))
      n)))
\end{verbatim}

\subsubsection{On `add-to-or-start-list'}
\label{sec:org5f99fec}
This is is used to start store an \inp{element} on a
``\inp{possible-list}''; unlike `add-to-list', it works even when list
is nil, or even (for now) when \inp{possible-list} is not a list at
all.  (Unlike with `add-to-list', \inp{possible-list} should not be
the name of a list.)

This function is used by `put-type-labels', `put-backlinks' and
`label-article'.  Note that you have to \emph{save} the result if you
want to this function to have a lasting effect.

Like `add-to-list', this function will only store \emph{one} copy of
\inp{element}.


\begin{verbatim}
(defun add-to-or-start-list (possible-list element)
  (cond ((null possible-list)
         (list element))
        ((listp possible-list)
         (if (member element possible-list)
             possible-list
           (append possible-list (list element))))
        (t (list possible-list element))))
\end{verbatim}

\subsubsection{On `next-single-property-change+predicate'}
\label{sec:orgd672b8e}

Like `next-single-property-change' except instead of automatically
judging changes in the text property by the `eq' predicate, it allows
the user to supply a \inp{test}.


\begin{verbatim}
(defun next-single-property-change+predicate (pos prop &optional test)
  (let ((starting (get-text-property pos prop))
        (index pos)
        (cmpfct (or test
                    'eq)))
    (save-excursion
      (while (and (setq index (1+ index))
                  (< index (point-max))
                  (funcall cmpfct
                           starting
                           (get-text-property index prop)))))
    (when (< index (point-max))
      index)))
\end{verbatim}

\subsubsection{On `delete-all-dups'}
\label{sec:org2502999}

This function differs from `delete-dups' in being
non-destructive and in keeping none of several `equal'
occurrences of an element in \inp{list} as opposed to one;
otherwise, it manifests a similar idea.


\begin{verbatim}
(defun delete-all-dups (list)
  (let ((tail list)
        ret)
    (while tail
      (cond ((member (car tail) (cdr tail))
             (setq tail (delete (car tail) tail)))
            (t
             (setq ret (cons (car tail) ret)
                   tail (cdr tail)))))
    ret))

(defun set-difference (A B)
  (delete-all-dups (append A B)))

(defun zip (A B)
  (let ((ret (make-hash-table)))
    (while A
      (puthash (car A)
               (car B)
               ret)
      (setq A (cdr A)
            B (cdr B)))
    ret))

(defun flatten (list-structure)
  (apply 'concatenate 'list (list list-structure)))
\end{verbatim}

\section{Part III — Scholia-Based Documents}
\label{sec:orgb1dbbe0}
\subsection{The digital library}
\label{sec:org644943e}
\subsubsection{On `article-table'}
\label{sec:org1479dda}
We begin with an empty library.


\begin{verbatim}
(defvar article-table
  (make-hash-table :test 'equal))
\end{verbatim}

\subsubsection{On `put-article'}
\label{sec:org818281a}
This destructively adjusts the values on the hash table (see
documentation for `puthash').  To \emph{intelligently manage} the
values in the table takes more work, so we typically `get-article'
before to make various comparions and adjustments to existing values
before making changes.


\begin{verbatim}
(defun put-article (name value)
  (puthash name value article-table))
\end{verbatim}

\subsubsection{On `get-article'}
\label{sec:org1ed7755}

Basically just `gethash', but since the article table is indexed by
\inp{name} and we don't want to pass \inp{name} around all the time,
we add it to the recalled value.


\begin{verbatim}
(defun get-article (name)
  (let ((content (gethash name article-table)))
    (when content
      (cons name content))))
\end{verbatim}

\subsubsection{On `name-of-current-article'}
\label{sec:org8f44bfc}
The ``current article'' is of special importance for display (an
article is made ``current'' when `display-article' displays it).  The
name of this article is stored in this variable.


\begin{verbatim}
(defvar name-of-current-article nil)

(defun current-article ()
  (get-article name-of-current-article))
\end{verbatim}

\subsubsection{Futon1 synchronization primitives}
\label{sec:org1dee92e}
Arxana can treat Futon1 as the backing graph service.  The helpers
below provide lightweight HTTP glue that other commands can call when
they want to mirror in-memory operations to Futon1's API.


\begin{verbatim}
(require 'json)
(require 'url)

(defgroup futon4 nil
  "Arxana <-> Futon1 integration."
  :group 'tools)

(defcustom futon4-base-url "http://localhost:8080/api/alpha"
  "Base URL for Futon1 API (ASCII alias for /api/α)."
  :type 'string)

(defcustom futon4-enable-sync t
  "When non-nil, mirror article and relation edits to Futon1."
  :type 'boolean)

(defcustom futon4-log-requests nil
  "When non-nil, log each Futon1 POST and its JSON payload."
  :type 'boolean)

(defun futon4--post-json (path payload &optional cb)
  "POST PAYLOAD as JSON to Futon1 PATH and run CB on the decoded body."
  (when futon4-enable-sync
    (let* ((json-body (json-encode payload))
           (url-request-method "POST")
           (url-request-extra-headers '(("Content-Type" . "application/json")))
           (url-request-data (encode-coding-string json-body 'utf-8)))
      (when futon4-log-requests
        (message "futon4 POST %s %s" path json-body))
      (condition-case err
          (url-retrieve
           (concat futon4-base-url path)
           (lambda (_status)
            (goto-char (point-min))
            (when (re-search-forward "\n\n" nil t)
               (let* ((json-object-type 'alist)
                      (json-array-type 'list)
                      (json-key-type 'keyword)
                      (body (ignore-errors (json-read))))
                 (when cb (funcall cb body))))
             (let ((buf (current-buffer)))
               (when (buffer-live-p buf)
                 (kill-buffer buf)))))
        (error
         (message "futon4 request to %s failed: %S" path err))))))

(defun futon4--canonical-path (path)
  "Return a canonicalized representation of PATH, or nil."
  (when path
    (convert-standard-filename (expand-file-name path))))

(defun futon4--article-id (path)
  "Build a stable Futon1 article id from PATH or BUFFER name."
  (when path
    (concat "arxana:article:" (format "%s" path))))

(defvar futon4--article-id-cache (make-hash-table :test 'equal)
  "Cache mapping scholium names to Futon1 ids.")

(defun futon4-register-article (name id)
  "Remember that NAME corresponds to Futon1 article ID."
  (when (and name id)
    (puthash name id futon4--article-id-cache)
    id))

(defun futon4-lookup-article-id (name)
  "Return Futon1 article id cached for NAME, if any."
  (and name (gethash name futon4--article-id-cache)))

(defun futon4--article-id-for (name &optional path)
  "Return or derive the Futon1 id for NAME, optionally using PATH."
  (or (futon4-lookup-article-id name)
      (let ((derived (futon4--article-id (or path name))))
        (when derived
          (futon4-register-article name derived)))))

(defun futon4--link-label (link)
  "Return a readable label string for LINK's metadata."
  (let ((meta (cdr-safe link)))
    (if meta
        (mapconcat (lambda (piece)
                     (cond
                      ((stringp piece) piece)
                      ((symbolp piece) (symbol-name piece))
                      (t (format "%S" piece))))
                   meta
                   " | ")
      "")))

(defun futon4--sync-about-links (source-name about)
  "Mirror ABOUT links for SOURCE-NAME into Futon1."
  (when (and futon4-enable-sync about)
    (let ((src-id (futon4-lookup-article-id source-name)))
      (when src-id
        (dolist (link about)
          (let* ((target (car-safe link))
                 (dst-id (and target
                              (futon4--article-id-for target))))
            (when dst-id
              (futon4-store-nema-simple src-id dst-id
                                        (futon4--link-label link)))))))))

(defun futon4--article-context-for-buffer (buffer)
  "Return plist with :id, :name, and :path for BUFFER."
  (let* ((path (or (futon4--canonical-path (buffer-file-name buffer))
                   (buffer-name buffer)))
         (id (futon4--article-id path))
         (name (buffer-name buffer)))
    (list :id id :name name :path path)))

(defun futon4-ensure-article-entity (id name path &optional spine-p cb)
  "Ensure Futon1 has an article entity with ID, NAME, and PATH.
SPINE-P marks the article as belonging to the current spine when non-nil.
CB is an optional callback that receives the decoded response body."
  (when id
    (let* ((props-alist (delq nil (list (when path
                                          (cons 'path path))
                                        (when spine-p
                                          (cons 'spine t)))))
           (payload (delq nil (list (cons 'id id)
                                    (cons 'name (if (symbolp name)
                                                    (symbol-name name)
                                                  name))
                                    (cons 'type "arxana/article")
                                    (when props-alist
                                      (cons 'props props-alist))))))
      (futon4--post-json "/entity" payload cb))))

(defun futon4-store-nema-simple (src-id dst-id &optional label cb)
  "Store a simple scholium-style relation between SRC-ID and DST-ID."
  (when (and src-id dst-id)
    (futon4--post-json
     "/relation"
     `((type . "arxana/scholium")
       (src . ,src-id)
       (dst . ,dst-id)
       (props . ((label . ,(or label "")))))
     cb)))
\end{verbatim}
\subsection{Creating scholia}
\label{sec:orgb06d863}
\subsubsection{Links}
\label{sec:org49d5148}
Each link is associated with precisely one article.  Links can have
additional link-type information stored about them.  The general
format of a link is:
\begin{verbatim}
(<target article's name> &rest <link-types>)
\end{verbatim}
The design here maintains partial symmetry between the treatment of
article types and link types; the cdr of a link can be processed
by the same typedata processing functions as the \inp{type}
data from articles.

For example, the link
\begin{verbatim}
'(foo (passage 10 15) mistaken)
\end{verbatim}
indicates that the region from character position 10 to 15 in the
article named ``foo'' is ``mistaken'', whereas the link
\begin{verbatim}
'(foo mistaken)
\end{verbatim}
indicates simply that the article \emph{foo} is mistaken.


\subsubsection{Format of `bookkeeping' field}
\label{sec:org49801a4}

The \inp{bookkeeping} field has a special format, very similar
to the format of metadata articles

one might expect to see something like
\begin{verbatim}
((owner <owner>)
 (ACL <ACL>)
 ...)
\end{verbatim}
Remember that the \inp{bookkeeping} is \emph{owned}, so we probably
shouldn't put anything there that can't be edited by the user, and so
in particular, things that are needed for system consistency should go
into metadata articles instead.

Do notice that various schemes for access and ownership can be
considered.  (E.g. maybe anyone on the \emph{access control list}
(ACL) can edit the text of the article, but only the owner is allowed
to edit the ACL itself.)

It would be worth looking at existing strategies (e.g. as found on
PlanetMath) for handling complicated ownership and access
arrangements.  Actual implementation of useful bookkeeping features
will have to come later (for a sort of silly placeholder for the
meantime, see Note \ref{sec:org9d270d7}).


\subsubsection{Access functions}
\label{sec:orgaf0006e}
A few simple functions to get pieces of (just aliases to help with
coding; see Note \url{2.2-Design_issues.org}).  Note
\ref{sec:org8691c05} talks about something similar for links.


\begin{verbatim}
(defalias 'scholium-name 'first)
(defalias 'scholium-text 'second)
(defalias 'scholium-about 'third)
(defalias 'scholium-type 'fourth)
(defalias 'scholium-bookkeeping 'fifth)
\end{verbatim}

\subsubsection{Link accessors}
\label{sec:org8691c05}
Links have exactly one linked-to-article together with any number of
different link-types.


\begin{verbatim}
(defalias 'linked-to-article 'first)
(defalias 'link-type 'cdr)
\end{verbatim}

\subsubsection{Special link accessors}
\label{sec:orgf87d28b}

First we need a function that will give us the type-element associated
with a given type.  Then, we have some important examples.

The function `link-type-accessor' will produce the (first) specific
type-element from \inp{link} that matches the given \inp{type}, if one
exists.

Note that the format of \emph{version} access should follow the
`link-version' function given here.  (Passages don't have versions, so
it doesn't make sense to put a version number as an additional element
of a ``passage'' element.)


\begin{verbatim}
(defun link-type-accessor (link type)
  (car (member-if (lambda (type-elt)
                    (or (eq type-elt type)
                        (and (listp type-elt)
                             (eq (car type-elt) type))))
                  (cdr link))))

(defun link-beginning (link)
  (second (link-type-accessor link 'passage)))

(defun link-end (link)
  (third (link-type-accessor link 'passage)))

(defun link-version (link)
  (second (link-type-accessor link 'version)))
\end{verbatim}

\subsubsection{Hooks for new and modified scholia}
\label{sec:org2101498}
If the scholium is new, run `new-scholium-hook', otherwise, run
individual hooks depending on which pieces of the scholium were
modified (if any).  We use separate hooks in part because we need to
be careful about what sorts of changes we make.  If we adjusted the
value of some scholium every time the value of a scholium was
adjusted, we would expect to encounter infinite loops pretty quickly!

The standard settings for these hooks will be given in the section
\ref{sec:orgce4a8e5}; these settings facilitate e.g. the automatic
creation of backlinks (Note ).


\begin{verbatim}
(defvar new-scholium-hook nil)
(defvar scholium-modified-text-hook nil)
(defvar scholium-modified-about-hook nil)
(defvar scholium-modified-type-hook nil)
(defvar scholium-modified-book-hook nil)
\end{verbatim}

\subsubsection{The `scholium' function}
\label{sec:org3f447ab}
This function is foundational for the system.  Lots of other functions
will use it, but because it is destructive, users should typically not
access it directly.  Several interactive interfaces to this function
appear in Section .  Note that the conditional structure
here shouldn't be a `cond'; we really mean to run several hooks if
several parts of the scholium have been modified.


\begin{verbatim}
(defun scholium (name text &optional about type book)
  (let* ((old-version (get-article name))
         (old-about (and old-version (scholium-about old-version)))
         (maybe-path (and (stringp text)
                          (fboundp 'typedata-includes)
                          (typedata-includes type 'file)
                          (fboundp 'futon4--canonical-path)
                          (futon4--canonical-path text)))
         (article-id (and (fboundp 'futon4--article-id-for)
                          (futon4--article-id-for name maybe-path))))
    (put-article name (list text about type book))
    (when (and article-id
               (not (bufferp text))
               (or (not (fboundp 'typedata-includes))
                   (not (typedata-includes type 'file)))
               (fboundp 'futon4-ensure-article-entity))
      (futon4-ensure-article-entity article-id name maybe-path))
    (let ((meta-override (metadata-override)))
      (when (and (not meta-override)
                 (fboundp 'futon4--sync-about-links)
                 (not (equal old-about about)))
        (futon4--sync-about-links name about))
      (when (not meta-override)
        (if (not old-version)
            (run-hooks 'new-scholium-hook)
          (when (not (equal (scholium-text old-version) text))
            (run-hooks 'scholium-modified-text-hook))
          (when (not (equal (scholium-about old-version) about))
            (run-hooks 'scholium-modified-about-hook))
          (when (not (equal (scholium-type old-version) type))
            (run-hooks 'scholium-modified-type-hook))
          (when (not (equal (scholium-bookkeeping old-version) book))
            (run-hooks 'scholium-modified-book-hook)))))))
\end{verbatim}

\subsubsection{On `metadata-override'}
\label{sec:org18c52a3}
We don't want to run the usual hooks when the article being processed
is a metadata article or a ``fake'' article.  Fake articles appear
when we create fake references that they don't show up in the scholia
display and that aren't permanently attached to anything.  See Note
\ref{sec:orgcf271aa}.

(At least at one point I had some misgivings about this override, but
it seems to get the job done.  I don't see why we would want to have
weird automatic thing happen after creating a metadata article or a
``fake'' article, so it may be that the design here is perfectly
fine.)


\begin{verbatim}
(defun metadata-override ()
  (when (or (typedata-includes type 'meta)
            (typedata-includes type 'fake))
    t))
\end{verbatim}

\subsubsection{Simple scholium derivatives}

\subsubsection{On `article-names-from-about-data'}
\label{sec:org4371df2}

The idea here is to build a list with just the names of the articles
that the \inp{about} data features.  Names are uniquified.


\begin{verbatim}
(defun article-names-from-about-data (about)
  (delete-dups (mapcar (lambda (elt) (car elt)) about)))
\end{verbatim}

\subsubsection{On `typedata-includes'}
\label{sec:org8b09281}
Read \inp{typedata} in the format used in scholia,
and say whether it matches a \inp{specific-type}.
Notice that when \inp{typedata} and \inp{specific-type} are
both is `nil', we return a positive match.


\begin{verbatim}
(defun typedata-includes (typedata specific-type)
  (cond ((eq typedata specific-type) t)
        ((and (listp typedata)
              (member specific-type typedata)) t)
        (t nil)))
\end{verbatim}

\subsubsection{On `typedata-includes-element-of-list'}
\label{sec:org30bd718}


Like
`typedata-includes' (Note \ref{sec:org8b09281}), but only
requires one type out of those listed to match in order to return
`t'.


\begin{verbatim}
(defun typedata-includes-element-of-list (typedata list-of-types)
  (let (ret)
    (while (and list-of-types
                (not ret))
      (when (typedata-includes typedata (car list-of-types))
        (setq ret t))
      (setq list-of-types (cdr list-of-types)))
    ret))
\end{verbatim}

\subsubsection{On `typedata-includes-passage'}
\label{sec:org96e25dd}
A specific test to see if typedata includes type ``passage'' (noting
that the list element that indicates this type should come together
with some suffix that tells you which passage is being indicated).

As far as I can tell, this function will always apply to typedata
coming from links (but who knows).


\begin{verbatim}
(defun typedata-includes-passage (typedata)
  (let (ret)
    (when (listp typedata)
      (while (and typedata
                  (not ret))
        (when (eq (car (car typedata)) 'passage)
          (setq ret (car typedata)))))
    ret))
\end{verbatim}

\subsubsection{Examples} \label{examples}

\subsubsection{Examples of the `scholium' function in use}
\label{sec:org6372254}

As an example of how the `scholium' function might be applied, here is
a scholium about the article I'm writing now.
\begin{verbatim}
(scholium "Remark On Scholium Definition"
          "This is an Emacs Lisp function."
          '(((passage "sbdm4cbpp.tex" 49078 49738))))
\end{verbatim}
Actually, the article that I'm writing right now won't be in the
article list unless we explicitly put it there.  So the scholium
that we added here is actually attached to a \emph{fictitious}
article with the name ``sbdm4cbpp.tex''.  That's OK, but for
completeness, I'll add the current buffer as a scholium with the
appropriate name:
\begin{verbatim}
(scholium "sbdm4cbpp.tex"
          (current-buffer))
\end{verbatim}
Notice that we've supplied a buffer instead of a string for the
\inp{text} field.  We now add another scholium, attached to the
previous two, communicating to the user a fact that the system already
knows:
\begin{verbatim}
(scholium "This is a scholium about part of the SBDM document"
          "This scholium is attached to this region."
          '(((article "Remark On Scholium Definition"))
            ((passage "sbdm4cbpp.tex" 31091 31744))))
\end{verbatim}
By setting the \inp{type} data appropriately, we might make this last
example display when ``Remark On Scholium Definition'' is displayed,
but not when ``sbdm4cbpp.tex'' is displayed.  It might make sense to
mark up the words ``this region'' with a reference to
``sbdm4cbpp.tex''.  Tricky things like this will be coming in later
sections.
\subsection{Metadata}
\label{sec:org903c8a5}
\subsubsection{On `metadata-article-name-p'}
\label{sec:orgaf251c2}

So, like I said, we're losing some generality in the
set of available names by doing things the way we've been doing it.


\begin{verbatim}
(defun metadata-article-name-p (name)
  (when (and (listp name)
             (eq (car name) 'meta))
    t))

(defun base-name-from-metadata-name (name)
  (second name))
\end{verbatim}

\subsubsection{On `metadata-article'}
\label{sec:org196c8b3}

This function retrieves the metadata article associated with the
article named \inp{name}.


\begin{verbatim}
(defun metadata-article (name)
  (get-article (list 'meta name)))
\end{verbatim}

\subsubsection{On `put-metadata-field'}
\label{sec:org1b55af9}
This can be can be used to fill a metadata \inp{field} with the given
\inp{value}, in the metadata article pertaining to the article named
\inp{name}.  If the field has not yet been set, it is created anew
with the appropriate \inp{value}.


\begin{verbatim}
(defun put-metadata-field (field value name)
  (let* ((metadata (metadata-article name))
         (old-value (assoc field (scholium-text metadata)))
         new-text)
    (if old-value
        (setq new-text (progn (setcdr old-value value)
                              (scholium-text metadata)))
      (setq new-text `((,field . ,value))))
    (scholium (list 'meta name)
              new-text
              nil
              'meta
              'system)))
\end{verbatim}

\subsubsection{On `get-metadata-field'}
\label{sec:orga24e221}

This can be used to retrieve any particular metadata \inp{field}
pertaining to the article named \inp{name}.


\begin{verbatim}
(defun get-metadata-field (field name)
  (cdr (assoc field (scholium-text (metadata-article name)))))
\end{verbatim}

\subsubsection{On `delete-backlink'}
\label{sec:org54921b5}
This function is called by `put-backlinks' to prune away an old
backlink.

Also notice that in this function, we know that some
metadata and backlinks already exist, so in particular the
`metafield' exists.  Hence we don't need the complicated
conditions found in the `add-backlink' function.

(I don't suppose we actually need to delete the ``backlink'' field
in the case in which we delete the last backlink.)


\begin{verbatim}
(defun delete-backlink (linked-to-article link-number)
  (let* ((metaarticle (metadata-article linked-to-article))
         (metatext (scholium-text metaarticle))
         (metafield (assoc 'backlinks metatext))
         (backlinks (remove (list name link-number)
                            (cdr metafield))))
    (setcdr metafield backlinks)
    (scholium (list 'meta linked-to-article)
              metatext
              nil
              'meta
              'system)))
\end{verbatim}

\subsubsection{On `add-backlink'}
\label{sec:orgcf48043}
This function is called by `put-backlinks' to add a new backlink.

Note that the relevant metadata article may not exist prior to the
time this function runs and even if it exists, it may not contain any
backlink data.  So we have to run the relevant tests to deal with
these cases.  This accounts for differences between the implementation
of `add-backlink' and `delete-backlink' (Note \ref{sec:org54921b5}).


\begin{verbatim}
(defun add-backlink (linked-to-article link-number)
  (let* ((metaarticle (metadata-article linked-to-article))
         (metatext (scholium-text metaarticle))
         (metafield (assoc 'backlinks metatext))
         (backlinks (add-to-or-start-list
                     (cdr metafield)
                     (list name link-number))))
    (cond
     (metafield
      (setcdr metafield backlinks))
     (metatext
      (setcdr metatext
              `(((backlinks . ,backlinks)))))
     (t
      (setq metatext
            `((backlinks . ,backlinks)))))
    (scholium (list 'meta linked-to-article)
              metatext
              nil
              'meta
              'system)))
\end{verbatim}

\subsubsection{On `put-backlinks'}
\label{sec:org681fdb2}
The basic use for this function is to run it within the scope of the
`scholium' function, to build and store new (or updated) backlink
data.  Backlinks are added to each of the metadata articles
corresponding to articles that this article is \inp{about}.

The algorithm used here (zap \emph{all} existing backlinks, then place
\emph{all} new backlinks) seems likely to be woefully inefficient!  If
so, this can be improved later.

Notice that we don't take into account \inp{name} changes with this
function (there is no relevant ``old-name'' variable, at least, not at
present).


\begin{verbatim}
(defun put-backlinks ()
  (let ((old-about (scholium-about old-version))
        (link-number 0))
    (dolist (link old-about)
      (setq link-number (1+ link-number))
      (delete-backlink (car link) link-number)))
  (let ((link-number 0))
    (dolist (link about)
      (setq link-number (1+ link-number))
      (add-backlink (car link) link-number))))

(add-hook 'new-scholium-hook 'put-backlinks)
(add-hook 'scholium-modified-about-hook 'put-backlinks)
\end{verbatim}
\subsection{Subcollections}
\label{sec:orgce4a8e5}
\subsubsection{On `modified-type-labels'}
\label{sec:org19b98ba}
An alist of types to look for paired with the corresponding label to
apply.  Each new or modified article is tested to see if it matches
any of the given types; if so, then the corresponding label(s) will be
applied.  (Note that the ``label'' label is not treated specially.)


\begin{verbatim}
(defvar modified-type-labels '((nil . plain)
                               (label . label)
                               (meta . metadata)
                               (list . list)
                               (reference . reference)
                               (section . section)))
\end{verbatim}

\subsubsection{On `label-article'}
\label{sec:orgefd12b7}
This function is responsible for the mechanics of editing labels, and
creates them as needed.


\begin{verbatim}
(defun label-article (name article-label)
  (scholium article-label
            (add-to-or-start-list (scholium-text
                                   (get-article article-label))
                                  name)
            nil
            'label))
\end{verbatim}

\subsubsection{On `label-article-insert-before'}
\label{sec:orgbe233f6}
Like `label-article' (Note \ref{sec:orgefd12b7}), but takes an
additional argument \inp{before-this} to say which entry the new name
should be inserted just before.


\begin{verbatim}
(defun label-article-insert-before (name before-this article-label)
  (let* ((contents (scholium-text (get-article article-label)))
         (before-this-headed (member before-this contents)))
    (when before-this-headed
      (let ((len (- (length contents)
                    (length before-this-headed)
                    1)))
        (if (> len -1)
            (setcdr (nthcdr len contents)
                    (cons name before-this-headed))
          (setq contents (cons name before-this-headed))))
      (scholium article-label
                contents
                nil
                'label))))
\end{verbatim}

\subsubsection{On `put-type-labels'}
\label{sec:org1f4ea36}

This function runs within the scope of `scholium'.  It might make more
sense to be able to add lots of different labels for a new article;
the `cond' function doesn't work that way however.


\begin{verbatim}
(defun put-type-labels ()
  (unless (typedata-includes type 'label)
    (dolist (type-label modified-type-labels)
      (when (typedata-includes type (car type-label))
        (label-article name (cdr type-label))))))

(add-hook 'new-scholium-hook 'put-type-labels)
(add-hook 'scholium-modified-type-hook 'put-type-labels)
\end{verbatim}

\subsubsection{On `generalized-put-article'}
\label{sec:orge5014b2}
Like `put-article' (Note \ref{sec:org818281a}), but you specify
a \inp{path} as well as a \inp{name}.  The \inp{path}
should specify the path to the namespace wherein 
the \inp{name}, \inp{value} pair is to be stored.


\begin{verbatim}
(defun generalized-put-article (path name value)
  (puthash name value (generalized-get-article path)))
\end{verbatim}

\subsubsection{On `generalized-get-article'}
\label{sec:org1e60373}
Like `get-article' but takes a \inp{path}.  The path specifies a list
of nested namespaces, and possibly, a final non-namespace item to be
found in the last namespace.  Optional argument \inp{current} keeps
track of the ``current'' namespace as the path is digested.  If only
one item appears in the path and \inp{namespace} isn't given, the path
points to an item in the main article table, and we return the
corresponding item.

Be advised that there is a little bit of potentially destructive
ambiguity here.  But to make up for it, notice the doubly-clever use
of `and' and `cond' (to deal with the case that we're generalizing).


\begin{verbatim}
(defun generalized-get-article (path &optional current)
  (let ((first-step (get-article path)))
    (cond 
     ((and (not current) first-step)
      first-step)
     ((cdr path)
      (if (typedata-includes (get-article (car path)) 'namespace)
          (generalized-get-article (cdr path) (car path))
        (error "Path element not a namespace")))
     ((and (car path) current)
      (gethash current (car path)))
     ((car path) (get-article (car path))))))
\end{verbatim}
\subsection{Data access and conversion}
\label{sec:org38b9e78}

\subsubsection{Introduction to data access and conversion}
\label{sec:org30bd203}

The functions in this section give easy access to things we're often
interested in later on.  The functions here are simple, but it is
useful to have names for them anyway (Note
\url{2.2-Design_issues.org}).


\begin{verbatim}
(defun label-to-list (label)
  (mapcar (lambda (name)
            (format "%s" name))
          (scholium-text (get-article label))))

(defun label-to-propertized-list (label)
  (mapcar (lambda (name)
            (propertize (format "%s" name) 'name name))
          (scholium-text (get-article label))))
\end{verbatim}

\subsubsection{On `get-backlinks'}
\label{sec:org894214b}
This code produces the backlinks associated with \inp{name}.  See Note
for details.  Notice that throughout
the code I have been applying this idiom
\begin{verbatim}
(lambda (backlink)
  (get-article (car backlink)))
\end{verbatim}
to the element of the returned list in order to come up with the names
of the backlinked articles.  However, I recently converted the
backlink format to be richer than it was before so that we knew
\emph{which link} was doing the linking, not just which article.  So
presumably we should be using this additional data at least some of
the time.


\begin{verbatim}
(defun get-backlinks (name)
  (get-metadata-field 'backlinks name))

(defun get-links (name)
  (cdr (assoc 'links (scholium-text (metadata-article name)))))
\end{verbatim}

\subsubsection{On `read-article-name'}
\label{sec:org07e9590}

We frequently have to read the name of an article from a list.  We may
be able to do this in several different more intelligent ways than the
one we have here!  For one thing, we could use
`turn-article-table-into-names' (which see).  Another thing to do
would be to allow some other source of input, for example, some
particular namespace could be specified (this might be best handled
with another function, `read-article-name-from-namespace', say).  We
could offer some recursion if a namespace is selected.


\begin{verbatim}
(defun read-article-name ()
  (let* ((completion-ignore-case t)
         (strings (turn-article-table-into-list))
         (string-found (completing-read
                        "Article: "
                        strings))
         (place (- (length strings)
                   (length (member string-found strings)))))
    (nth place (turn-article-table-into-names))))
\end{verbatim}

\subsubsection{On `read-article-path'}
\label{sec:orga18b283}

Like `read-article-name' but reads a path to an article through
namespaces (cf. `generalized-get-article', Note 
\ref{sec:org1e60373}).


\begin{verbatim}
(defun read-article-path (&optional namespace path)
  (let* ((completion-ignore-case t)
         (strings (if namespace
                      (turn-namespace-into-list namespace)
                    (turn-article-table-into-list)))
         (string-found (completing-read
                        "Article: "
                        strings))
         (place (- (length strings)
                   (length (member string-found strings))))
         (ret (nth place (if namespace
                             (turn-namespace-into-names namespace)
                           (turn-article-table-into-names)))))
    (setq path (append path (list ret)))
    (if (and (typedata-includes ret 'namespace)
             (y-or-n-p "Read further? "))
        (read-article-path namespace path))
    path))
\end{verbatim}

\subsubsection{On `link-about-article-p'}
\label{sec:org600b203}
This provides a quick way to tell whether one of the elements of an
\inp{about} list is actually about the article named
\inp{article-name}.


\begin{verbatim}
(defun link-about-article-p (link article-name)
  (equal (linked-to-article link) article-name))
\end{verbatim}

\section{Part IV — HONEY Storage Backend}
\label{sec:org17ed8bd}
This backend is included here for reference, but its features should
be replaced by the new Clojure backend.

\subsection{Preliminaries}
\label{sec:org1ad6cca}

\subsubsection{Required packages}
\label{sec:orge818ae5}

We use the Common Lisp compatibility functions.


\begin{verbatim}
(require 'cl)
\end{verbatim}

\subsubsection{On `filter'}
\label{sec:org966dc5d}

This is a useful utility to filter elements of a list satisfying a condition.
Returns the subset of stuff which satisfies the predicate pred.


\begin{verbatim}
(defun filter (pred stuff)
  (let ((ans nil))
    (dolist (item stuff (reverse ans))
      (if (funcall pred item)
            (setq ans (cons item ans))
        nil))))
\end{verbatim}

\begin{verbatim}
(filter '(lambda (x) (= (% x 2) 1)) '(1 2 3 4 5 6 7))
=> (1 3 5 7)
\end{verbatim}

\subsubsection{On `intersection'}
\label{sec:org44bb125}

Set-theoretic intersection operation.  More general than the version
coming from the `cl' package.


\begin{verbatim}
(defun intersection (&rest arg)
  (cond ((null arg) nil)
        ((null (cdr arg)) (car arg))
        (t (let ((ans nil))
             (dolist (elmt (car arg) ans)
               (let ((remainder (cdr arg)))
                 (while (and remainder
                             (member elmt (car remainder)))
                   (setq remainder (cdr remainder))
                   (when (null remainder)
                     (setq ans (cons elmt ans))))))))))
\end{verbatim}

\begin{verbatim}
(intersection '(a b c d e f g h j)
              '(a b h j k)
              '(b d g h j k))
=> (j h b)
\end{verbatim}

\subsubsection{On `mapply'}
\label{sec:org80bf902}

Map and apply rolled into one.

\begin{verbatim}
(defun mapply (f l)
  (if (member nil l) nil
    (cons (apply f (mapcar 'car l))
          (mapply f (mapcar 'cdr l)))))
\end{verbatim}

\begin{verbatim}
(mapply '+ '((1 2) (3 4)))
 => (4 6)
\end{verbatim}

\subsubsection{On `sublis'}
\label{sec:orga66f60f}

Substitute objects in a list.


\begin{verbatim}
(defun sublis (sub lis)
  (cond
   ((null lis) nil)
   ((assoc lis sub) (cadr (assoc lis sub)))
   ((atom lis) lis)
   (t (cons (sublis sub (car lis))
            (sublis sub (cdr lis))))))
\end{verbatim}
\subsection{Core definitions}
\label{sec:org6ef37fd}

\subsubsection{HONEY set up}
\label{sec:orgbf90a97}

These variables are needed for a coherent set-up.\todo\{Explain
what they will do.\}


\begin{verbatim}
(defvar plexus-registry '(0 nil))
(defvar current-plexus nil)
\end{verbatim}

\subsubsection{The `add-plexus' function}
\label{sec:org2ee0293}
We use this create a new plexus for storage.  It defines a
counter (beginning at 1), together with several hash tables that allow
efficient access to the plexus' contents: an article table, forward
links, backward links, forward labels, and backward labels.
Additionally, it defines a ``ground'' and
``type'' nodes.\todo{Explain these things in more detail.}\todo\{NB. it could be useful
to maintain a registry available networks, by analogy with
Emacs's `buffer-list', which
I think could be done if we use `cl-defstruct' below
instead of `list', and set up the constructor suitably
(info \textquotedbl(cl) Structures\textquotedbl).\}


\begin{verbatim}
(defun add-plexus ()
  "Create a new plexus."
  (let ((newbie (list '*plexus*
                      1                               ; nema counter
                      (make-hash-table :test 'equal)  ; nema table
                      (make-hash-table :test 'equal)  ; forward links
                      (make-hash-table :test 'equal)  ; backward links
                      (make-hash-table :test 'equal)  ; forward labels
                      (make-hash-table :test 'equal)  ; backward labels
                      (car plexus-registry))))
    ;; Define ground and type nodes.
    (puthash 0 '(0 0) (nth 2 newbie))
    (puthash 1 '(0 0) (nth 2 newbie))
    (puthash 0 '((0 . 0) (1 . 0)) (nth 3 newbie))
    (puthash 0 '((0 . 0) (1 . 0)) (nth 4 newbie))
    (puthash 0 '"ground" (nth 5 newbie))
    (puthash '"ground" 0 (nth 6 newbie))
    (puthash 1 '"type" (nth 5 newbie))
    (puthash '"type" 1 (nth 6 newbie))
    ;; Register the new object and return it.
    (setq plexus-registry
          (append
           `(,(+ (car plexus-registry) 1)
             ,newbie)
           (cdr plexus-registry)))
    newbie))
\end{verbatim}

\subsubsection{The ``remove-plexus'' function}
\label{sec:org2a065ba}

When we're done with our plexus, we should tidy up after ourselves.


\begin{verbatim}
(defun remove-plexus (plex)
  "Remove a plexus."
  ;; Wipe out the hash tables
  (dotimes (i 5)
    (clrhash (nth (+ i 2) plex)))
  ;; Remove the entry from the registry.
  (setq plexus-registry
        (cons
         (car plexus-registry)
         (delete
          (assoc (nth 7 plex)
                 (cdr plexus-registry))
          (cdr plexus-registry)))))
\end{verbatim}

\begin{verbatim}
(defun show-plexus-registry ()
  plexus-registry)
\end{verbatim}

\subsubsection{Network selection}
\label{sec:orgc18c91e}

We can work with several networks, only one of
which is ``current'' at any given time.


\begin{verbatim}
(defun set-current-plexus (plex)
  "Examine a different plexus instead."
  (setq current-plexus plex))

(defmacro with-current-plexus (plex &rest expr)
  (declare (debug (&rest form)))
  (append `(let ((current-plexus ,plex))) expr))

(defun show-current-plexus ()
  "Return the plexus currently being examined."
  current-plexus)
\end{verbatim}

\subsubsection{On `next-unique-id'}
\label{sec:org9595a55}

Increment the identifier that tells us how many nemas are in our network.


\begin{verbatim}
(defun next-unique-id ()
  "Produce a yet unused unique identifier."
  (1+ (cadr current-plexus)))
\end{verbatim}

\subsubsection{On `reset-plexus'}
\label{sec:org4ee296e}

Reset article counter and hash tables.  Redefine ``ground'' and
``article-type''.


\begin{verbatim}
(defun reset-plexus ()
  "Reset the database to its initial configuration."
  ; Reset nema counter and hash tables.
  (setcar (cdr current-plexus) 1)
  (dotimes (n 5)
    (clrhash (nth (+ n 2) current-plexus)))
  ;; Define ground and nema-type.
  (puthash 0 '(0 0) (nth 2 current-plexus))
  (puthash 1 '(0 0) (nth 2 current-plexus))
  (puthash 0 '((0 . 0) (1 . 0)) (nth 3 current-plexus))
  (puthash 0 '((0 . 0) (1 . 0)) (nth 4 current-plexus))
  (puthash 0 '"ground" (nth 5 current-plexus))
  (puthash '"ground" 0 (nth 6 current-plexus))
  (puthash 1 '"type" (nth 5 current-plexus))
  (puthash '"type" 1 (nth 6 current-plexus))
  nil)
\end{verbatim}
\subsection{Individual Operations}
\label{sec:org00a593a}

\subsubsection{On `add-nema'}
\label{sec:org517ecd8}

Add record to article table.
Add record to list of forward links of source.
Add record to list of backward links of sink.
Return the id of the new article.\todo\{Should we add an alias `add-triple'
for this function, to make it more clear that our middle/frontend
is not implementation specific?\}


\begin{verbatim}
(defun add-nema (src txt snk)
  "Enter a new nema to the database."
  (let ((uid (next-unique-id)))
    ;; Add record to nema table.
    (puthash uid
             `(,src ,snk . ,txt)
             (nth 2 current-plexus))
    ;; Add record to list of forward links of source.
    (puthash src
             (cons `(,uid . ,snk)
                   (gethash src (nth 3 current-plexus) nil))
             (nth 3 current-plexus))
    ;; Add record to list of backward links of sink.
    (puthash snk
             (cons
              `(,uid . ,src)
              (gethash snk (nth 4 current-plexus) nil))
             (nth 4 current-plexus))
    ;; Update the counter for long-term storage
    (setcar (cdr current-plexus) uid)
    ;; Return the id of the new nema.
    uid))
\end{verbatim}

\subsubsection{Retrieving elements of a nema}
\label{sec:orgce66c79}
These functions exist to get the relevant components
of a nema, given its uid.


\begin{verbatim}
(defun get-content (uid)
  "Return the content of the nema."
  (cddr (gethash uid (nth 2 current-plexus))))

(defun get-source (uid)
  "Return the source of the nema."
  (car (gethash uid (nth 2 current-plexus))))

(defun get-sink (uid)
  "Return the sink of the nema."
  (cadr (gethash uid (nth 2 current-plexus))))

(defun get-triple (uid)
  (list (get-source uid)
        (get-content uid)
        (get-sink uid)))
\end{verbatim}

\subsubsection{On `update-content'}
\label{sec:org90c8aaa}

old source
old sink
new content


\begin{verbatim}
(defun update-content (uid txt)
  "Replace the content of the nema."
  (puthash uid
              (let ((x (gethash uid (nth 2 current-plexus))))
                     `(,(car x)    ; old source
                              ,(cadr x) . ; old sink
                                     ,txt))      ; new content
                 (nth 2 current-plexus)))
\end{verbatim}

\subsubsection{On `update-source'}
\label{sec:org4e6842f}

Extract current source.
Extract current sink.
Extract current content.
Update the entry in the article table.
Remove the entry with the old source in the
forward link table.  If that is the only entry
filed under old-src, remove it from table.
Add an entry with the new source in the
forward link table.
Update the entry in the backward link table.


\begin{verbatim}
(defun update-source (uid new-src)
  "Replace the source of the nema."
  (let* ((x (gethash uid (nth 2 current-plexus)))
         (old-src (car x))   ; extract current source
         (old-snk (cadr x))  ; extract current sink
         (old-txt (cddr x))) ; extract current content
    ;; Update the entry in the nema table.
    (puthash uid
             `(,new-src ,old-snk . ,old-txt)
             (nth 2 current-plexus))
    ;; Remove the entry with the old source in the
    ;; forward link table.  If that is the only entry
    ;; filed under old-src, remove it from table.
    (let ((y (delete `(,uid . ,old-snk)
                     (gethash old-src
                              (nth 3 current-plexus)
                              nil))))
      (if y
          (puthash old-src y (nth 3 current-plexus))
        (remhash old-src (nth 3 current-plexus))))
    ;; Add an entry with the new source in the
    ;; forward link table.
    (puthash new-src
             (cons `(,uid . ,old-snk)
                   (gethash old-src (nth 3 current-plexus) nil))
             (nth 3 current-plexus))
    ;; Update the entry in the backward link table.
    (puthash old-snk
             (cons `(,uid . ,new-src)
                   (delete `(,uid . ,old-src)
                           (gethash old-src
                                    (nth 4 current-plexus)
                                    nil)))
             (nth 4 current-plexus))))
\end{verbatim}

\subsubsection{On `update-sink'}
\label{sec:orgba6628b}
Extract current source.
Extract current sink.
Extract current content.
Update the entry in the article table.
Remove the entry with the old sink in the
backward link table.  If that is the only entry
filed under old-src, remove it from table.
Add an entry with the new source in the
backward link table.
Update the entry in the forward link table.


\begin{verbatim}
(defun update-sink (uid new-snk)
  "Change the sink of the nema."
  (let* ((x (gethash uid (nth 2 current-plexus)))
          (old-src (car x))   ; extract current source
           (old-snk (cadr x))  ; extract current sink
            (old-txt (cddr x))) ; extract current content
    ; Update the entry in the nema table.
    (puthash uid
             `(,old-src ,new-snk . ,old-txt)
             (nth 2 current-plexus))
    ;; Remove the entry with the old sink in the
    ;; backward link table.  If that is the only entry
    ;; filed under old-src, remove it from table.
    (let ((y (delete `(,uid . ,old-src)
                     (gethash old-snk
                              (nth 4 current-plexus)
                              nil))))
      (if y
          (puthash old-snk y (nth 4 current-plexus))
        (remhash old-snk (nth 4 current-plexus))))
    ;; Add an entry with the new source in the
    ;; backward link table.
    (puthash new-snk
             (cons `(,uid . ,old-src)
                   (gethash old-snk
                            (nth 4 current-plexus)
                            nil))
             (nth 4 current-plexus))
    ;; Update the entry in the forward link table.
    (puthash old-src
             (cons `(,uid . ,new-snk)
                   (delete `(,uid . ,old-snk)
                           (gethash old-src
                                    (nth 3 current-plexus)
                                    nil)))
             (nth 3 current-plexus))))
\end{verbatim}

\subsubsection{On `remove-nema'}
\label{sec:org95d6edf}

Remove forward link created by article.
Remove backward link created by article.
Remove record from article table.


\begin{verbatim}
(defun remove-nema (uid)
  "Remove this nema from the database."
  (let ((old-src (car (gethash uid (nth 2 current-plexus))))
        (old-snk (cadr (gethash uid (nth 2 current-plexus)))))
  ;; Remove forward link created by nema.
  (let ((new-fwd (delete `(,uid . ,old-snk)
                          (gethash old-src (nth 3 current-plexus)))))
    (if new-fwd
        (puthash old-src new-fwd (nth 3 current-plexus))
      (remhash old-src (nth 3 current-plexus))))
  ;; Remove backward link created by nema.
  (let ((new-bkw (delete `(,uid . ,old-src)
                          (gethash old-snk (nth 4 current-plexus)))))
    (if new-bkw
        (puthash old-snk new-bkw (nth 4 current-plexus))
      (remhash old-snk (nth 4 current-plexus))))
  ;; Remove record from nema table.
  (remhash uid (nth 2 current-plexus))))
\end{verbatim}

\subsubsection{Functions for gathering links}
\label{sec:orgb149471}

Links are stored on triples alongside other
elements.


\begin{verbatim}
(defun get-forward-links (uid)
  "Return all links having given object as source."
  (mapcar 'car (gethash uid (nth 3 current-plexus))))

(defun get-backward-links (uid)
  "Return all links having given object as sink."
  (mapcar 'car (gethash uid (nth 4 current-plexus))))
\end{verbatim}

\subsubsection{On `label-nema'}
\label{sec:org792bc64}

Nemas can be given a unique human-readable label in addition
to their numeric uid.


\begin{verbatim}
(defun label-nema (uid label)
  "Assign the label to the given object."
  (puthash uid label (nth 5 current-plexus))
  (puthash label uid (nth 6 current-plexus)))
\end{verbatim}

\subsubsection{Label to uid and uid to label lookup}
\label{sec:orgd3f6878}

These functions allow the exchange of uid and label.


\begin{verbatim}
(defun label2uid (label)
  "Return the unique identifier corresponding to a label."
  (gethash label (nth 6 current-plexus) nil))

(defun uid2label (uid)
  "Return the label associated to a unique identifier."
  (gethash uid (nth 5 current-plexus) nil))
\end{verbatim}
\subsection{Bulk Operations}
\label{sec:org4688c61}

\subsubsection{On `download-en-masse'}
\label{sec:orgdcaa637}

Unpack triplets, obtain labels if they exist.
Write data in the network to a list, and return.


\begin{verbatim}
(defun download-en-masse ()
  "Produce a representation of the database as quintuples."
  (let ((plex nil))
    (maphash (lambda (uid tplt)
               ;; Unpack triplet.
               (let ((src (car tplt))
                     (snk (nth 1 tplt))
                     (txt (nthcdr 2 tplt)))
                 ;; Obtain label if exists.
                 (setq lbl (gethash uid
                                    (nth 5 current-plexus)
                                    nil))
                 ;; Write data to list.
                 (setq plex (cons `(,uid ,lbl ,src ,snk . ,txt)
                                 plex))))
             (nth 2 current-plexus))
    ;; Return list of data.
    (reverse plex)))
\end{verbatim}

\subsubsection{On `upload-en-masse'}
\label{sec:orgb5733ab}

Unpack quintuplets.  Plug into tables.
Bump up article counter as needed.


\begin{verbatim}
(defun upload-en-masse (plex)
  "Load a representation of a database as quintuples into memory."
  (dolist (qplt plex t)
    ; unpack quintuplet
    (let ((uid (car qplt))
            (lbl (nth 1 qplt))
              (src (nth 2 qplt))
                (snk (nth 3 qplt))
                  (txt (nthcdr 4 qplt)))
      ; plug into tables
      (puthash uid
                      `(,src ,snk . ,txt)
                             (nth 2 current-plexus))
      (puthash src
                      (cons `(,uid . ,snk)
                                 (gethash src (nth 3 current-plexus) nil))
                             (nth 3 current-plexus))
      (puthash snk
                      (cons
                       `(,uid . ,src)
                       (gethash snk (nth 4 current-plexus) nil))
                             (nth 4 current-plexus))
      (when lbl
          (progn
                (puthash uid lbl (nth 5 current-plexus))
                    (puthash lbl uid (nth 6 current-plexus))))
      ; Bump up nema counter if needed.
      (when (> uid (cadr current-plexus))
             (setcar (cdr current-plexus) uid)))))
\end{verbatim}

\subsubsection{On `add-en-masse'}
\label{sec:orgc462ee7}

Given several articles, add all of them at once.


\begin{verbatim}
(defun add-en-masse (plex)
  "Add multiple nemata given as list of quartuplets."
  (mapcar (lambda (qplt)
            (let ((uid (next-unique-id)))
              (add-nema (nth 1 plex)
                        (nthcar 2 plex)
                        (nth 2 plex))
              (label-nema uid (car qplt))))
          plex))
\end{verbatim}
\subsection{Query}
\label{sec:orga26a579}

\subsubsection{Various lookup functions}
\label{sec:org5869980}

These functions allow testing and lookup of various elements
of a net.


\begin{verbatim}
(defun uid-p (uid)
  "Is this a valid uid?"
  (let ((z '(())))
    (not (eq z (gethash uid (nth 2 current-plexus) z)))))

(defun uid-list ()
  "List of all valid uid's."
  (maphash (lambda (key val) key)
           (nth 2 current-plexus)))

(defun ground-p (uid)
  "Is this nema the ground?"
  (= uid 0))

(defun source-p (x y)
  "Is the former nema the sink of the latter?"
  (equal x (get-source y)))

(defun sink-p (x y)
  "Is the former nema the sink of the latter?"
  (equal x (get-sink y)))

(defun links-from (x y)
  "Return all links from nema x to nema y."
  (filter '(lambda (z) (source-p x z))
            (get-backward-links y)))

(defun links-p (x y)
  "Does nema x link to nema y?"
  (when (member x (mapcar
                      'get-source
                      (get-backward-links y)))
    t))

(defun triple-p (x y z)
  "Do the three items form a triplet?"
  (and (source-p y x)
       (sink-p y z)))

(defun plexus-p (x)
  "Is this object a plexus?"
  (let ((ans t))
    (setq ans (and ans
                      (equal (car x) "*plexus*")))
    (setq ans (and ans
                      (integrp (cadr x))))
    (dotimes (n 5)
          (setq ans (and ans (hash-table-p
                                    (nth (+ n 2) x)))))
    ans))
\end{verbatim}
\subsection{Iteration}
\label{sec:orgcf7caad}

\subsubsection{Iterating over a plexus}
\label{sec:org701d8c1}

 These functions allow users to run loops over a plexus without
 having to delve into its internal structure.\todo\{I forget whether the
use of `apply' here is good form.\}


\begin{verbatim}
(defmacro do-plexus (var res body)
  `((maphash (lambda (,var val) ,body)
             (nth 2 current-plexus))
    ,res))

;; This maps over the keys; func should be
;; defined appropriately.
(defun map-plexus (func)
  (let ((ans nil))
    (maphash
     (lambda (key val)
       (push (apply func (list key)) ans))
     (nth 2 current-plexus))
    ans))

(defun filter-plexus (pred)
  (let ((ans nil))
    (maphash
     (lambda (key val)
       (when (apply pred (list key))
         (push key ans)))
       (nth 2 current-plexus))
     ans))
\end{verbatim}

\subsubsection{Filtering convenience functions}
\label{sec:org488c7f3}

Several convenience functions for filtering the plexus can be
defined.  They give lists of uids, which can be expanded
using get-triple.


\begin{verbatim}
(defun nemas-given-beginning (node)
  "Get triples outbound from the given NODE."
  (filter-plexus
   (lambda (x) (when (equal (get-source x)
                            node)
                 (list node
                       (get-content x)
                       (get-sink x))))))

(defun nemas-given-end (node)
  "Get triples inbound into NODE."
  (filter-plexus
   (lambda (x) (when (equal (get-sink x)
                            node)
                 (list (get-source x)
                       (get-content x)
                       node)))))

(defun nemas-given-middle (edge)
  "Get the triples that run along EDGE."
  (filter-plexus
   (lambda (x) (when (equal (get-content x)
                            edge)
                 (list (get-source x)
                       edge
                       (get-sink x))))))

(defun nemas-given-middle-and-end (edge node)
  "Get the triples that run along EDGE into NODE."
  (filter-plexus
   (lambda (x) (when (and
                      (equal (get-content x)
                             edge)
                      (equal (get-sink x)
                             node))
                 (list (get-source x)
                       edge
                       node)))))

(defun nemas-given-beginning-and-middle (node edge)
  "Get the triples that run from NODE along EDGE."
  (filter-plexus
   (lambda (x) (when (and
                      (equal (get-source x)
                             node)
                      (equal (get-content x)
                             edge))
                 (list node
                       edge
                       (get-sink x))))))

(defun nemas-given-beginning-and-end (node1 node2)
  "Get the triples that run from NODE1 to NODE2."
  (filter-plexus
   (lambda (x) (when (and
                      (equal (get-source x)
                             node1)
                      (equal (get-sink x)
                             node2))
                 (list node1
                       (get-content x)
                       node2)))))

(defun nemas-exact-match (node1 edge node2)
  "Get the triples that run from NODE1 along EDGE to
NODE2."
  (filter-plexus
   (lambda (x) (when (and
                      (equal (get-source x)
                             node1)
                      (equal (get-content x)
                             edge)
                      (equal (get-sink x)
                             node2))
                 (list node1
                       edge
                       node2)))))
\end{verbatim}

\subsubsection{Additional elementary functions for node access}
\label{sec:orgba4e27b}

These functions give access to the various parts of a node.\todo\{Note:
 since `article-list' is not defined, should these functions be deleted?
Or should they be rewritten to access `current-plexus'?\}


\begin{verbatim}
(defun get-src (n)
  (car (nth 0 (cdr (assoc n (cdr article-list))))))

(defun get-flk (n)
  (cdr (nth 0 (cdr (assoc n (cdr article-list))))))

(defun get-txt (n)
  (nth 1 (cdr (assoc n (cdr article-list)))))

(defun get-snk (n)
  (car (nth 2 (cdr (assoc n (cdr article-list))))))

(defun get-blk (n)
  (cdr (nth 2 (cdr (assoc n (cdr article-list))))))

(defun get-ids nil
  (mapcar (quote car) (cdr article-list)))

(defun get-gnd nil 0)
\end{verbatim}

\subsubsection{On `search-cond'}
\label{sec:org209fe86}
Surround the search within dolist loops on free variables.
Wrap no further when finished.\todo\{Upgrade this to concatenate the results together.
Also maybe allow options to add headers or to
only loop over unique tuplets.\}\todo\{Explain; how does this differ from
the function defined at Note \ref{sec:orgabf0321}?\}


\begin{verbatim}
(defmacro search-cond (vars prop)
  "Find all n-tuplets satisfying a condition"
  (let ((foo '(lambda (vars cmnd)
                (if vars
                    Wrap in a loop.
                    `(dolist (,(car vars) uids)
                       ,(funcall foo (cdr vars) cmnd))
                    cmnd))))
    (funcall foo vars prop)))
\end{verbatim}

\subsubsection{Overview of the search pipeline}
\label{sec:org237de45}

We will implement the search as a pipeline which gradually
transforms the query into a series of expressions which produce
the sought-after result, then evaluate those expressions.

A search query designates predicates apply to the nodes
and the network relationships that apply to them.  The network relationships
function as wildcards.

The basic model of the data is triplets that point to other triplets.
The following query asks for a \emph{funny} link from a
\emph{big blue object} to a \emph{small green link} pointing outwards
from the big blue object.
\begin{verbatim}
(((a blue big) (b funny) (c green small)
  ((b src a) (b snk c) (c src a))
\end{verbatim}
The first step of processing is to put the quaerenda in some
order so that each item links up with at least one previous item:
\begin{verbatim}
(scheduler
 '((b funny)
   (c green small))
 '((b src a)
   (b snk c)
   (c src a))
 '((a blue big)))
=>
((c (green small) ((b snk c) (c src a)))
 (b (funny) ((b src a)))
 (a blue big))
\end{verbatim}
Note that the order is reversed due to technicalities of
implementing `scheduler' --- that is to say, a is first and does
not link to any other variable, b is next and links to only a,
whilst c is last and links to both a and b.
At the same time, we have also rearranged things so that the
links to previous items to which a given object are listed
alongside that object. The next step is to replace the links with the commands which
generate a list of such objects:
\begin{verbatim}
((c (green small) ((b snk c) (c src a)))
 (b (funny) ((b src a)))
 (a blue big))
=>
((c (green small)
    (intersection (list (get-snk b)) (get-forward-links a)))
 (b (funny)
    (intersection (get-backward-links a)))
 (a blue big))
\end{verbatim}
This is done using the function `tplts2cmd', e.g.
\begin{verbatim}
(tplts2cmd 'c  '((b snk c) (c src a)))
=>
(intersection (list (get-snk b)) (get-forward-links a))
\end{verbatim}
Subsequently, we filter over the predicates:
\begin{verbatim}
((c (filter '(lambda (c) (and (green c) (small c)))
    (intersection (list (get-snk b))
  (get-forward-links))))
 (b (filter '(lambda (b) (and (funny b)))
    (intersection (get-backward-links a)))))
\end{verbatim}
This is done with the command `add-filt':
\begin{verbatim}
(add-filt 'c
  '(green small)
  '((b snk c) (c src a)))
=>
(c (filter (quote (lambda (c) (and (green c) (small c))))
   (intersection (list (get-snk b))
 (get-forward-links a))))
\end{verbatim}
This routine calls up the previously described routine `tplts2cmd'
to take care of the third argument. The last entry, \kw{(a blue big)}
gets processed a little differently because we don't as yet have
anything to filter over; instead, we generate the initial list by
looping over the current network:
\begin{verbatim}
(a (let ((ans nil))
     (donet 'node
    (when (and (blue (get-content node))
       (big (get-content node)))
      (setq ans (cons node ans))))
     ans))
\end{verbatim}
This is done by invoking `first2cmd':
\begin{verbatim}
(first2cmd '(blue big))
=>
(let ((ans nil))
  (donet (quote node)
 (when (and (blue (get-content node))
    (big (get-content node)))
 (setq ans (cons node ans))))
 ans)
\end{verbatim}
And putting this all together:
\begin{verbatim}
(query2cmd
 '((c (green small) ((b snk c) (c src a)))
   (b (funny) ((b src a)))
   (a blue big)))
=>
((c (filter (quote (lambda (c) (and (green c) (small c))))
    (intersection (list (get-snk b))
  (get-forward-links a))))
 (b (filter (quote (lambda (b) (and (funny b))))
    (intersection (get-forward-links a))))
 (a (let ((ans nil))
      (donet (quote node)
     (when (and (blue (get-content node))
(big (get-content node)))
       (setq ans (cons node ans))))
      ans)))
\end{verbatim}
To carry out these instructions in the correct order and generate
a set of variable assignments, we employ the `matcher' function.
Combining this last layer, we have the complete pipeline:
\begin{verbatim}
(matcher nil
 (query2cmd
  (scheduler
   '((b funny)
     (c green small))
   '((b src a)
     (b snk c)
     (c src a))
   '((a blue big)))))
\end{verbatim}
This combination of operations is combined into the `search'
function, which can be called as follows:
\begin{verbatim}
(search
 '(((a blue big)
    (b funny)
    (c green small))
   ((b src a)
    (b snk c)
    (c src a))))
\end{verbatim}

Having described what the functions are supposed to do and how
they work together, we now proceed to implement them.


\subsubsection{On `scheduler'}
\label{sec:orgd6dc3cf}

The scheduler function takes a list search query and rearranges it
into an order suitable for computing the answer to that query.
Specifically, a search query is a pair of lists --- the first list
consists of lists whose heads are names of variables and whose
tails are predicates which the values of the variables should
satisfy and the second list consists of triples indicating the
relations between the values of the variables.
Its arguments are:
\begin{itemize}
\item new-nodes, a list of items of the form \verbal|(node &rest property)|;
\item \verbal|links|, a list of triplets;
\item \verbal|sched| is a list whose items consist of triplets of the
form\newline \verbal|(node (&rest property) (&rest link))|.
\end{itemize}

A recursive function to find linked nodes.
If done, return answer.
New nodes yet to be examined.
Element of remaining-nodes currently under consideration.
List of links between candidate and old-nodes.
List of nodes already scheduled.
Loop through new nodes until find one linked to an old node.
Look at the next possible node.
Find the old nodes linking to the candidate node and record the answer in ``ties''.
Pick out the triplets whose first element is the node under consideration and whose third element is already on the list or vice-versa.
Recursively add the rest of the nodes.


\begin{verbatim}
(defun scheduler (new-nodes links sched)
  (if (null new-nodes)
      sched
    (let ((remaining-nodes new-nodes)
          (candidate nil)
          (ties nil)
          (old-nodes (mapcar 'car sched)))
      (while (null ties)
        (setq candidate (car remaining-nodes))
        (setq remaining-nodes (cdr remaining-nodes))
        (setq ties
              (filter '(lambda (x)
                         (or
                          (and (eq (first x) (car candidate))
                               (member (third x) old-nodes))
                          (and (member (first x) old-nodes)
                               (eq (third x) (car candidate)))))
                      links)))
      (scheduler (remove candidate new-nodes)
                 links
                 (cons (list (car candidate)
                             (cdr candidate)
                             ties)
                       sched)))))
\end{verbatim}

\subsubsection{On `tplts2cmd'}
\label{sec:org8cd42eb}

\ldots\todo{Explain.}


\begin{verbatim}
(defun tplts2cmd (var tplts)
  (cons 'intersection
        (mapcar
         #'(lambda (tplt)
             (cond ((and (eq (third tplt) var)
                         (eq (second tplt) 'src))
                    `(get-flk ,(first tplt)))
                   ((and (eq (third tplt) var)
                         (eq (second tplt) 'snk))
                    `(get-blk ,(first tplt)))
                   ((and (eq (first tplt) var)
                         (eq (second tplt) 'src))
                    `(list (get-src ,(third tplt))))
                   ((and (eq (first tplt) var)
                         (eq (second tplt) 'snk))
                    `(list (get-snk ,(third tplt))))
                   (t nil)))
         tplts)))
\end{verbatim}

\subsubsection{On `add-filt'}
\label{sec:org6ec101a}

\ldots\todo{Explain.}


\begin{verbatim}
(defun add-filt (var preds tplts)
  `(,var
    (filter
     #'(lambda (,var)
         ,(cons 'and
                (mapcar
                 #'(lambda (pred)
                     (list pred
                           (list 'get-txt var)))
                 preds)))
     ,(tplts2cmd var tplts))))
\end{verbatim}

\subsubsection{On `first2cmd'}
\label{sec:orgae4f038}

\ldots\todo{Explain.}


\begin{verbatim}
(defun first2cmd (preds)
  `(let ((ans nil))
     (dolist (node (get-ids) ans)
       (when
           ,(cons 'and
                  (mapcar
                   #'(lambda (pred)
                       (cons pred '((get-txt node))))
                   preds))
         (setq ans (cons node ans))))))
\end{verbatim}

\subsubsection{On `query2cmd'}
\label{sec:org9637a32}

\ldots\todo{Explain.}


\begin{verbatim}
(defun query2cmd (query)
  (let ((backwards (reverse query)))
    (reverse
     (cons
      (list (caar backwards)
            (first2cmd (cdar backwards)))
      (mapcar
       #'(lambda (x)
           (add-filt (first x) (second x) (third x)))
       (cdr backwards))))))
\end{verbatim}

\subsubsection{On `matcher'}
\label{sec:org6883c93}

\ldots\todo{Explain.}


\begin{verbatim}
(defun matcher (assgmt reqmts)
  (if (null reqmts) (list assgmt)
    (apply 'append
           (mapcar
            #'(lambda (x)
                (matcher (cons (list (caar reqmts) x)
                               assgmt)
                         (cdr reqmts)))
            (apply 'intersection
                   (eval `(let ,assgmt
                            (mapcar 'eval
                                    (cdar reqmts)))))))))
\end{verbatim}

\subsubsection{How matcher works}
\label{sec:org312e08c}

Here are some examples unrelated to what comes up in searching
triplets which illustrate how matcher works:


\begin{verbatim}
(matcher '((x 1)) '((y (list 1 3))
                    (z (list (+ x y) (- y x)))))
=>
(((z 2) (y 1) (x 1))
 ((z 0) (y 1) (x 1))
 ((z 4) (y 3) (x 1))
 ((z 2) (y 3) (x 1)))

(matcher nil '((x (list 1))
               (y (list 1 3))
               (z (list (+ x y) (- y x)))))
=>
(((z 2) (y 1) (x 1))
 ((z 0) (y 1) (x 1))
 ((z 4) (y 3) (x 1))
 ((z 2) (y 3) (x 1)))
\end{verbatim}

\subsubsection{On `search'}
\label{sec:orgabf0321}
\ldots\todo\{Explain; how does this differ from
the macro defined at Note \ref{sec:org209fe86}?\}


\begin{verbatim}
(defun search (query)
  (matcher nil
           (reverse
            (query2cmd
             (scheduler
              (cdar query)
              (cadr query)
              (list (caar query)))))))
\end{verbatim}
\subsection{Scholium programming}
\label{sec:org1f982fb}

\subsubsection{On `node-fun'}
\label{sec:orgd11e800}

\ldots\todo{Explain.}
Produce a list of commands to produce temporary bindings.
Produce a list of commands to reset function values.


\begin{verbatim}
(defun node-fun (node get-code get-links)
  (let ((code  (funcall get-code node))
        (links (funcall get-links node)))
    (list
     'lambda
     (car code)
     (cons
      'prog1
      (cons
       (append
        '(progn)
        (mapcar #'(lambda (x)
                    `(fset ',(car x)
                           (node-fun ,(cdr x)
                                     ',get-code
                                     ',get-links)))
                links)
        (cdr code))
       (mapcar #'(lambda (x)
                   (if (fboundp (car x))
                       `(fset ',(car x)
                              ',(symbol-function (car x)))
                     `(fmakunbound ',(car x))))
               links))))))
\end{verbatim}

\subsubsection{On `tangle-module'}
\label{sec:org7689c2e}

Recursively replace the chunks to recover executable code.\todo{Explain.}


\begin{verbatim}
(defun tangle-module (node get-cont ins-links)
  (insert-chunk
   (funcall get-cont node)
   (mapcar #'(lambda (x)
               (cons (car x)
                     (tangle-module (cdr x)
                                    get-cont
                                    ins-links)))
           (funcall ins-links node))))
\end{verbatim}

\subsubsection{On `insert-chunk'}
\label{sec:org45da921}

Given a node and an association list of replacement texts, insert
the chunks at the appropriate places.


\begin{verbatim}
(defun insert-chunk (body chunks)
  (cond ((null body) nil)
        ((null chunks) body)
        ((equal (car body) '*insert*)
         (cdr (assoc (cadr body) chunks)))
        (t (cons (insert-chunk (car body) chunks)
                 (insert-chunk (cdr body) chunks)))))
\end{verbatim}

\subsubsection{Functions for rewriting nemas}
\label{sec:orge029379}

Several functions for rewriting nemas.\todo\{How does this stuff relate to what's
going on in the vicinity of Note \ref{sec:orgba6628b}?\}


\begin{verbatim}
(defun set-src (n x)
  (if (equal n 0)
      0
    (progn (let ((old-backlink
                  (nth 1 (assoc (get-src n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((new-backlink
                  `(nth 1 (assoc x (cdr article-list)))))
             (setcdr new-backlink (cons n (cdr new-backlink))))
           (setcar (nth 1 (assoc n (cdr article-list))) x))))

(defun set-txt (n x)
  (setcar (cdr (cdr (assoc n (cdr article-list)))) x))

(defun set-snk (n x)
  (if (equal n 0)
      0
    (progn (let ((old-backlink
                  (nth 3 (assoc (get-snk n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((new-backlink
                  (nth 3 (assoc x (cdr article-list)))))
             (setcdr new-backlink (cons n (cdr new-backlink))))
           (setcar (nth 3 (assoc n (cdr article-list))) x))))

(defun ins-nod (src txt snk)
  (progn (setcdr article-list
                 (cons (list (car article-list)
                             (list src)
                             txt
                             (list snk))
                       (cdr article-list)))
         (let ((backlink
                (nth 3 (assoc snk (cdr article-list)))))
           (setcdr backlink (cons (car article-list)
                                  (cdr backlink))))
         (let ((backlink
                (nth 1 (assoc src (cdr article-list)))))
           (setcdr backlink (cons (car article-list)
                                  (cdr backlink))))
         (- (setcar article-list (+ 1 (car article-list))) 1)))

(defun del-nod (n)
  (if (or (equal n 0)
          (get-blk n)
          (get-flk n))
      nil
    (progn (let ((old-backlink
                  (nth 3 (assoc (get-snk n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((old-backlink
                  (nth 1 (assoc (get-src n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (setcdr article-list
                   (delete (assoc n (cdr article-list))
                           (cdr article-list)))
            t)))
\end{verbatim}
\subsection{Initialization}
\label{sec:orge104aa3}

\subsubsection{Initialize with a new network}
\label{sec:orge4f56f1}

For now, we just create one network to import things into.  Additional
networks can be added later.


\begin{verbatim}
(set-current-plexus (add-plexus))
\end{verbatim}

\section{Part V — SQL Storage Backend}
\label{sec:orgfe856d3}
This is omitted in the current build, though it could be reintroduced
if that was useful.

\section{Part VI — Adding and Interacting with Articles}
\label{sec:org6ecd558}
\subsection{Database interaction}
\label{sec:org7a2d2c6}
\subsubsection{The `article' function}
\label{sec:orgefd95b5}
You can use this function to create an article with a
given name and contents.  You can optionally put it in a
list by specifying the heading that it is under.  (If this
is used multiple times with the same heading, that just becomes
a cone over the contents.)


\begin{verbatim}
(defun article-2 (name contents &optional heading)
  (let ((coordinates (add-nema name
                               "has content"
                               contents)))
    (when heading (add-nema coordinates "in" heading))
    coordinates))
\end{verbatim}

\subsubsection{The `scholium' function}
\label{sec:org6e3fd04}
You can use this function to link annotations to objects.
As with the `article' function, you can optionally
categorize the connection under a given heading (cf. Note
\ref{sec:orgefd95b5}).


\begin{verbatim}
(defun scholium-2 (beginning link end &optional heading)
  (let ((coordinates (add-nema beginning
                               link
                               end)))
    (when heading (add-nema coordinates "in" heading))
    coordinates))
\end{verbatim}

\subsubsection{On `get-article'}
\label{sec:orgf2f4816}
Get the contents of the article named `name'.
We assume that there is only one such article for now.


\begin{verbatim}
(defun get-article (name)
  (get-sink
   (first
    (nemas-given-beginning-and-middle
     (first
      (nemas-given-beginning-and-end
       name "arxana-merge.tex"))
     "has content"))))
\end{verbatim}

\subsubsection{On `get-names'}
\label{sec:org19efe9d}
This function simply gets the names of articles that have
names -- in other words, every triple built around the
``has content'' relation.\todo\{This seems to work but
are both map operations needed?\}


\begin{verbatim}
(defun get-names (&optional heading)
  (mapcar #'get-source
   (mapcar #'get-source (nemas-given-middle "has content"))))
\end{verbatim}
\subsection{Supplying initial bookkeeping information}
\label{sec:org4f78b48}
\subsubsection{On `sch-book'}
\label{sec:org9d270d7}
Interactive functions that call `scholium' should always provide
\inp{bookkeeping} information.

The following definition can be extended to add any sort of initial
bookkeeping information we might like to maintain.  The
\inp{bookkeeping} field will be revised when the article is edited
(see Section ).


\begin{verbatim}
(defun sch-book ()
  `((created ,user-login-name ,(current-time-string))))
\end{verbatim}
\subsection{Adding text from an existing source}
\label{sec:org3318689}
\subsubsection{On `make-current-buffer-into-article'}
\label{sec:org21be5ed}

We store the object representing the buffer in the \inp{text} field.
There is no particular reason to set the \inp{type} (at least, one has
yet to appear).

An alternative approach would be to make an article's \inp{text}
reflect the current contents of the buffer (i.e., save the buffer as a
string) -- but we currently don't do this.  However, it would probably
be nice to have that option, or even just the option to make a certain
selection into an article.


\begin{verbatim}
(defun make-buffer-into-article (&optional buffer name)
  (let* ((buffer (or buffer
                     (get-buffer (read-buffer
                                  "Buffer: "
                                  (buffer-name
                                   (current-buffer))
                                  t))))
         (name (or name
                   (read-string "Name: "
                                nil
                                nil
                                (buffer-name buffer))))
         (sync-context (and (fboundp 'futon4--article-context-for-buffer)
                            (futon4--article-context-for-buffer buffer))))
    (scholium name buffer nil nil (sch-book))
    (when sync-context
      (let* ((article-path (plist-get sync-context :path))
             (article-id (and (fboundp 'futon4--article-id-for)
                              (futon4--article-id-for name article-path))))
        (when (and article-id (fboundp 'futon4-ensure-article-entity))
          (futon4-ensure-article-entity article-id name article-path))))))

(defun make-current-buffer-into-article (name)
  (interactive (list (read-string
                      (concat "Name (default "
                              (buffer-name (current-buffer)) "): ")
                      nil
                      nil
                      (buffer-name (current-buffer)))))
  (make-buffer-into-article (current-buffer) name))
\end{verbatim}

\subsubsection{On `make-file-into-article'}
\label{sec:org6eb42e9}

This function adds a file to the article list.  Again, the \inp{text}
field is not filled in with a string representing the text directly,
but rather, with the name of the file that holds the text.  A token is
added to the \inp{type} field explaining that this is a file.


\begin{verbatim}
(defun make-file-into-article (path name)
  (interactive
   (let* ((bufn (buffer-file-name))
          (pth (read-file-name
                (if bufn
                    (concat "File (default: " bufn "): ")
                  (concat "File: "))
                nil
                (if bufn
                    bufn
                  (default-directory))))
          (dnme (file-name-nondirectory pth))
          (nme (read-string (concat "Name (default: " dnme "): ")
                            nil
                            nil
                            dnme)))
     (list pth nme)))
  (scholium name path nil '(file) (sch-book))
  (let* ((canonical (and (fboundp 'futon4--canonical-path)
                         (futon4--canonical-path path)))
         (article-id (and (fboundp 'futon4--article-id-for)
                          (futon4--article-id-for name canonical))))
    (when (and article-id (fboundp 'futon4-ensure-article-entity))
      (futon4-ensure-article-entity article-id name canonical))))
\end{verbatim}
\subsection{Interactively supplying text}
\label{sec:orga696fee}
\subsubsection{Global varibles describing new scholia}
\label{sec:orgc74ea42}

The variables `new-scholium-name' and `new-scholium-about' are used to
build new articles interactively.  For now, \inp{type} is ignored by
these functions.  Also, we don't have a `new-scholium-text' field,
since we get the text another way.  It could be that an approach with
a `new-scholium-text' variable would allow us to unify the treatment
here with the one used in previous subsections.


\begin{verbatim}
(defvar new-scholium-name nil "Name of our new scholium.")
(defvar new-scholium-about nil "What the new scholium is about.")
\end{verbatim}

\subsubsection{On `new-scholium-mode'}
\label{sec:org66bd7fe}

This mode is invoked by `make-scholium' in the buffer in which the new
scholium's \inp{text} is to be supplied.


\begin{verbatim}
(define-minor-mode new-scholium-mode
  "Mode for composing a new scholium.
\\{new-scholium-mode-map}"
  :init-value nil
  :keymap '(("\C-c\C-c" . escape-scholium-creation)))
\end{verbatim}

\subsubsection{On `escape-scholium-creation'}
\label{sec:org2806449}

Once the new scholium's \inp{text} has been supplied, this function
creates a scholium from that text and other data the user has
supplied.  It then restores the window configuration that was active
before `make-scholium' ran.  It also nullifies `new-scholium-name'
and `new-scholium-about', since we're done with these things.


\begin{verbatim}
(defun escape-scholium-creation ()
  (interactive)
  (scholium new-scholium-name
            (buffer-substring-no-properties (point-min) (point-max))
            new-scholium-about
            nil
            (sch-book))
  (kill-buffer (concat "Editing scholium: " new-scholium-name))
  (set-window-configuration sch-win-config)
  (setq new-scholium-name nil
        new-scholium-about nil))
\end{verbatim}

\subsubsection{On `make-scholium'}
\label{sec:orgf246e3e}
This function is called every time the user makes a scholium with new
text (i.e. text that is typed in on the fly).  Functions for making
scholia about articles, parts of articles, buffers, etc., are given in
this document and all use this function.


\begin{verbatim}
(defun make-scholium ()
  (setq sch-win-config (current-window-configuration))
  ;; we allow this to be set elsewhere
  (unless new-scholium-name
    (setq new-scholium-name (read-string "Scholium name: ")))
  (set-buffer (get-buffer-create "Scholia Display"))
  (other-window -1)
  (split-window-vertically)
  (other-window 1)
  (switch-to-buffer (get-buffer-create (concat "Editing scholium: "
                                               new-scholium-name)))
  (new-scholium-mode))
\end{verbatim}

\subsubsection{On `make-scholium-about-current-article'}
\label{sec:orgf300656}

This function makes a scholium about the article as a whole.


\begin{verbatim}
(defun make-scholium-about-current-article ()
  (interactive)
  (when name-of-current-article
    (setq new-scholium-about `(((,name-of-current-article))))
    (make-scholium)))
\end{verbatim}

\subsubsection{On `make-scholium-about-part-of-current-article'}
\label{sec:org144ecc6}
This function makes a scholium about one specific portion of the
article.

This function makes the (somewhat unrealistic seeming) assumption that
the current article and the current buffer are the same thing.  This
situation should be resolved.

However, if no article is current yet, then perhaps we should
offer to make a scholium about the current buffer?


\begin{verbatim}
(defun make-scholium-about-part-of-current-article (beg end)
  (interactive "r")
  (if name-of-current-article
      (progn
        (setq new-scholium-about
              `((,name-of-current-article
                  (passage 
                   ,beg
                   ,end))))
        (make-scholium)
        (deactivate-mark)
        (message (concat (format "%s--%s" beg end) " added.")))
    (message "Make some article current first.")))
\end{verbatim}

\subsubsection{On `make-scholium-about-current-line'}
\label{sec:org546c550}

Here is a little convenience wrapper for working with lists.


\begin{verbatim}
(defun make-scholium-about-current-line ()
  (interactive)
  (make-scholium-about-part-of-current-article (line-beginning-position)
                                               (line-end-position)))

(defun make-scholium-about-current-line-quickly ()
  (interactive)
  (setq new-scholium-name (buffer-substring-no-properties
                           (line-beginning-position)
                           (line-end-position)))
  (make-scholium-about-part-of-current-article (line-beginning-position)
                                               (line-end-position)))

(defun make-scholium-about-current-line-quickly-and-completely ()
  (interactive)
  (scholium (buffer-substring-no-properties
                           (line-beginning-position)
                           (line-end-position))
            (buffer-substring-no-properties
                           (line-beginning-position)
                           (line-end-position))
            `((,name-of-current-article 
               (passage
                ,(line-beginning-position)
                ,(line-end-position))))
            nil
            (sch-book)))

(defun make-scholium-about-current-sentence ()
  (interactive)
  (make-scholium-about-part-of-current-article (line-beginning-position)
                                               (line-end-position)))
\end{verbatim}

\subsubsection{On `reading-regions-mode'}
\label{sec:org94cbaa6}

This mode is invoked by
`make-scholium-about-several-parts-of-current-article', and
adds an editing mode in the buffer containing the current
article that enables the user to select regions that the
scholium will be \inp{about}.


\begin{verbatim}
(define-minor-mode reading-regions-mode
  "Mode for reading in regions.
\\{new-scholium-mode-map}"
  :init-value nil
  :keymap '(("\C-c\C-c" . add-region)
            ("\C-c\C-g" . escape-reading-regions-mode))
  (message "C-c C-c to add regions; C-c C-g to make scholium."))
\end{verbatim}

\subsubsection{On `add-region'}
\label{sec:orge34a15f}

This function adds regions to `new-scholium-about'.


\begin{verbatim}
(defun add-region (beg end)
  (interactive "r")
  (setq new-scholium-about
        (cons `(,name-of-current-article
                 (passage 
                  ,(region-beginning)
                  ,(region-end)))
              new-scholium-about))
  (deactivate-mark)
  (message (concat (format "%s--%s" beg end) " added.")))
\end{verbatim}

\subsubsection{On `escape-reading-regions-mode'}
\label{sec:org1a4a50f}

When all of the regions desired have been selected, this function
calls `make-scholium' to finish things off.


\begin{verbatim}
(defun escape-reading-regions-mode ()
  (interactive)
  (reading-regions-mode -1)
  (make-scholium))
\end{verbatim}

\subsubsection{On `make-scholium-about-several-parts-of-current-article'}
\label{sec:org8e60d1f}
This function makes a scholium that applies to several portions of the
article, using the mode and so on featured in this section.

(Note, it doesn't seem that this is displayed quite right; I'm
getting two copies of the scholium's text in the Scholia
Display buffer.)


\begin{verbatim}
(defun make-scholium-about-several-parts-of-current-article ()
  (interactive)
  (let ((article (get-article name-of-current-article)))
    (if (article-buffered article)
        (switch-to-buffer (get-buffer (scholium-text article)))
      (switch-to-buffer "Main Article Display"))
    (setq new-scholium-about nil)
    (reading-regions-mode 1)))
\end{verbatim}

\subsubsection{Scholia about the current buffer} \label{about-buffer}

\subsubsection{On `call-if-user-adds-current-buffer-to-article-list'}
\label{sec:orge185787}

This is used by functions that require the current buffer to
be an article; typically they recall themselves after the
buffer has been added.  It is used by
`make-scholium-about-current-buffer' and
`display-scholia-about-current-buffer'.


\begin{verbatim}
(defun call-if-user-adds-current-buffer-to-article-list (fct)
  (when (y-or-n-p "Buffer not an article, add to list? ")
        (make-current-buffer-into-article
         (read-string (concat "Name (default: "
                              (buffer-name
                               (current-buffer)) "): ")
                      nil
                      nil
                      (buffer-name (current-buffer))))
        (funcall fct)))
\end{verbatim}

\subsubsection{On `make-scholium-about-current-buffer'}
\label{sec:orgfd44c06}

This function makes a scholium about the current buffer,
requiring that it be an article.  (Maybe we should
just add the current buffer to the article list
transparently, rather than giving the prompt in
`call-if-user-adds-current-buffer-to-article-list'.)


\begin{verbatim}
(defun make-scholium-about-current-buffer ()
  (interactive)
  (let ((article (get-article (buffer-name (current-buffer)))))
    (if (not article)
        (call-if-user-adds-current-buffer-to-article-list
         'make-scholium-about-current-buffer)
      (setq new-scholium-about
            `(((,(buffer-name (current-buffer))))))
      (make-scholium))))
\end{verbatim}

\subsubsection{On `genref'}
\label{sec:orgdeb9ead}
Instead of using `gensym' (which causes problems) we do something
similar to generate references with unique ids.  Note that this might
cause some problems when we go to the distributed way of doing things
(or even just save and restore articles with references in them after
making some intervening edits), since references with the same names
might mean different things.  But of course, this is true of all
scholia with the same names, so I propose not to worry about it too
much right now.

It may turn out to be advantageous to use a reference counter that is
local to each article.

Actually, the scheme proposed here seems pretty weak; saving files and
then reading them back in after Emacs has been shut down could cause
problems.  It might be much better to have a reference counter in each
metadata article, so that the collection of references associated with
a given article is always unique.  Furthermore, references associated
with a given article should possibly be recorded on that article's
metadata explicitly \emph{as references}.


\begin{verbatim}
(defvar *reference-counter* 0)

(defun genref ()
  (setq *reference-counter* (1+ *reference-counter*)))
\end{verbatim}

\subsubsection{On `make-reference-in-current-article'}
\label{sec:org4f687d5}
This function is similar to
`make-scholium-about-part-of-current-article' (Note
\ref{sec:org144ecc6}) except that the
\inp{type} is set to ``reference''.  References currently don't have any
\inp{text}, but we could later set things up to let them have a
docstring or something like that.

(Are backlinks working properly in an article that has several
references associated with it?)


\begin{verbatim}
(defun make-reference-in-current-article (beg end &optional target)
  (interactive "r")
  (let ((target (or target
                    (read-article-name))))
    (if name-of-current-article
        (when target
          (scholium `(reference ,name-of-current-article ,(genref))
                    nil
                    `((,name-of-current-article
                       (passage 
                        ,beg
                        ,end))
                      (,target))
                    'reference)
          (deactivate-mark))
      ;; Maybe the message should instead be an offer to make
      ;; a scholium about the current buffer?
      (message "Make some article current first."))))
\end{verbatim}

\subsubsection{Speedy reference creation}
\label{sec:org65ad894}

It would be handy to be able to make a reference to an article and
automatically create and follow the reference, all at the same time.
(Maybe also subsets of these actions, like create but don't follow.)
Probably we could do something similar for generalized references.


\begin{verbatim}
(defun create-follow-reference ()
  (interactive)
  (let ((name (buffer-substring (point) (mark))))
    (unless (get-article name)
      (save-excursion
        (set-buffer (get-buffer-create name))
        (make-current-buffer-into-article name)))
    (make-reference-in-current-article (min (point) (mark))
                                       (max (point) (mark))
                                       name)
    (display-article name)))
\end{verbatim}

\subsubsection{Reference component access}
\label{sec:org749e995}
These functions give easy access to information specifying the
referenced article (the target), the region the reference applies to,
and the name of the article the reference lies in.  These functions
rely on the formulaic nature of the \inp{type} data of references,
namely, a link to the passage wherein the reference is made is given,
followed by a link to the referenced article.

Notice that these functions would have to change if we later
allow multiple sources (presumably, regions) to be part of the
same reference.


\begin{verbatim}
(defun reference-source-link (reference)
  (first (scholium-about reference)))

(defun reference-from-article (reference)
  (car (reference-source-link reference)))

(defun reference-to-article (reference)
 (car (second (scholium-about reference))))
\end{verbatim}

\subsubsection{On `make-new-undirected-article'}
\label{sec:orgde6cfab}

Although one could simply create a new buffer and add that buffer to
the article list (as in Section

), sometimes it
may be more intuitive to simply add a new undirected article directly
to the article list.


\begin{verbatim}
(defun make-new-undirected-article ()
  (interactive)
  (setq new-scholium-about nil)
  (make-scholium))
\end{verbatim}

\subsubsection{Followups} \label{followups}

\subsubsection{On `name-of-current-scholium'}
\label{sec:orgb2e131f}

The function can be called from anywhere; ``current'' is defined
relative to the position of `point' in the Scholia Display buffer.
(It is natural to assume that there is only one current scholium,
given the way the contents of this buffer have been put together.)

Note that \emph{scholia} appear once in the Scholia Display buffer, so
there is only one ``current scholium'' (with one name) when we look at
things this way.  If we were going to do something like this for the
main article buffer, then we'd need to do a bit more.  (In fact,
various functions to associate marked regions with scholia need just
this sort of special touch.)


\begin{verbatim}
(defun name-of-current-scholium ()
  (interactive)
  (save-excursion
    (set-buffer (get-buffer-create "Scholia Display"))
    (let ((ret (car (scholia-named-at-point))))
      (if ret
          (message (format "%s" ret))
        (message "Position cursor on a scholium in Scholia Display."))
      ret)))

(defun make-scholium-about-current-scholium ()
  (interactive)
  (when (equal (buffer-name (current-buffer)) "Scholia Display")
    (let ((cur (name-of-current-scholium)))
      (when cur
        (progn (setq new-scholium-about `(((,cur))))
               (make-scholium))))))
\end{verbatim}

\section{Part VII — Rendering and Browsing}
\label{sec:org51a6be4}
\subsection{Formatting articles for display}
\label{sec:orgd0e4ace}
\subsubsection{On `sch-plain-text-hook'}
\label{sec:orgc364937}
Alternative ways of setting the return value of `sch-plain-text'.


\begin{verbatim}
(defvar sch-plain-text-hook nil)
\end{verbatim}

\subsubsection{On `sch-plain-text'}
\label{sec:org66e74d8}
This function is called by `mark-up-scholium' to render scholia that
are to be displayed alongside the main article, and also by
`transclude-article' (see Note \ref{sec:orgddd20ad}) and other
functions in Section \ref{sec:orgabef2cd}.

Its goal is to turn arbitrary articles into strings.  This will be
done in different ways depending on the sort of article in question.
(And could be done in other ways depending on other stuff.)  Compare
Note \url{2.2-Design_issues.org}.

Here's how it works: different kinds of ``objects'' are to be
distinguished from one another by simple tests -- is the `car' equal
to \verb|passage|?  Does looking up the object in the article table
produce anything?  Then act as appropriate, grabbing the text that is
specified.  Currently it works on input \emph{article names} or
input \emph{articles}.  (If input is both the name of an article
and an article, it will be treated as a name.)

Another thing that might be handy to be able to process is
\emph{simple strings}, which aren't article names, or articles
(obviously).

Note that links are rendered differently depending on context.

Links can't actually run from arbitrary object to arbitrary
object within the current version of the system.  That can
probably be fixed easily.

Converting the function to render scholium system objects in general
is a step towards answering the request in Note
\ref{sec:org8f44bfc} about extending the purview of
`display-article'.  At that point, it will take more than just a
\inp{title} as argument, certainly; and it will need a ``triage''
phase in order to figure out what sort of object it has been applied
to; various modifications will have to be made so that it can be
applied to various sorts of objects.


\begin{verbatim}
(defun sch-plain-text (title-or-article)
  ;; this overloading of the input & reliance upon `get-article' to
  ;; sort things out... could probably be revised into something
  ;; better
  (let* ((obj (or (get-article title-or-article)
                  title-or-article))
         (text (scholium-text obj))
         (type (scholium-type obj))
         ret)
    ;; This seems like the correct way to override a `cond' form.
    (run-hooks 'sch-plain-text-hook)
    (when (not ret)
      (cond
       ((bufferp text)
        (save-excursion (set-buffer (get-buffer text))
                        (setq ret (buffer-string))))
       ((typedata-includes type 'file)
        (let ((bufs (buffer-list))
              (live nil))
          (while (and bufs (not live))
            (when (equal (buffer-file-name (car bufs))
                         (expand-file-name text))
              (setq live (car bufs)))
            (setq bufs (cdr bufs)))
          (if live
              (progn (set-buffer live)
                     (setq ret (buffer-string)))
            (find-file text)
            (setq ret (buffer-string))
            (kill-buffer (current-buffer)))))
       ;; these quoted things should presumably themselves be rendered
       ;; as links (and we probably don't need the crazy markup for
       ;; things about the whole buffer, ever)
       ((typedata-includes type 'reference)
        (if (equal (reference-to-article obj)
                   name-of-current-article)
            (setq ret
                  ;; it might be kind of cool to at least include a
                  ;; snippet of the context of this link, say 3 lines
                  ;; worth
                  (format "\"%s\" links here."
                          (reference-from-article obj)))
          (setq ret
                (format "This is a link from \"%s\" to \"%s\"."
                        (reference-from-article obj)
                        (reference-to-article obj)
                        obj))))
       ((stringp text)
        (setq ret text))
       (t
        (setq ret (format "%S" text)))))
    ret))
\end{verbatim}
\subsection{Managing windows and buffers}
\label{sec:orgea085fa}
\subsubsection{Dot dot dot}
\label{sec:org9e88bf4}

How should scholia in later generations be displayed?  In the default
mode, without threading, a ``dot dot dot'' would be useful.  (And in
the case of scholia that bridge the gap between two articles, the
``dot dot dot'' probably needs to have a special meaning.)  Anyway,
note that these dot-dot-dotted things could be found by a depth-first
search through the document collection.  (Find anything \inp{about}
the current article, then find anything \inp{about} that, etc., then
find the next thing \inp{about} the current article, 
etc.)\footnote\{Compare the 2nd figure in Corneli and Krowne (2005)
(cf. Footnote

Page \pageref{corneli-krowne}).\}.
\% How to get page reference corresponding to a label?


\begin{verbatim}
(defvar pre-sch-win-config nil "Saved window configuration.")
(defvar sch-win-config nil "Saved window configuration.")

(defvar buffer-associated-with-current-article nil)
\end{verbatim}

\subsubsection{On `article-buffered'}
\label{sec:orga94990c}

Here's a little convenience function that tells you whether the
article's text lives in a buffer or not.


\begin{verbatim}
(defun article-buffered (article)
  (bufferp (scholium-text article)))
\end{verbatim}

\subsubsection{On `scholia-overwhelm-display'}
\label{sec:org52c21c2}
This function displays scholium stuff.  It is called by
`display-article' (Note \ref{sec:org3731def}) and
`display-scholia-about-current-buffer'
(Note \ref{sec:org4d4a72e}).  If
there is a main article buffer (i.e. the article to be displayed lives
in its own buffer), we use that buffer to display the article;
otherwise, we use the ``Main Article Display'' buffer.  Scholia that
match the appropriate set of conditions in `mark-things-up' will be
rendered to the ``Scholia Display'' buffer.


\begin{verbatim}
(defun scholia-overwhelm-display (text)
  (unless pre-sch-win-config
    (setq pre-sch-win-config (current-window-configuration)))
  (delete-other-windows)
  (split-window-horizontally)
  (if rendering-target-buffer
      (pop-to-buffer rendering-target-buffer t)
    (switch-to-buffer (get-buffer-create "Main Article Display") t))
  (erase-buffer)
  (insert text)
  (goto-char (point-min))
  (setq buffer-associated-with-current-article (current-buffer))
  (other-window 1)
  (switch-to-buffer (get-buffer-create "Scholia Display") t)
  (erase-buffer))
\end{verbatim}

\subsubsection{Switching between views}
\label{sec:org0105806}
We offer a few convenient functions for switching between the
article-plus-scholia browsing display and whatever came before.  It
would also be nice to offer a function for switching between the
article display and the generic listing display.


\begin{verbatim}
(defun back-to-normal ()
  (interactive)
  (setq sch-win-config (current-window-configuration))
  (set-window-configuration pre-sch-win-config)
  (setq pre-sch-win-config nil))

(defun back-to-other-view ()
  (interactive)
  (setq pre-sch-win-config (current-window-configuration))
  (set-window-configuration sch-win-config)
  (setq sch-win-config nil))
\end{verbatim}
\subsection{Sorting scholia for markup purposes}
\label{sec:orgabca713}
\subsubsection{On `first-beginning-about-article'}
\label{sec:orgb1e7732}

Return 0 if \inp{about} is about all of \inp{article}, i.e., otherwise
return the character position of the first region within \inp{article}
that \inp{about} is actually about.  If there is none, return nil.
(Actually, let me note that in the usage we have established so far,
we would already know that in the case that \inp{about} is a string,
it is about the article here, and in the case that \inp{about} is a
one-layer list, similarly; so some of the tests we do here are as yet
unneeded.)

Here we're assuming that if there is \emph{some} link to the article
that isn't a passage link, then we treat the link as about the article
as a whole.  The case in which the link is about the whole article
\emph{and} some part of the article might possibly be better treated
some other way; but I'll leave that case for subsequent work.


\begin{verbatim}
(defun first-beginning-about-article (about article)
  (cond
   ;; condition for the scholium to be about the article as a whole.
   ;; The condition is that there is _some_ link to the article that
   ;; is NOT a ``passage''-type link.  In this case, we just return 0.
   ((member-if (lambda (link) 
                 (and (equal (car link) article)
                      (not (link-type-accessor link 'passage))))
               about)
    0)
   ;; else, collect the regions of `article' that `about' indicates,
   ;; and sort them.
   (t
    (let* ((marking-links
            (let (marked)
              (mapc (lambda (elt)
                      (when (and
                             (typedata-includes-passage (link-type elt))
                             (equal (linked-to-article elt) article))
                        (setq marked (cons elt marked))))
                    about)
              marked))
           (earliest-link
            (car (sort
                  marking-links
                  (lambda (link1 link2)
                    (< (link-beginning link1)
                       (link-beginning link2)))))))
      (link-beginning earliest-link)))))
\end{verbatim}

\subsubsection{On `sort-scholia-by-beg-position'}
\label{sec:org37b315f}
This function orders \inp{scholia} according to the magnitude of the
smallest beginning a region of \inp{article} that the input scholia
mark.  All links are considered when finding the first marked region.


\begin{verbatim}
(defun sort-scholia-by-beg-position (scholia article)
  (setq
   scholia
   (sort scholia
         (lambda (scholium1 scholium2)
           (let ((beg1 (first-beginning-about-article 
                        (scholium-about scholium1)
                        article))
                 (beg2 (first-beginning-about-article
                        (scholium-about scholium2)
                        article)))
             (and beg1
                  beg2
                  (< beg1 beg2)))))))
\end{verbatim}
\subsection{Marking things up}
\label{sec:org60c3d88}
\subsubsection{On `new-simple-scholium-face'}
\label{sec:orgdf54511}

Adapted from ttn's \kw{ricette-mode.el}. \emph{Nota bene}: new faces
are automatically customizable, so if you don't like the way they
look, you can change them.


\begin{verbatim}
(defmacro new-simple-scholium-face (num color doc)
  (let ((prop (intern (concat "sch-face-" (int-to-string num)))))
    `(progn
       (defvar  ,prop ',prop)
       (defface ,prop
         '((t (:foreground ,(symbol-name color)
               :underline ,(symbol-name color)))) ,doc))))
\end{verbatim}

\subsubsection{Underlining versus foreground}
\label{sec:org6f073ea}
It is worth considering using the underline attribute instead or in
addition to the foreground attribute: underlining would be less
obtrusive in documents that already use faces.  We could have two
variants; one with underlining for the main article, one foreground
for the scholia display.  We could also give users some
immediately-customizable options.  (Do the default colors I picked out
work well?)


\begin{verbatim}
(new-simple-scholium-face 1 maroon1 "First scholium face.")
(new-simple-scholium-face 2 aquamarine1 "Second scholium face.")
(new-simple-scholium-face 3 IndianRed1 "Third scholium face.")
(new-simple-scholium-face 4 yellow1 "Fourth scholium face.")
(new-simple-scholium-face 5 firebrick1 "Fifth scholium face.")
(new-simple-scholium-face 6 plum1 "Sixth scholium face.")
\end{verbatim}

\subsubsection{Reference face}
\label{sec:org60566cc}
A special face for references.  We don't currently have a special face
for \emph{visited} references, but this can be added if/when we start
keeping track of which references have been visited (see Note
).  We might also want to record and display
information about visited articles in general.


\begin{verbatim}
(defface sch-reference-face
  '((t (:foreground "red" :underline "red")))
  "Face for references in the scholium system.")
\end{verbatim}

\subsubsection{Color by number}
\label{sec:org36eef07}
The `scholia-count' variable keeps track of how many scholia have been
 displayed.  The `scholium-face' function selects a face to use when
 displaying the next scholium according to this count.  This simple
 display mechanism seems sort of lame (hence, it is turned on with the
 `use-crazy-font-lock' variable); better things may come later, see,
 e.g. Note \url{2.2-Design_issues.org}.

Note that turning off ``crazy font lock'' makes it so that no text
properties are added to the buffer, but of course it would be best if
text properties were added and overlays omitted.  On the other hand,
we need to do some thinking to sort out the use of text properties
versus the use of overlays.  Cutting and pasting multiple copies of
some markup in the same buffer may cause some trouble at commit time.
See Section \ref{sec:orgabef2cd}; also, compare Note
.


\begin{verbatim}
(defvar scholia-count 0 "Number of scholia about the article found.")

(defun scholium-face ()
  (let ((short-count (mod scholia-count 6)))
    (cond ((eq short-count 0)
           'sch-face-1)
          ((eq short-count 1)
           'sch-face-2)
          ((eq short-count 2)
           'sch-face-3)
          ((eq short-count 3)
           'sch-face-4)
          ((eq short-count 4)
           'sch-face-5)
          ((eq short-count 5)
           'sch-face-6))))

(defvar use-crazy-font-lock t)
(defvar main-article-overlays nil)
(defvar scholia-overlays nil)
\end{verbatim}

\subsubsection{Access to rendering target buffer}
\label{sec:org9b93339}
The rendering target buffer is either ``Main Article Display'' if the
current article isn't buffered, or whatever buffer the article lives
in if it is buffered.  (Well, actually, we can always redirect
rendering to any buffer of our choice; but the preceding statement
accurately describes the default operation.)  We use
`get-rendering-target-buffer' as a shorthand when we grab the
rendering target buffer, and `set-buffer-to-rendering-target-buffer'
to make that buffer current for editing.  (Note that we \emph{could}
go about this in a slightly different way, namely set the
`rendering-target-buffer' variable to ``Main Article Display'' instead
of `nil' when there is nothing to override the default -- but what
would be the point?)


\begin{verbatim}
(defun get-rendering-target-buffer ()
  (get-buffer (or rendering-target-buffer
                  (get-buffer "Main Article Display"))))

(defun set-buffer-to-rendering-target-buffer ()
  (set-buffer (get-rendering-target-buffer)))
\end{verbatim}

\subsubsection{Experiment with many `scholium' properties}
\label{sec:orgad60c7d}
All else equal, it might be advantageous to use independent `scholia'
properties instead of just one `scholium' property (see Note
\ref{sec:org9ed88c3}).

Accordingly, I tried switching over to using one `scholium' property
for each marked-up region.  These properties were given somewhat
complicated names -- namely, the link-ids that are currently stored as
elements of the `scholia' property (Note ).
However, this doesn't work, as suggested by the following example.
\begin{verbatim}
(progn (put-text-property (point) (1+ (point)) '(foo 1) t)
       (put-text-property (point) (1+ (point)) '(foo 1) nil)
       (text-properties-at (point)))
\end{verbatim}
This is because\footnote\{Thanks Andreas Schwab, help-gnu-emacs,
2005/12/12. \label{so-called-text-property-bug}\}
\begin{verbatim}
(eq '(foo 1) '(foo 1)) ;=> nil
\end{verbatim}

The Emacs text property engine is uniformly `eq'-based instead of
`equal'-based.  (So, if we happened to have an association between
link-id's and integers, this would have worked, but that seems like a
silly kludge.)

Indeed, this `eq' preference is pretty much fatal to the utility of
non-symbol text properties (unless we managed to hang directly onto
the actual link-ids that would be used for the names of the text
properties, which seems infeasible; or alternatively used some other
sort of weird work-around, as above).  A further difficulty is
associated with the fact that these various `scholium' text properties
would be indiscriminately mixed in with any other text properties that
happened to be stored at point, requiring filtering for any useful en
masse processing. 

I have some ideas that could possibly improve the prospects for doing
away with the `scholia' property and replacing it with several
`scholium' properties, but it seems like anything realistic would
hacking Emacs C.  But since it seems that there are no immediate
problems associated with using just one `scholia' property, we plunge
ahead that way.


\subsubsection{On `add-to-scholia-property-within-region'}
\label{sec:org5b604d6}
For each character in the region between \inp{beg} and \inp{end}, this
function grabs the `scholia' property and replaces it with a version
that has been modified to include the input \inp{value} (a link-id;
see Note ).

The same property is used in the Scholia Display buffer, although that
may be a bit of an abuse (cf. Note
); something simpler would
work for our needs there -- but the current way is expedient.  Also,
it seems to be suggestive -- perhaps in the future we'll be able to
treat the Scholia Display buffer as a proper scholium-based article
itself, presumably by using transclusion and identification, as
appropriate (see Section ).


\begin{verbatim}
(defun add-to-scholia-property-within-region (start end value)
  (while (< start end)
    (put-text-property start (1+ start) 'scholia
                       (add-to-or-start-list
                        (get-text-property start 'scholia)
                        value))
    (setq start (1+ start))))
\end{verbatim}

\subsubsection{On `current-markup'}
\label{sec:org89aa6bd}
This variable will be used to record the regions of the article being
displayed which have scholia attached to them and are, consequently,
marked up.  This information will be stored at markup time by
`mark-up-region' (Note \ref{sec:org2f70f9c}).  It is important to have
this information on record so that we have something to compare to
after editing takes place (see Section \ref{sec:org8da94c7}).

Its format is a list of elements of the form
\begin{verbatim}
((<name> <link number>) <beg> <end>)
\end{verbatim}
where `beg' and `end' denote the beginning and end of the region
marked up via the specified link (but see Note 
\ref{sec:org8cc8aa5}!).


\begin{verbatim}
(defvar current-markup nil)
\end{verbatim}

\subsubsection{Investigating `current-markup' in the context of masks}
\label{sec:org8cc8aa5}
If the link in question is being masked, then the format of
`current-markup' changes from the form described in Note
\ref{sec:org89aa6bd} to the following:
\begin{verbatim}
((mask (<name> <link number>)) <beg> <end>)
\end{verbatim}
where `beg' and `end' denote the beginning and ending of
one particular region coming from the mask for the indicated
link.

I'm not sure this is really sufficient information.  Should we know
\emph{which part} of the mask we're dealing with?  I.e., use something
like a link-id, but for mask components?


\subsubsection{On `mark-up-region'}
\label{sec:org2f70f9c}
Like `add-to-scholia-property-within-region', but also adds to
`current-markup' (see Note \ref{sec:org89aa6bd}).


\begin{verbatim}
(defun mark-up-region (start end value)
  (add-to-scholia-property-within-region start end value)
  (setq current-markup
        (add-to-or-start-list current-markup
                              (list value start end))))
\end{verbatim}

\subsubsection{On `non-printing-types'}
\label{sec:org27cf2ed}

This variable will record a list of the types of scholia that we
typically don't want to print when displaying an article.  The
`derives-from' type is an example of a scholium that we typically
don't want to print; see Note \ref{sec:org6b16af6}.

User should temporarily set `non-printing-types' to `nil' before
`mark-things-up' runs whenever they wish to display all scholia.


\begin{verbatim}
(defvar non-printing-types nil)
\end{verbatim}

\subsubsection{Masks}
\label{sec:org537c937}
In light of the comments in Note , it is possible
to think of a mask as a map that takes a given link to to a region,
and replaces it with a list of several regions.

The format of a mask, then, is
\begin{verbatim}
((<name> <link number>) &rest regions)
\end{verbatim}
where the regions are pairs (two-element lists), each giving the
beginning and end of a region that the link is being redirected to.

This format lacks generality!  Certainly a link that is pointing to
something other than a region may need to be redirected, for example,
a link pointing at a page, when the page gets deleted.  For the time
being, these interesting cases can be dealt with through \emph{ad hoc}
measures.  Eventually we'll want to make a study of all of the
different redirection cases; but getting the platform working
reasonably well takes priority.  (See also Note
.)

Finally, observe that the format used here is related to the format of
the `current-markup' variable (Note \ref{sec:org89aa6bd}).

For an interesting meditation on masking perceptions, see
Lem\footnote{Stanislaw Lem, The Futurological Congress}.


\subsubsection{On `compute-usable-about-data'}
\label{sec:org13a277d}
This function runs within the scope of `mark-things-up' (Note
\ref{sec:org638f79c}).  Its role is to identify the regions to be
marked up, based on the \inp{about} data expressed by attached
scholia, and augmented by any masks associated with this data.  In
short, this is the mask-applying part of the algorithm described in
Note .

The way it works is as follows.  We look through all of the links
(\emph\{although we really don't need to do this anymore, given that we
  have specifically identified the relevant links by using link-id'ed
  backlinks in the article being displayed; the change would have to
  come in at the level of `mark-things-up' or higher\}) -- and if the
link is relevant, then it will be reflected in the value returned by
`compute-usable-about-data'.  However, if the link is masked, it will
be the mask that is reflected, instead of the link itself.

Recall that we can't `assoc' the link across the masks; we need
to `assoc' the link-id instead.

The format of the return value is kind of ugly; we could almost
certainly do without the extra `list' layer.

Note that in the return value, the name of the \emph{scholium} is
supplied, not the name of the linked-to article -- we'll subsequently
know (when applying markup) that all of the links apply to the
linked-to article, whereas we won't know where these links are coming
from unless we record that specially.


\begin{verbatim}
(defun compute-usable-about-data ()
  (let (usable-data
        (about (scholium-about scholium))
        (masks (get-metadata-field 'masks
                                   (scholium-name
                                    scholium)))
        (link-number 0))
    (dolist (link about)
      (setq link-number (1+ link-number))
      (when (link-about-article-p link name-of-current-article)
        (let* ((link-id (list (scholium-name scholium) link-number))
               (mask (assoc link-id masks)))
          (if mask
              (dolist (reg (cdr mask))
                (setq usable-data
                      (add-to-or-start-list
                       usable-data
                       `((mask ,(car mask)) ,@reg))))
            (setq usable-data
                  (add-to-or-start-list
                   usable-data
                   (append (list (list (scholium-name scholium)
                                       link-number))
                           (let ((beg (link-beginning link)))
                             (if beg 
                                 (list beg (link-end link))
                               (list nil))))))))))
    usable-data))
\end{verbatim}

\subsubsection{On `mark-things-up-customizations'}
\label{sec:orgb14f561}
This may not have to be used.


\begin{verbatim}
(defvar mark-things-up-customizations nil)
\end{verbatim}

\subsubsection{On `scholia-display-pre-update-hook'}
\label{sec:org00ee225}
This gives us a chance to do various customizations to the environment
before the main part of `mark-things-up' runs.

I imagine that the role that it will play will be similar to the one
played by the functions that run right in `pre-mark-up', namely to zap
variables and settings that we don't want to have around anymore.


\begin{verbatim}
(defvar scholia-display-pre-update-hook nil)
\end{verbatim}

\subsubsection{On `pre-mark-up'}
\label{sec:org3a9b1ff}

This function generally zaps things, to prepare for markup.


\begin{verbatim}
(defun pre-mark-up ()
  (setq current-markup nil)
  (save-excursion
    (set-buffer-to-rendering-target-buffer)
    (remove-list-of-text-properties (point-min)
                                    (point-max)
                                    '(scholia)))
  (mapcar #'delete-overlay main-article-overlays)
  (setq main-article-overlays nil)
  (setq scholia-count 0))
\end{verbatim}

\subsubsection{On `mark-things-up-hook'}
\label{sec:org8c68add}
For unconditional customizations to `mark-things-up'.
The functions added to this hook run after everything
else `mark-things-up' does is done.


\begin{verbatim}
(defvar mark-things-up-hook nil)
\end{verbatim}

\subsubsection{On `mark-things-up'}
\label{sec:org638f79c}
This function assembles text, text properties, and overlays: it is the
main rendering engine, called by `display-article' to get
scholia and appropriate markup onto the screen.  It is important
that `raw-scholia' be defined (and be a list of scholia)
for this function to work properly.

The first part of the plot is to delete the old markup; we call
`pre-mark-up' to take care of this.

A list of ``raw scholia'' is expected to be present in the context in
which this function runs; typically this data is provided by
`display-article' (see Note \ref{sec:org3731def}), but it can be
supplied by any stand-in (e.g. `display-scholia-about-current-buffer'
of Note \ref{sec:org4d4a72e}).

The raw scholia are first sorted using `sort-scholia-by-beg-position'
(Note \ref{sec:org37b315f}) and then translated into a
usable form by `compute-usable-about-data' (Note
\ref{sec:org13a277d}).

The function `mark-things-up' can handle different sorts of scholia
differently (e.g., references are marked up in the conventional way);
see Note .

In order to \emph{selectively} display scholia, the `raw-scholia'
variable should be modified before this function runs.


\begin{verbatim}
(defun mark-things-up ()
  (pre-mark-up)
  (let ((scholia (sort-scholia-by-beg-position
                  raw-scholia
                  name-of-current-article)))
    (dolist (scholium scholia)
      (unless (typedata-includes-element-of-list
               (scholium-type scholium)
               non-printing-types)
        (let ((usable-about-data (compute-usable-about-data))
              (current-position-in-scholia-display (point)))
          (cond
           ((and
             (typedata-includes (scholium-type scholium) 'reference)
             (equal (reference-from-article scholium)
                    name-of-current-article))
            (mark-up-reference))
           (t
            (mark-up-scholium)))))))
  (run-hooks 'mark-things-up-hook))
\end{verbatim}

\subsubsection{Functions for adding overlays}
\label{sec:orgd74c600}
These function run within the scope of `mark-up-scholium' to
add overlays to the display.


\begin{verbatim}
(defun add-overlays-in-scholia-display-buffer ()
  (setq scholia-overlays
        (cons
         (make-overlay current-position-in-scholia-display
                       (point)
                       (get-buffer "Scholia Display")
                       t)
         scholia-overlays))
  (overlay-put (car scholia-overlays)
               'face (scholium-face)))

(defun add-overlays-in-rendering-target-buffer ()
  (setq main-article-overlays
        (cons
         (make-overlay (second elt)
                       (third elt)
                       (get-rendering-target-buffer)
                       t)
         main-article-overlays))
  (overlay-put (car main-article-overlays)
               'face (scholium-face)))
\end{verbatim}

\subsubsection{On `mark-up-reference'}
\label{sec:org59d28c1}
We call this function from `mark-things-up' (Note
\ref{sec:org638f79c}) to render a scholium if it has reference type
and its \inp{about} data indicates that that the reference originates
from (i.e., appears in) the current article.  See Note
\ref{sec:org749e995} for a description of the format of
the return value of the function `reference-source-link' used here.

References should perhaps be rendered differently depending on their
sub-type (in particular, a different face could be used for references
with different sub-types).

(Do we really want to loop through all of the elements of
`usable-about-data'?  Mightn't there be something there corresponding
to the linked-to article?)


\begin{verbatim}
(defun mark-up-reference ()
  (save-excursion
    (set-buffer-to-rendering-target-buffer)
    (dolist (elt usable-about-data)
      (mark-up-region (second elt)
                      (third elt)
                      (first elt))
      (when use-crazy-font-lock
        (setq main-article-overlays
              (cons
               (make-overlay (second elt)
                             (third elt)
                             (get-rendering-target-buffer)
                             t)
               main-article-overlays))
        (overlay-put (car main-article-overlays)
                     'face 'sch-reference-face)))))
\end{verbatim}

\subsubsection{On `mark-up-scholium'}
\label{sec:org833ac0d}

This inserts scholia and marks them up, together with the marked up
regions (when these exist; the function does both whole-article
scholia and region-specific scholia).

The `scholia-count' variable is set for purposes of face selection;
see Note \ref{sec:org36eef07}.


\begin{verbatim}
(defun mark-up-scholium ()
  ;; this part takes place in the scholia display buffer
  (insert (sch-plain-text (scholium-name scholium)))
  (add-to-scholia-property-within-region
   current-position-in-scholia-display
   (point)
   ;; add a list to make it possible to reuse the scholium property
   (list (scholium-name scholium)))
  (when use-crazy-font-lock
    (add-overlays-in-scholia-display-buffer))
  (insert "\n\n")
  ;; this part is relevant to the buffer containing the main article
  (dolist (elt usable-about-data)
    (when (second elt)
      (save-excursion
        (set-buffer-to-rendering-target-buffer)
        (mark-up-region (second elt)
                        (third elt)
                        (first elt))
        (when use-crazy-font-lock
          (add-overlays-in-rendering-target-buffer)))))
  ;; adjust count once everything else is done here, so same count
  ;; applies in both buffers (useful for coloration purposes)
  (setq scholia-count (1+ scholia-count)))
\end{verbatim}
\subsection{Display interface}
\label{sec:orgaa2b6a7}
\subsubsection{On `rendering-target-buffer'}
\label{sec:orge4557db}
If a given \inp{name} is associated with a buffered article, then that
buffer will be where the article is displayed.  If the article to be
displayed is in a buffer, this variable will be set that buffer
object.  Otherwise it will be set to nil.


\begin{verbatim}
(defvar rendering-target-buffer nil)
\end{verbatim}

\subsubsection{On `scholia-display-post-update-hook'}
\label{sec:org92eee88}

This provides a way to customize the article (and
scholia) being displayed.


\begin{verbatim}
(defvar scholia-display-post-update-hook nil)

(add-to-list 'non-printing-types 'fake)
\end{verbatim}

\subsubsection{On `scholia-display-extras'}
\label{sec:orgbce72d4}
This is used to add some extra stuff to the Scholia Display for
purposes of navigation and establishing context.  It is called by
`display-article' (Note \ref{sec:org3731def}) and
`display-scholia-about-current-buffer' (Note
\ref{sec:org4d4a72e}).

It might be nice to have this in the main article window, but that
could also be confusing, especialy if the main article is associated
with some buffer; so I'm taking the route of caution here.  Also note
that according to the principle of order \url{2.2-Design_issues.org} this
stuff should probably appear much later on in the document, perhaps in
Section \ref{sec:org953fc84}.

It might be more appropriate to have some of these extra features
display in or above the main article buffer; the info system has a
nice un-editable bar for display of various navigational data.


\begin{verbatim}
(defun scholia-display-extras ()
  ;; this setting is useful for presentations.
  (goto-char (point-min))
  ;; Be careful that this is ignored when the article is saved or
  ;; otherwise processed internally.
  (insert
   "Title: "
   (propertize (format "%s" name-of-current-article) 'face 'italic)
   "\n\n")
  (goto-char (point-max))
  (run-hooks 'scholia-display-extras-hook)
  (goto-char (point-min)))
\end{verbatim}

\subsubsection{On `display-style'}
\label{sec:orgb97fedd}
As discussed in Section

there are a
number of different styles we'd like to offer users to choose between
when they go to display an article.  For now, the relevant settings
for the display style variable are `plain' (the default, displaying
all scholia) and `contextual' (which causes only those scholia
associated with the region being displayed to appear; see Note
\url{2.2-Design_issues.org}).

There are a few problems here: if we go with the contextual display,
what about scholia that apply to the article as a whole?  That's a
little tricky.  I guess for now we just leave them out?

Set this variable with `set-display-style', not manually.


\begin{verbatim}
(defvar display-style 'plain)
\end{verbatim}

\subsubsection{On `window-displayed-substring'}
\label{sec:orgaf159c2}

This variable will hold the string that is being shown
through a given window at a given point in time.


\begin{verbatim}
(defvar window-displayed-substring nil)
\end{verbatim}

\subsubsection{On `set-display-style'}
\label{sec:org8a0c3c8}
Use this function to control the setting of `display-style' (Note
\ref{sec:orgb97fedd}).  Relevant arguments are `plain', or
`contextual'.

(Actually, anything but `contextual' will set `display-style' to
its default setting.  Eventually, we might want to be able to
have contextual display together with some other non-default features,
at which point we'll have to adjust this function appropriately.)


\begin{verbatim}
(defun set-display-style (style)
  (cond ((eq style 'contextual)
         ;; we may need a "double hook" here, so we get the local
         ;; hooks set up in the correct window
         (add-hook 'display-article-hook
                   'initiate-contextual-updating)
         (setq display-style 'contextual))
        (t
         (remove-hook 'display-article-hook
                      'initiate-contextual-updating)
         (setq display-style 'plain))))
\end{verbatim}

\subsubsection{On `initiate-contextual-updating'}
\label{sec:orgc54798a}

This function gets the rendering target buffer set up
to do live-updating of scholia.

For now, this function doesn't do anything for labels -- since
for now, labels typically don't have scholia on their \inp{text}.
However, this can be undone later, if necessary.

In addition, we don't yet have any code for getting rid of contextual
updating in an individual buffer OTF.
\begin{verbatim}
(remove-hook 'window-scroll-functions
             'set-window-displayed-substring t)
\end{verbatim}


\begin{verbatim}
(defun initiate-contextual-updating ()
  (unless (typedata-includes (scholium-type article) 'label)
    (save-excursion (set-buffer rendering-target-buffer)
                    (add-hook 'window-scroll-functions 
                              'maybe-update-scholia-display nil t))))
\end{verbatim}

\subsubsection{On `maybe-update-scholia-display'}
\label{sec:org3680ddf}
In order for this to work optimally, we'd might to keep track of
a list of the current scholia that are being displayed.  But
for now, I suppose (contrary to this function's name) we can just
redisplay all the scholia we encounter every time.


\begin{verbatim}
(defun maybe-update-scholia-display ()
  (set-window-displayed-substring)
  ;; this is just a ridiculous thing to run -- for testing purposes
  ;; only.  Eventually, we'll actually want to analyse the text, 
  ;; figure out which scholia are relevant, and update the scholia
  ;; display.
  (save-excursion (set-buffer (get-buffer-create "*scratch*"))
                  (erase-buffer)
                  (insert window-displayed-substring)))
\end{verbatim}

\subsubsection{On `set-window-displayed-substring'}
\label{sec:org1afc78b}

This function will be an element of the `window-scroll-functions'
hook when the display mode is set to `contextual'.


\begin{verbatim}
(defun set-window-displayed-substring ()
  (setq window-displayed-substring
        (buffer-substring (window-start)
                          (window-end))))
\end{verbatim}

\subsubsection{Displaying articles}

\subsubsection{On `display-article-hook'}
\label{sec:org8d75289}

We will later do some ``interesting'' things with this function, so we
add a hook.  For example, one use for this hook is to maintain a
history of articles that have been displayed; see Section
\ref{sec:org3e3ff6a}.


\begin{verbatim}
(defvar display-article-hook nil)
\end{verbatim}

\subsubsection{On `raw-scholia-selector'}
\label{sec:orgb456e09}


This function is here both to select raw scholia for display when
`display-article' runs, and to provide for a choice between different
ways of selecting raw scholia.  It returns a list of scholia.

This function is set up to run within the scope of `display-article' 
(Note \ref{sec:org3731def}).

We select slightly different scholia when the article that is being
displayed is a label; in particular, we don't want to display scholia
that indicate the current article as a `parent', since these scholia
will already be listed in the label's \inp{text} itself.

If we're trying to display scholia contextually, then this function
should probably be doctored with some, to make it so that the initial
set of scholia that are displayed are contextually appropriate, i.e.,
are just those associated with the on-screen portion of the buffer
that is being displayed.


\begin{verbatim}
(defun raw-scholia-selector (&optional what-is-displayed)
  (cond ((eq what-is-displayed 'label)
         (remove-if                
          (lambda (scholium)
            (member-if (lambda (link)
                         (member 'parent (cdr link)))
                       (scholium-about scholium)))
          (mapcar (lambda (backlink)
                    (get-article (car backlink)))
                  (get-backlinks name-of-current-article))))
        (t (mapcar (lambda (backlink)
                     (get-article (car backlink)))
                   (get-backlinks name-of-current-article)))))

;; (eq display-style 'contextual)
;;          (save-excursion (set-buffer (get-buffer-create "*scratch*"))
;;                          (erase-buffer)
;;                          (insert window-displayed-substring))
;;          nil
\end{verbatim}

\subsubsection{On `display-article'}
\label{sec:org3731def}
Display article found via \inp{path} (which can just be the name of an
article in the main article tabel), if said article exists.  If the
article lives in a buffer, that buffer will be where the article is
displayed; otherwise the article is displayed in the ``Main Article
Display'' buffer.  Note that this function can also be used to display
labels (it calls `display-label'; but see Note
, since some other approach might be
valuable sometimes).

I don't want to have all of the children appear as scholia when a
label is browsed, at least not by default; but it is kind of neat to
know that they can be made to appear; if we don't do the `remove-if'
then the scholia display will be the OTF-assembled compilation
mentioned in Note .

It makes more sense to always run `display-article-hook' after the
`cond', and to put things that are conditional upon being in this
specific branch into `scholia-display-post-update-hook' or, barring
that, some additional branch-specific hook.  This of course means that
the parent will be added to the history list if that is where we
browse from; this is intended.

If it turns out to be needed here, we could reuse the trick of running
a hook and then making a test before the `cond', which we're familiar
with from e.g. `sch-plain-text' (Note \ref{sec:org66e74d8}).

It would be good to make the buffer disposition (left? right?)
is consistent when we use this function to display labels;  I
think we have it sorted out properly for the display of 
``normal'' articles.

We may want to treat namespaces and labels together in the same
`cond' branch (currently namespaces aren't handled specially by
this function). 

Since we are now reading in paths, these paths have to be parsed.
This is the job of `generalized-get-article' (see Note
\ref{sec:org1e60373}).


\begin{verbatim}
(defun display-article (path)
  (interactive (list (read-article-path)))
  (let* ((article (generalized-get-article path))
         (name (scholium-name article)))
    (if (not article)
        (error "No article by that name found")
      (setq name-of-current-article name)
      (cond
       ((typedata-includes (scholium-type article) 'label)
        (display-label name)
        (setq rendering-target-buffer "*Generic List*")
        (switch-to-buffer (get-buffer "*Generic List*"))
        (setq buffer-read-only nil)
        (switch-to-buffer (get-buffer-create "Scholia Display") t)
        (erase-buffer)
        (let ((raw-scholia (raw-scholia-selector 'label)))
          (mark-things-up))
        (scholia-display-extras)
        (switch-to-buffer (get-buffer "*Generic List*"))
        (setq buffer-read-only t)
        (pop-to-buffer "Scholia Display")
        (other-window -1))
       (t
        (if (article-buffered article)
            (setq rendering-target-buffer (scholium-text article))
          (setq rendering-target-buffer nil))
        (run-hooks 'scholia-display-pre-update-hook)
        (scholia-overwhelm-display (sch-plain-text article))
        (let ((raw-scholia (raw-scholia-selector)))
          (mark-things-up))
        (scholia-display-extras)
        (pop-to-buffer (get-rendering-target-buffer))
        (run-hooks 'scholia-display-post-update-hook)))
      (run-hooks 'display-article-hook))))
\end{verbatim}

\subsubsection{On `redisplay-article'}
\label{sec:org723d53c}

This accomplishes a simple task.

It would be nice if we could get the point restored to
its original position after this thing runs.

Also, it would be good to have the function run automatically
after scholia have been added about the document.


\begin{verbatim}
(defun redisplay-article ()
  (interactive)
  (display-article name-of-current-article))
\end{verbatim}

\subsubsection{Displaying scholia about a given buffer}

\subsubsection{On `display-scholia-about-current-buffer'}
\label{sec:org4d4a72e}
This function is similar to `display-article' (\ref{sec:org3731def}),
but it works directly on the buffer level.  (Stylistically this
function should probably just be a thin wrapper, but we're running
with it for now.)

This function should perhaps check to see whether the
current buffer has been \emph{edited} since the last time
this function (or similar, through other means) was executed.
If the buffer has been edited, the user should probably
be prompted, and asked whether to reparse (Section \ref{sec:orge1a02e4})
before redisplaying.


\begin{verbatim}
(defun display-scholia-about-current-buffer ()
  (interactive)
  (let ((article (get-article (buffer-name (current-buffer)))))
    (if article
        (progn
          (setq rendering-target-buffer (current-buffer))
          (run-hooks 'scholia-display-pre-update-hook)
          (scholia-overwhelm-display (sch-plain-text article))
          (let ((raw-scholia
                 (mapcar (lambda (backlink)
                          (get-article (car backlink)))
                         (get-backlinks name-of-current-article))))
            (mark-things-up))
          (scholia-display-extras)
          (pop-to-buffer (get-rendering-target-buffer))
          (run-hooks 'scholia-display-post-update-hook)
          ;; weird!
          (run-hooks 'display-article-hook))
      (call-if-user-adds-current-buffer-to-article-list
       'display-scholia-about-current-buffer))))
\end{verbatim}

\subsubsection{On `display-label-hook'}
\label{sec:org3363b57}

This provides a way to customize the behavior of
`display-label'.


\begin{verbatim}
(defvar display-label-hook nil)
\end{verbatim}

\subsubsection{On `currently-displayed-label'}
\label{sec:orgf0bb872}

This gives us a handle on the most recently displayed
label.  This facilitates only the simplest 
improvement to reverting behavior.


\begin{verbatim}
(defvar currently-displayed-label nil)
\end{verbatim}

\subsubsection{On `display-label'}
\label{sec:org1356c39}
The function `display-label' uses the catalog browsing feature of
Section \ref{sec:org32b4b82}.  If we want to do other interesting rendering
things with articles that have special types, we can follow the usage
of `display-label' in `display-article'.  It might be good for this
function to run its own hook, e.g., for maintaining a special history
(see ).


\begin{verbatim}
(defun display-label (name)
  (interactive 
   (list
    (let* ((completion-ignore-case t)
           (label-names
            (scholium-text (get-article 'label)))
           (label-strings (mapcar (lambda (name) 
                                    (format "%s" name))
                                  label-names))
           (string-found (completing-read
                          "Label: "
                          label-strings))
           (place (- (length label-strings)
                     (length (member string-found label-strings)))))
      (nth place label-names))))
  (article-menu-listing (label-to-propertized-list name))
  (run-hooks 'display-label-hook))

(add-hook 'display-label-hook (lambda ()
                                (setq currently-displayed-label name)))

(defalias 'list-label 'display-label)
\end{verbatim}

\subsubsection{On `display-intersection-of-labels'}
\label{sec:orgf4c2536}
For displaying everything bearing every one of the
input \inp{labels}.


\begin{verbatim}
(defun display-intersection-of-labels (&rest labels)
  (let ((intersection (label-to-list (car labels)))
        (ctn (cdr labels)))
    (while ctn
      (setq intersection (intersection intersection
                                       (label-to-list (car ctn))
                                       :test 'equal))
      (setq ctn (cdr ctn)))
    (article-menu-listing (turn-list-into-propertized-list
                           intersection))))
\end{verbatim}

\subsubsection{On `display-difference-of-labels'}
\label{sec:org1822408}
For purposes of simplicity, this is set up to work with two labels
only, for the time being.


\begin{verbatim}
(defun display-difference-of-labels (label-A label-B)
  (article-menu-listing (turn-list-into-propertized-list
                         (set-difference (label-to-list label-A)
                                         (label-to-list label-B)))))
\end{verbatim}

\subsubsection{On `find-marked-regions'}
\label{sec:orgc3c5a14}

This function is used in the subsequent section (Section

to locate the parts of the buffer
that have scholia written about them.  Note that
this scheme might have been outmoded by stuff in Section
\ref{sec:orge1a02e4}.


\begin{verbatim}
(defun find-marked-regions ()
  (let (names-and-positions
        (next-change-point (point-min)))
    (while next-change-point
      (let ((next-region (find-next-marked-region)))
        (when next-region
          (setq names-and-positions
                (cons next-region
                      names-and-positions)))))
    names-and-positions))
\end{verbatim}

\subsubsection{On `find-next-marked-region'}
\label{sec:org728b094}

This function is within the scope of `find-marked-regions'.  Should be
able to find all the regions associated with any scholium.  Right now,
this function is working in a simplified universe in which scholia and
regions are mapped to each other in 1-1 way!


\begin{verbatim}
(defun find-next-marked-region ()
  (let* ((beg (next-single-property-change next-change-point
                                           'scholia))
         (end (when beg
                (next-single-property-change beg
                                             'scholia))))
    (setq next-change-point end)
    (when end
      (list
       (get-text-property beg 'scholia)
       (list (cons beg end))))))
\end{verbatim}

\subsubsection{Turning overlays off and on} \label{overlays-on-off}

\subsubsection{Turning overlays off}
\label{sec:org44ec97f}

It is easy enough to turn overlays off; this is accomplished for the
main article buffer and the Scholia Display buffer by
`sch-turn-main-article-overlays-off' and
`sch-turn-scholia-overlays-off', respectively.


\begin{verbatim}
(defun sch-turn-main-article-overlays-off ()
  (interactive)
  (mapcar #'delete-overlay main-article-overlays)
  (setq main-article-overlays nil))

(defun sch-turn-scholia-overlays-off ()
  (interactive)
  (mapcar #'delete-overlay scholia-overlays)
  (setq scholia-overlays nil))
\end{verbatim}

\subsubsection{Turning overlays on}
\label{sec:org4a64904}

Turning overlays on is a bit trickier.  In order to be able to turn
scholia on, we need to be able to find all the regions that have
scholia attached to them.  This is accomplished (for the main article
buffer only, I think) by `find-marked-regions'.


\begin{verbatim}
(defun sch-turn-main-article-overlays-on ()
  (interactive)
  ;; to save from potential overlap weirdness
  (sch-turn-main-article-overlays-off)
  (save-excursion
    (let ((names-and-positions (find-marked-regions)))
        (dolist (info names-and-positions)
    (let* ((name (car info))
           (marked-regions (cadr info))
           (scholium (get-article name))
           (beg (point)))
      (save-excursion
        (set-buffer-to-rendering-target-buffer)
        (dolist (reg marked-regions)
          ;; add "transient" overlay
          (when use-crazy-font-lock
            (setq main-article-overlays
                  (cons
                   (make-overlay (car reg)
                                 (cdr reg)
                                 (get-rendering-target-buffer)
                                 t)
                   main-article-overlays))
            ;; using `scholium-face' here is a bit weird
            (overlay-put (car main-article-overlays)
                         'face (scholium-face))))))))))

(defun sch-turn-scholia-overlays-on ()
  (interactive)
  )
\end{verbatim}
\subsection{Scholia browsing}
\label{sec:orge1689a1}
\subsubsection{On `move-to-next-region-with-scholium' and `move-to-previous-region-with-scholium'}
\label{sec:orgec49b48}
This moves the point to the beginning of the next region that has a
scholium about it (if there is one).

(I'm noticing a bug when the function is used interactively with the
binding selected in Section \ref{sec:orgfd4dba1} and the cursor is
positioned on a right paren; calling the function with M-x in this
case doesn't result in the same problem.)

Note these two functions are not quite symmetrical, because we
want the cursor to end up at the beginning of the marked
region.  (I think there will be a problem if we try to go to the
beginning of a scholium that is attached at the beginning of
the article, but that isn't such a big deal.)


\begin{verbatim}
(defun move-to-next-region-with-scholium ()
  (interactive)
  (let ((change (next-overlay-change (point))))
    (if (overlays-at change)
        (progn (goto-char change)
               (list change (next-overlay-change change)))
      (if (overlays-at (next-overlay-change change))
          (progn (goto-char (next-overlay-change change))
                 (list (next-overlay-change change)
                       (next-overlay-change (next-overlay-change 
                                             change))))
        (message "No subsequent regions with scholia about them.")
        nil))))

(defun move-to-previous-region-with-scholium ()
  (interactive)
  (let ((change (previous-overlay-change (point))))
    (if (overlays-at change)
        (progn (goto-char change)
               (list change (previous-overlay-change change)))
      (if (overlays-at (previous-overlay-change change))
          (progn (goto-char (previous-overlay-change change))
                 (list (previous-overlay-change change)
                       (previous-overlay-change (previous-overlay-change 
                                             change))))
        (message "No previous regions with scholia about them.")
        nil))))

(defun scroll-article-display-to-next-region-for-current-scholium ()
  (interactive)
  (save-excursion
    (set-buffer buffer-associated-with-current-article)
    (let (found
          (curpoint (point)))
      (while (and (not found)
                  (not (eobp))
                  (move-to-next-region-with-scholium))
        (mapc (lambda (overlay)
                (when (equal (overlay-get overlay 'scholia)
                             (name-of-current-scholium))
                  (setq found t)))
              (overlays-at (point)))
        (if found
            (recenter)))
      (when (not found)
        (goto-char curpoint)
        (message "Scholium not about further regions in buffer.")))))

(defun scroll-article-display-to-previous-region-for-current-scholium ()
  (interactive)
  (save-excursion
    (set-buffer buffer-associated-with-current-article)
    (let (found
          (curpoint (point)))
      (while (and (not found)
                  (not (bobp))
                  (move-to-previous-region-with-scholium))
        (mapc (lambda (overlay)
                (when (equal (overlay-get overlay 'scholia)
                             (name-of-current-scholium))
                  (setq found t)))
              (overlays-at (point)))
        (if found
            (recenter)))
      (when (not found)
        (goto-char curpoint)
        (message "Scholium not about previous regions in buffer.")))))
\end{verbatim}

\subsubsection{On `move-to-first-region-for-scholium'}
\label{sec:orge49311a}
Move you to the beginning of the region marked up by the scholium
named \inp{name}.  Should this be made interactive?)  At present, it
is only called by `move-to-first-region-for-current-scholium'.


\begin{verbatim}
(defun move-to-first-region-for-scholium (name)
  (pop-to-buffer (get-buffer rendering-target-buffer))
  (let ((beg (point-max))
        (about (scholium-about (get-article name))))
    (dolist (link about)
      ;; this should be revised in light of the
      ;; fact that a link can be multiply typed
      (when (and (typedata-includes-passage (link-type elt))
                 (equal (linked-to-article link)
                        name-of-current-article)
                 (< (link-beginning link) beg))
        (setq beg (link-beginning link))))
    (unless (equal beg (point-max))
      (goto-char beg))))
\end{verbatim}

\subsubsection{On `move-to-first-region-for-current-scholium'}
\label{sec:org30a3a8a}

This uses the function `move-to-first-region-for-scholium' from
section \ref{sec:orge1689a1}; the thought behind including the
function here is that it establishes a relationship between
the Scholia Display buffer and the main article buffer (however
it could probably go in section \ref{sec:orge1689a1} equally well).

This should probably be complemented by a function
`move-to-last-region-for-current-scholium'.

Also, it should probably have some intelligent message
(not to say ``error message'') if the scholium applies to
the article as a whole.

(Gives some error, complaining about `elt' being void.
Can this run in the Scholia Display buffer as well as the
main article buffer?)


\begin{verbatim}
(defun move-to-first-region-for-current-scholium ()
  (interactive)
  (let ((current (name-of-current-scholium)))
    (move-to-first-region-for-scholium current)))
\end{verbatim}
\subsection{Local browsing}
\label{sec:org46df2c9}
\subsubsection{On `read-scholia-property-at-point'}
\label{sec:org8d0c0f2}

Suppose we simply want to make the current scholium into the new
current article.  That's what the next function is for.


\begin{verbatim}
(defun read-scholia-property-at-point ()
  (get-text-property (point) 'scholia))
\end{verbatim}

\subsubsection{On `scholia-named-at-point'}
\label{sec:orgf4895c2}

I think that this should strip out the ``mask'' tags
from the link-ids, but leave the name parts.  Since it
is only used by interactive functions, this seems fine,
and appropriate.


\begin{verbatim}
(defun scholia-named-at-point ()
  (mapcar (lambda (id)
            (if (eq (car id) 'mask)
                (car (second id))
              (car id)))
          (read-scholia-property-at-point)))
\end{verbatim}

\subsubsection{On `follow-scholium'}
\label{sec:org05e8766}
This causes the current scholium to become the current article.

Eventually we'll want to be able to run this command with a
mouse-click.


\begin{verbatim}
(defun follow-scholium ()
  (interactive)
  (let ((current (name-of-current-scholium)))
    (when current
      (display-article current))))
\end{verbatim}

\subsubsection{On `follow-reference'}
\label{sec:org35c2083}
This reads the `scholia' property at point and either follows the
reference at point (if there is only one) or allows the user to choose
between references (if there are several).

We might want to provide an additional function for following links
\emph{in general}; basically the strategy for that is, just don't do
the `remove-if' filtering.


\begin{verbatim}
(defun follow-reference ()
  (interactive)
  (let ((references
         (remove-if (lambda (name)
                      (not (typedata-includes
                            (scholium-type (get-article name))
                            'reference)))
                    (scholia-named-at-point))))
    (cond
     ((equal (length references) 1)
      (let* ((ref (get-article (car references)))
             (to-article (reference-to-article ref)))
        (if (equal to-article name-of-current-article)
            (display-article (reference-from-article ref))
          (display-article to-article)))
      ;; maybe `display-article' should be returning
      ;; some non-`nil' value so that we don't have to do this.
      t)
     (references
      ;; this sort of disambiguation is really only needed if the
      ;; references have different targets.  Two distinct references
      ;; to the same thing overlaying each other could be treated as
      ;; one for simple following purposes.
      (list-articles references))
     (t
      (message "No reference at point.")
      nil))))

(defun follow-reference-or-scholium ()
  (interactive)
  (unless (follow-reference)
    (follow-scholium)))

(defun display-an-article-that-current-article-is-about ()
  (interactive)
  (let ((abouts (scholium-about
                 (get-article name-of-current-article))))
    (cond
     ((equal (length abouts) 1)
      (display-article (car abouts)))
     (abouts
      (list-articles abouts))
     (t
      (message "Article isn't about any other articles.")))))
\end{verbatim}

\subsubsection{On `current-scholium-is-about'}
\label{sec:orgfb5e28c}

This function is similar to the previous one, but it applies to
scholia.  Since one presumably knows that the current scholium is
about the current article, this is most useful when a scholium is
about several different articles, as it allows the user to move
``down'' to any of them.


\begin{verbatim}
(defun current-scholium-is-about ()
  (scholium-about (get-article (name-of-current-scholium))))

(defun display-an-article-that-current-scholium-is-about ()
  (interactive)
  (let ((abouts (current-scholium-is-about)))
    (cond
     ((equal (length abouts) 1)
      (display-article (car abouts))
      (message "Note: scholium is only about current article."))
     (abouts
      (list-articles abouts))
     (t
      (message "Article isn't about any other articles.")))))
\end{verbatim}
\subsection{Catalog browsing}
\label{sec:org32b4b82}
\subsubsection{On `make-generic-menu-mode'}
\label{sec:orgbb07b49}

This takes the name of the menu (as a space-separated string) together
with a list of bindings to be used in that particular menu mode.

This should provide a docstring for the mode it creates.


\begin{verbatim}
(defmacro make-generic-menu-mode
  (mode bindings)
  (let* ((modedash (downcase (replace-regexp-in-string " " "-" mode)))
         (modesymbol (intern (concat modedash "-mode")))
         (mapname (intern (concat modedash "-map"))))
    `(progn
       (defvar ,mapname)
       (setq ,mapname (make-keymap))
       (suppress-keymap ,mapname t)
       (dolist (binding ,bindings)
         (define-key ,mapname (car binding) (cdr binding)))
       (defun ,modesymbol ()
         (kill-all-local-variables)
         (use-local-map ,mapname)
         (setq major-mode (quote ,modesymbol))
         (setq mode-name ,mode)
         (setq truncate-lines t)
         (setq buffer-read-only t)))))
\end{verbatim}

\subsubsection{On `generic-menu-noselect'}
\label{sec:org390b462}
The basic idea of this is that we have some \inp{objects} and some
functions to map across the objects to extract the information from
the objects (\inp{accessors}).  The functions must be set up to
produce strings as their output.  The functions correspond to columns
in the display; individual objects correspond to rows.  This is the
same idea no matter what the source of the objects is.  (In
particular, it might be a good idea for a later version of this
function to accept either a hash table or a list as the source of the
objects; see Note .)  Note that columns
of the display are assumed to be as wide as their widest item!


\begin{verbatim}
(defun generic-menu-noselect (objects accessors)
  (let (cols)
    (dolist (get-this accessors)
      ;; if we built this front-to-back rather than back-to-front,
      ;; that would be better
      (setq cols (cons
                  (cons (car get-this)
                        (mapcar (cdr get-this) objects))
                  cols)))
    ;; find the width of the columns.
    (let ((lens (mapcar (lambda (col)
                          (let ((len 0))
                            (dolist (str col)
                              (let ((candidate (length str)))
                                (when (> candidate len)
                                  (setq len candidate))))
                            len))
                        cols)))
      (with-current-buffer (get-buffer-create "*Generic List*")
        (setq buffer-read-only nil)
        (erase-buffer)
        (while cols
          (goto-char (point-min))
          (goto-char (line-end-position))
          (dolist (str (car cols))
            (insert str " ")
            ;; fill with spaces to make up for lost space
            (insert-char 32 (- (car lens) (length str)))
            (unless (equal (forward-line) 0)
              (newline))
            (goto-char (line-end-position)))
          (setq cols (cdr cols))
          (setq lens (cdr lens)))
        (goto-char (point-min))
        (current-buffer)))))
\end{verbatim}

\subsubsection{Improved sorting of article listing}
\label{sec:org0b31ca4}

Sorting could be done using autocompletion on the name of the column
to sort on, too, which would be kind of nice.  Or we could make a
command to sort on the current column, or reorder columns according to
the values on the current line or just about anything you might like.

But I don't think sorting is going to work at all until we have a
consistent way of identifying the fields to sort; in the case of
strings with spaces in them, `sort-fields' won't work.  Since we
compute the width of each of the columns in `generic-menu-noselect',
if we were to store this info (perhaps as a text property attached to
each column heading), we could adroitly divide the text up to find the
strings we're trying to sort.  See Note .


\begin{verbatim}
(defun Generic-menu-sort (col)
  (interactive "P")
  (save-excursion
    (sort-fields (or col 1) (progn (goto-line 2)
                                   (point))
                 (point-max))))
\end{verbatim}

\subsubsection{On `standard-article-menu-accessors'}
\label{sec:org6aba0bf}
Note that it would be easy to provide more metadata -- just revise
this variable with additional fields as desired.  See Note
\ref{sec:org390b462} for a description of how accessors work.


\begin{verbatim}
(defvar standard-article-menu-accessors
  '(("Name" . identity)
    ("C"    . (lambda (elt) " "))))
\end{verbatim}

\subsubsection{On `article-menu-listing-hook'}
\label{sec:org63c1d41}

This is here to
customize the behavior of the article menu listing.  Currently it
is used to offset the activities invoked by
`currently-displayed-label-hook'; whereas we want
`currently-displayed-label' to be defined when the listing is
used to display a label, we'd rather it be `nil' when something
other than a label has been displayed, since anything else could
be misleading.


\begin{verbatim}
(defvar article-menu-listing-hook nil)
\end{verbatim}

\subsubsection{On `article-menu-listing'}
\label{sec:org4e6af29}

The optional input \inp{subset} is a list of article names to pump
into the generic menu; it defaults to the list of ``plain'' articles
as recorded on the corresponding label.  The optional input
\inp{accessors} specifies the functions to use to extract information
from the articles named by \inp{subset}; it is in the format of, and
defaults to, `standard-article-menu-accessors'.  (Note that function
plays a similar role to `Buffer-menu-revert' from buff-menu.el.)


\begin{verbatim}
(defun article-menu-listing (&optional subset accessors)
  (interactive)
  (pop-to-buffer
   (generic-menu-noselect
    ;; maybe this should always handle propertizing itself?
    (or subset
        (label-to-propertized-list 'plain))
    (or accessors
        standard-article-menu-accessors)))
  ;; note, this runs every time, even if the current article
  ;; isn't on the list.
  (article-menu-point-out-current-article)
  (article-menu-mode)
  (run-hooks 'article-menu-listing-hook))

(add-hook 'article-menu-listing-hook (lambda ()
                                       (setq currently-displayed-label
                                             nil)))
\end{verbatim}

\subsubsection{On `turn-article-table-into-list'}
\label{sec:orge5f89f8}

I hate to actually use this function the way it is used in
`display-article'\ldots{} probably we should just select from the
\emph{plain} articles there, and write a separate function to display
other articles.  In short, there really shouldn't be any need to use
this function, except maybe for debugging purposes or \emph{explicit}
listing of all the articles (whenever that really needs to be done).


\begin{verbatim}
(defun turn-article-table-into-list ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               ;; It might be nice to have %S here, but
               ;; I don't know if it would be _useful_
               (nconc names (list (format "%s" name))))
             article-table)
    (cdr names)))
\end{verbatim}

\subsubsection{On `turn-article-table-into-names'}
\label{sec:orgc96aeda}

This is a variant of `turn-article-table-into-list'
that produces the actual names of the articles;
probably it should supercede the other, since we could
get the print names by mapping over the output of this
function, obviously.


\begin{verbatim}
(defun turn-article-table-into-names ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               (nconc names (list name)))
             article-table)
    (cdr names)))
\end{verbatim}

\subsubsection{On `turn-article-table-into-propertized-list'}
\label{sec:orgdf98f9a}

This combines the best of both `turn-article-table-into-list' and
`turn-article-table-into-names'.  Compare
`label-to-propertized-list'.


\begin{verbatim}
(defun turn-article-table-into-propertized-list ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               (nconc names
                      (list 
                       (propertize (format "%s" name) 'name name))))
             article-table)
    (cdr names)))
\end{verbatim}

\subsubsection{On `turn-list-into-propertized-list'}
\label{sec:org115ef5e}
Turns an arbitrary list into a propertized list.


\begin{verbatim}
(defun turn-list-into-propertized-list (lis)
  (let (names)
    (mapc (lambda (name)
            (setq names (cons
                         (propertize (format "%s" name) 'name name)
                         names)))
          lis)
    names))
\end{verbatim}

\subsubsection{Special-purpose listings}
\label{sec:org899020c}
Here are a few functions to list special collections of articles.
The function `article-menu-list-labels' is perhaps particularly
noteworthy; browsing labels seems to be a powerful way of organizing
and retrieving information, see Note .


\begin{verbatim}
(defun article-menu-list-plain-articles ()
  (interactive)
  (article-menu-listing))

(defun article-menu-list-all-articles ()
  (interactive)
  (article-menu-listing (turn-article-table-into-propertized-list)))

(defun article-menu-list-metadata-articles ()
  (interactive)
  (article-menu-listing (label-to-propertized-list 'metadata)))

(defun article-menu-list-labels ()
  (interactive)
  (article-menu-listing (label-to-propertized-list 'label)))

(defun list-articles (lis)
  (interactive)
  (article-menu-listing (turn-list-into-propertized-list lis)))
\end{verbatim}

\subsubsection{On `article-menu-display-article'}
\label{sec:org7c6f167}

The point is to grab the name of the article on the currrent line of
the listing and display it.  This needs to be checked a bit in the
multicolumn case (which itself needs to be explored).


\begin{verbatim}
(defun article-menu-display-article ()
  (interactive)
  (when (> (line-number-at-pos) 1)
    (save-excursion
      (goto-char (line-beginning-position))
      (search-forward-regexp "[. >] .")
      (setq name-of-current-article
            (get-text-property (point) 'name))
      (article-menu-point-out-current-article)
      (display-article name-of-current-article))))
\end{verbatim}

\subsubsection{On `article-menu-mark-article'}
\label{sec:orgeb1aa68}

Use this to mark the article mentioned on this line.


\begin{verbatim}
(defun article-menu-mark-article ()
  (interactive)
  (setq buffer-read-only nil)
  (when (> (line-number-at-pos) 1)
    (goto-char (line-beginning-position))
    (delete-char 1)
    (insert ">")
    (when (< (line-number-at-pos)
             (progn (save-excursion (goto-char (point-max))
                                    (line-number-at-pos))))
      (forward-line 1)))
  (setq buffer-read-only t))
\end{verbatim}

\subsubsection{On `article-menu-unmark-article'}
\label{sec:org128628a}

Use this to remove any mark on the article mentioned on this line.


\begin{verbatim}
(defun article-menu-unmark-article ()
  (interactive)
  (setq buffer-read-only nil)
  (when (and (> (line-number-at-pos) 1)
             (not (save-excursion (goto-char (line-beginning-position))
                                  (looking-at "\\."))))
    (goto-char (line-beginning-position))
    (delete-char 1)
    (insert " ")
    (when (< (line-number-at-pos)
             (progn (save-excursion (goto-char (point-max))
                                    (line-number-at-pos))))
      (forward-line 1)))
  (setq buffer-read-only t))

(defun article-menu-unmark-all-articles ()
  (interactive)
  (setq buffer-read-only nil)
  (save-excursion (goto-line 2)
                  (goto-char (line-beginning-position))
                  (while (re-search-forward "^>" nil t)
                    (replace-match " ")))
  (setq buffer-read-only t))
\end{verbatim}

\subsubsection{On `article-menu-point-out-current-article'}
\label{sec:org6647be4}

This is a non-interactive function that puts a dot in front
of the current article when the article listing is generated.


\begin{verbatim}
(defun article-menu-point-out-current-article ()
  (goto-char (point-min))
  (setq buffer-read-only nil)
  (save-excursion (when (search-forward-regexp "^\\." nil t)
                    (replace-match " ")))
  (when (and
         name-of-current-article
         (search-forward-regexp
          ;; maybe this `(format "%s" name-of-current-article)'
          ;; stuff should be stored as some kind of function,
          ;; like `print-name-of-article' or something like that
          (concat "^[. ] " (regexp-quote
                            (format "%s" name-of-current-article)))
          nil t))
    (replace-match (concat ". " (substring (match-string 0) 2))))
  (goto-char (line-beginning-position))
  (setq buffer-read-only t))
\end{verbatim}

\subsubsection{Features of the article menu}
\label{sec:org8f40ac7}
The only ``actionable'' feature of the current listing is display.
See also Note .


\begin{verbatim}
(make-generic-menu-mode "Article Menu"
                        '(("g" . article-menu-listing)
                          ("m" . article-menu-mark-article)
                          ("u" . article-menu-unmark-article)
                          ("U" . article-menu-unmark-all-articles)
                          ("q" . quit-window)
                          ("\C-m" . article-menu-display-article)))
\end{verbatim}

\subsubsection{On `article-menu-list-articles-matching-regexp'}
\label{sec:orgc893db9}
This makes a listing showing all of the articles that match
\inp{regexp}.

\emph\{(It would be nice if we could leave out meta, reference,
code, and label types of articles in the default version of
this.)\}


\begin{verbatim}
(defun article-menu-list-articles-matching-regexp (regexp)
  (interactive "MRegexp: ")
  (let ((matches (mapcar
                  (lambda (name)
                    (propertize (format "%s" name) 'name name))
                  (remove-if
                   (lambda (elt)
                     (not
                      (with-temp-buffer
                        ;; rough, not bothering with
                        ;; `sch-plain-text'
                        (let ((article (get-article elt)))
                          (insert
                           (format "%s"
                                   (scholium-name (get-article elt)))
                           "\n"
                           (format "%s"
                                   (scholium-text article)))
                          (goto-char (point-min))
                          (search-forward-regexp regexp
                                                 nil t)))))
                   (turn-article-table-into-names)))))
    (if matches
        (article-menu-listing matches)
      (message "No hits."))))
\end{verbatim}

\subsubsection{On `article-menu-list-articles-matching-predicate'}
\label{sec:org1be4115}
This is a way to pick out all of the articles in the library
that match a given predicate.


\begin{verbatim}
(defun article-menu-list-articles-matching-predicate (pred)
  (let ((matches (mapcar
                  (lambda (name)
                    (propertize (format "%s" name) 'name name))
                  (remove-if (lambda (elt) (not (funcall pred elt)))
                             (turn-article-table-into-names)))))
    (if matches
        (article-menu-listing matches)
      (message "No hits."))))
\end{verbatim}

\subsubsection{On `display-article-listing'}
\label{sec:orgf971806}

This just puts the cursor in the article listing.


\begin{verbatim}
(defun display-article-listing ()
  (interactive)
  (pop-to-buffer "*Generic List*"))
\end{verbatim}
\subsection{Temporal browsing}
\label{sec:org3e3ff6a}
\subsubsection{Thematic histories}
\label{sec:orgefd25e5}
It might be useful to keep a record of several different sorts of
histories, e.g. of editing events or ``catalog pages'' (Note
).  These
alternate histories wouldn't have much to do with the temporal
browser per se.  Emacs does this in some cases (e.g. recording the
input history for various interactive functions separately).

If we're going to do this, probably the code in this section
should be written in a somewhat more generic way.


\begin{verbatim}
(defvar sb-history nil)

(add-hook 'display-article-hook
          (lambda ()
            (sb-add-article-to-history name-of-current-article)))
\end{verbatim}

\subsubsection{Complexities could be handled by `display-article'}
\label{sec:org88978de}

Of course, additional sorts of access instructions (like those alluded
to in Note ) could be handled by
`display-article'.  \emph{This section} does not depend on article
names being stored as strings.


\begin{verbatim}
(defun sb-add-article-to-history (article)
  (setq sb-history (nconc sb-history (list article))))

(defun sb-back ()
  (interactive)
  (let ((current (car (last sb-history)))
        (n 0)
        found)
    (while (not found)
      (if (equal (nth n sb-history) current)
          (progn (setq found t)
                 (if (> n 0)
                     (display-article (nth (1- n) sb-history))
                   (message "Already at beginning of history.")))
        (setq n (1+ n))))))

(defun sb-forward ()
  (interactive)
  (let* ((current (car (last sb-history)))
         (max (1- (length sb-history)))
         (n (1- max))
         found)
    (while (not found)
      (if (equal (nth n sb-history) current)
          (progn (setq found t)
                 (if (< n (1- max))
                     (display-article (nth (1+ n) sb-history))
                   (message "Already at end of future")))
        (setq n (1- n))))))
\end{verbatim}

\subsubsection{On `sb-previous'}
\label{sec:org2278440}

This gives the most recently browsed article besides the current
one.


\begin{verbatim}
(defun sb-previous ()
  (car (last sb-history 2)))
\end{verbatim}
\subsection{Linear browsing}
\label{sec:org953fc84}
\subsubsection{On `add-visible-back-temporal-link'}
\label{sec:orgcf271aa}
This makes a link to the previous-browsed page appear in the Scholia
Display.  It runs within the scope of `scholia-display-extras' (Note
\ref{sec:orgbce72d4}).

It like we should potentially be able to change the strategy here, so
as to add more information to the text properties and not actually
create any corresponding article.  I think this would require some
adjustments to the way text properties are handled.


\begin{verbatim}
(defun add-visible-back-temporal-link ()
  ;; this should be marked up to become a fake link (one that isn't
  ;; displayed in the main buffer)
  (when (sb-previous)
    (insert "\n\n"
            "Back (temporal): ")
    (let ((beg (point)))
      (insert (propertize 
               (format "%s" (sb-previous)) 'face 'sch-reference-face))
      (scholium 'reference-to-previous-article
                nil
                `((,name-of-current-article
                    (passage 
                     ,beg
                     ,(point)))
                  (,(sb-previous)))
                '(reference fake))
      (add-to-scholia-property-within-region
       beg
       (point)
       '(reference-to-previous-article 1 1)))))
\end{verbatim}

\subsubsection{On `add-visible-parent-and-sibling-links'}
\label{sec:orgd4b1e0a}
This adds links to the parent and nearest siblings in the Scholia
Display buffer.  It runs within the scope of `scholia-display-extras'
(Note \ref{sec:orgbce72d4}).


\begin{verbatim}
(defun add-visible-parent-and-sibling-links ()
  ;; identify the link to the parent, if it exists.
  ;; (this assumes that there is only one parent)
  (let ((link-to-parent (car (member-if (lambda (link)
                                          (member 'parent (cdr link)))
                                         (scholium-about article)))))
    (when link-to-parent
      (let* ((parent (get-article (first link-to-parent)))
             (parent-data
              (scholium-text parent))
             (this-name-headed (member name-of-current-article
                                       parent-data))
             (next (cadr this-name-headed))
             (prev (car (last (butlast parent-data
                                       (length this-name-headed))))))
        (when parent
          (insert "\n\n"
                  "Parent: ")
          (let ((beg (point)))
            (insert (propertize (format "%s" (scholium-name parent))
                                'face 'sch-reference-face))
            (scholium 'reference-to-parent
                      nil
                      `((,name-of-current-article
                          (passage 
                           ,beg
                           ,(point)))
                        (,(scholium-name parent)))
                      '(reference fake))
            (add-to-scholia-property-within-region
             beg
             (point)
             '(reference-to-parent 1 1))))
        (when prev
          (insert "\n\n"
                  "Back (in parent): ")
          (let ((beg (point)))
            (insert (propertize (format "%s" prev) 'face 'sch-reference-face))
            (scholium 'reference-to-previous-article-in-parent
                      nil
                      `((,name-of-current-article
                          (passage 
                           ,beg
                           ,(point)))
                        (,prev))
                      '(reference fake))
            (add-to-scholia-property-within-region
             beg
             (point)
             '(reference-to-previous-article-in-parent 1 1))))
        (when next
          (insert "\n\n"
                  "Forward (in parent): ")
          (let ((beg (point)))
            (insert (propertize (format "%s" next)
                                'face 
                                'sch-reference-face))
            (scholium 'reference-to-next-article-in-parent
                      nil
                      `((,name-of-current-article
                          (passage 
                           ,beg
                           ,(point)))
                        (,next))
                      '(reference fake))
            (add-to-scholia-property-within-region
             beg
             (point)
             '(reference-to-next-article-in-parent 1 1))))))))

(add-hook 'scholia-display-extras-hook
          'add-visible-back-temporal-link)
(add-hook 'scholia-display-extras-hook
          'add-visible-parent-and-sibling-links)
\end{verbatim}

\subsubsection{On `forward-in-parent'}
\label{sec:orga36636e}
A quick command to get the label identified as this object's parent,
and move to the next mentioned after this one in this label.  (It
would also be possible to follow the next reference in a page, i.e.,
use a page like a label; but this function doesn't do that.)

It would be nice to have this function select the ``next cousin'' (or
other suitable relative) if we are out of siblings.

We'll also want a quick command to hop \emph{to} an article's parent.


\begin{verbatim}
(defun forward-in-parent ()
  (interactive))
\end{verbatim}

\subsubsection{On `backward-in-parent'}
\label{sec:orga50defe}
Like `forward-in-parent' (Note \ref{sec:orga36636e}) but moves
backward instead.


\begin{verbatim}
(defun backward-in-parent ()
  (interactive))
\end{verbatim}

\section{Part VIII — Editing and Maintenance}
\label{sec:org805985b}
\subsection{Initiating edits}
\label{sec:org743a840}
\subsubsection{Inserting text in the middle of a marked up region}
\label{sec:org9ed88c3}
When someone inserts text into the middle of a marked up region, does
the new text take on the markup properties of the surrounding text, or
does it not, or can we make it an option, to possibly be exercised in
different ways in different places?  I assume we will want different
behavior at different times.  (Cf. Note
).  The reference to consider is the
``Sticky Properties'' node from the Elisp manual\footnote\{(info
  ``(elisp)Sticky Properties'')\}.

There they tell us that
\begin{quotation}
By default, a text property is rear-sticky but not front-sticky; thus,
the default is to inherit all the properties of the preceding
character, and nothing from the following character.
\end{quotation}
Furthermore,
\begin{quotation}
If a character's `rear-nonsticky' property is `t', then none of its
properties are rear-sticky.  If the `rear-nonsticky' property is a
list, properties are rear-sticky \emph{unless} their names are in the
list.
\end{quotation}
Thus, we have nothing to worry about in terms of front-stickiness, but
we must maintain an appropriate rear-nonsticky list throughout the
regions in which we want some of the properties to be non-sticky.

Something like this (enhanced, of course) will work:
\begin{verbatim}
(progn (put-text-property (line-beginning-position) (line-end-position)
       'face 'italic)
       (put-text-property (line-beginning-position) (line-end-position)
       'rear-nonsticky '(face)))
\end{verbatim}
\subsection{Finding revised `about' data by parsing text properties}
\label{sec:orge1a02e4}
\subsubsection{On `scholia-property-at-changepoints'}
\label{sec:org971fec8}

This returns a list of pairs; points where
the `scholia' property changes paired with the value of the `scholia'
property at those points.

\begin{figure}
\begin{center}
%% in LaTeX, ascii art is a little bit trickier than usual
{\tt
\begin{tabular}{l}
\ \ \ \ \ \ \ \ -- \\
\ \ ------ \\
\ ------------------  \\
------  \\
1234567890
\end{tabular}}
\end{center}
\caption{Markup simulated with indicator functions \label{Simulation-with-indicator-functions}}
\end{figure}


\begin{verbatim}
(defun scholia-property-at-changepoints ()
  (let ((next-change-point (point-min))
        change-points)
    (while next-change-point
      (setq change-points (cons (list next-change-point
                                      (get-text-property
                                       next-change-point
                                       'scholia)) 
                                change-points))
      (setq next-change-point (next-single-property-change+predicate
                               next-change-point
                               'scholia
                               'equal)))
    (when (not (null (get-text-property
                      (caar change-points)
                      'scholia)))
      (setq change-points (cons (point-max) change-points)))
    (reverse change-points)))
\end{verbatim}

\subsubsection{On `detect-scholia-structure'}
\label{sec:org6c63dbe}
This function says which passages of the current article have been
marked up with which scholia.  Typically, this function will be run
after editing, to recover the modified markup information and
propagate it to attached scholia (see Section \ref{sec:org8da94c7}).

The way the function works is as follows.  At each of the change
points, we find the the annotations that have either just appeared or
just disappeared, by using the `set-difference' function to compare
the value of the `scholia' property at the \emph{upcoming} change
point with the value at the \emph{current} one.  We then sort the
elements of this difference into ``opening'' and ``closing'' sets
based on whether they are present at the \emph{upcoming} change point,
or the \emph{current} one.  In order to ensure that there is an
adequate basis for comparison in all cases, exogenous points at
``\(-\infty\)'' and ``\(\infty\)'' are introduced, with no scholia
attached to them.

Every ``opening'' element corresponds to some as-yet-unseen marked-up
region; when encountering such an item, we add a term to the return
value that looks like ``(VALUE BEG)'' where VALUE and BEG are,
respectively
\begin{itemize}
\item the value of the `scholia' property -- which will be the
 name of a scholium together with a unique link identifier, as
 described in Note [[id:the-scholia-property]];
\item and the point where this link starts to attach to the current
 article.
\end{itemize}
Similarly, every ``closing'' element corresponds to the end of some
already-seen marked-up region.  When encountering such elements, we
modify the corresponding previously added term in the return value to
read ``(VALUE BEG END)'', END here being the point where the link in
question stops attaching to the current document.

Note that since `scholia-property-at-changepoints' gives us the values
in increasing order, new ``opening'' items are encountered and added
to the list in increasing order as well.  This property is important
for later.


\begin{verbatim}
(defun detect-scholia-structure ()
  (let ((begs-and-ends
         (cons '(-infinity nil)
               (append
                (scholia-property-at-changepoints)
                (list '(infinity nil)))))
        marked-regions)
    (while (> (length begs-and-ends) 1)
      (let ((difference (set-difference (second
                                         (first begs-and-ends))
                                        (second
                                         (second begs-and-ends))))
            opening
            closing)
        (when difference
          (dolist (elt difference)
            (if (member elt (second (second begs-and-ends)))
                (setq opening (cons elt opening))
              (setq closing (cons elt closing))))
          (dolist (elt opening)
            (setq marked-regions
                  (add-to-or-start-list
                   marked-regions
                   `(,elt ,(first (second begs-and-ends))))))
          (dolist (elt closing)
            (let ((found (member-if (lambda (pass)
                                      (equal (first pass) elt))
                                    marked-regions)))
              (setcdr (cdr (car found))
                      (list (first (second begs-and-ends)))))))
        (setq begs-and-ends (cdr begs-and-ends))))
    marked-regions))
\end{verbatim}
\subsection{Committing edits}
\label{sec:org8da94c7}
\subsubsection{On `store-link-masks'}
\label{sec:org8c30894}
This function runs within the scope of `commit-edits', after
`adjusted-markup' has been found by parsing (Note \ref{sec:org354cf9f}).
Indeed, so far, this is the only significant default action of
`commit-edits' (cf. Note ).

The function compares the elements of `current-markup' (Note
\ref{sec:org89aa6bd}) to the elements of `adjusted-markup'.  When
changes are present in the markup data, `store-link-masks' adds or
changes masks.

More precisely, for each element of `current-markup', we select
from `adjusted-markup' those elements with the same link-id
(or maybe mask-id).   These are the `matching-regions' corresponding
to that markup element.  Unless there is only one matching region
and this matching region happen to point to extend over exactly
the range specified by the original link, we execute an operation
on masks.

This operation is to swap in a replacement mask, if the markup
element was coming from a mask already, or to create a brand new
mask otherwise.  If we're doing a replacement, we look for the
\emph{one} mask that corresponds to the link-id borne by the
current markup element.  We then substitute \emph{all} of the
matching regions, for whatever was previously stored in this mask.

Otherwise, we just create a new mask with the appropriate link-id,
containing the relevant regions.


\begin{verbatim}
(defun store-link-masks ()
  (dolist (link-ext current-markup)
    (let* ((matching-regions (remove-if
                              (lambda (markup-item)
                                (not (equal (car markup-item)
                                            (car link-ext))))
                              adjusted-markup))
           (num-matching-regions (length matching-regions))
           (name-of-linking-article (if (eq (first
                                             (car link-ext)) 'mask)
                                        (first (second
                                                (first link-ext)))
                                      (first (first link-ext)))))
      (unless (and (eq num-matching-regions 1)
                   (equal (cdr (first matching-regions))
                          (cdr link-ext)))
        (if (eq (caar link-ext) 'mask)
            ;; swap in a different mask
            (let* ((masks
                    (get-metadata-field 'masks
                                        name-of-linking-article))
                   (current-mask-headed
                    (member-if (lambda (item)
                                 (equal (second (car link-ext))
                                        (car item)))
                               masks)))
              (setcdr (car current-mask-headed)
                      (mapcar (lambda (ided-reg) 
                                (cdr ided-reg))
                              matching-regions))
              (put-metadata-field 'masks
                                  masks
                                  name-of-linking-article))
          ;; create a new mask
          (let ((masks (or (get-metadata-field
                            'masks
                            name-of-linking-article)
                           (list 'masks))))
            (put-metadata-field
             'masks
             (setcdr
              masks
              (add-to-or-start-list
               (cdr masks)
               `(,(car link-ext)
                 ,@(mapcar (lambda (ided-reg) (cdr ided-reg))
                           matching-regions))))
             name-of-linking-article)))))))
\end{verbatim}

\subsubsection{On `commit-edits-hook'}
\label{sec:org283317a}
This is the single point of customization for the commit function,
to be used in future sections.  It runs within the scope of
`commit-edits', after `adjusted-markup' has been found
by parsing.  Thus, functions that are added to this hook can
take advantage of this knowledge about the current state of
markup.


\begin{verbatim}
(defvar commit-edits-hook nil)
\end{verbatim}

\subsubsection{On `after-committing-edits-hook'}
\label{sec:org51c0e5a}
This facilitates additional actions after the main committing
routines are finished.


\begin{verbatim}
(defvar after-committing-edits-hook nil)
\end{verbatim}

\subsubsection{On `commit-edits'}
\label{sec:org354cf9f}
Anything run by the `commit-edits-hook' that changes the text of the
article being committed should store the desired value on
`adjusted-text'.  It is going to take a bit of thinking about how to
make several functions (particularly functions having to do with
derivatives) run properly, in serial.  (But I'm pretty sure it can be
done.)

Note that when committing we currently make sure that exactly one
newline is attached to the end of the page when the text is
saved.  This has a beneficial effect on exporting the scholium
system (see \ref{sec:org0226f0d}).

We may at some point want one or more commit functions that will store
more different kinds of edits from more different places.  For
example, we'll want to be able to commit edits that take place in the
Scholia Display buffer.  Similarly for edits to `about' data, and so
forth (see Note ).


\begin{verbatim}
(defun commit-edits ()
  (interactive)
  (let* ((adjusted-markup (copy-tree (detect-scholia-structure)))
         (old-contents (get-article name-of-current-article))
         (adjusted-text (buffer-substring-no-properties (point-min)
                                                        (point-max)))
         (old-text (scholium-text old-contents)))
    (store-link-masks)
    (run-hooks 'commit-edits-hook)
    ;; here is where the criterion for checking that some change has
    ;; actually been made would be inserted
    (when (not (equal adjusted-text old-text))
      (scholium name-of-current-article
                (with-temp-buffer (insert adjusted-text)
                                  (goto-char (point-max))
                                  (insert "\n")
                                  (delete-blank-lines)
                                  (buffer-substring-no-properties
                                   (point-min)
                                   (point-max)))
                ;; of course, for more advanced versions of
                ;; this code, these won't be static
                (scholium-about old-contents)
                (scholium-type old-contents)
                ;; this should be reformatted to store the old
                ;; version!
                (scholium-bookkeeping old-contents)))
    (run-hooks 'after-committing-edits-hook)))
\end{verbatim}

\subsubsection{After committing, redisplay article}
\label{sec:orgfc612ee}

Hopefully this won't cause any problems.  The one concerning point I
can think of might come up when committing fully rendered and
identified compilations (Section \ref{sec:orgf54d38f}), but we
haven't worked out the major details of that yet, so there's no reason
to worry about this one minor one.


\begin{verbatim}
(add-hook 'after-committing-edits-hook 'redisplay-article)
\end{verbatim}
\subsection{Editing en masse}
\label{sec:org429fbb5}
\subsubsection{On `label-marked-articles'}
\label{sec:org9918c51}

Apply the specified \inp{label} to each marked article.
New labels can be applied no problem.


\begin{verbatim}
(defun label-marked-articles (label)
  (interactive (list
                (intern (let ((completion-ignore-case t))
                          (completing-read
                           "Label: "
                           (label-to-list 'label))))))
  (let (article-names)
    (save-excursion
      (goto-line 2)
      (goto-char (line-beginning-position))
      (while (re-search-forward "^> ." nil t)
        (setq article-names
              (append article-names
                      (list
                       (get-text-property (point) 'name))))))
    (dolist (name article-names)
      (label-article name label))))
\end{verbatim}
\subsection{Deletion}
\label{sec:org7132340}
\subsubsection{Set current article to `nil'}
\label{sec:orga0d8488}

If the current article is deleted, then the `name-of-current-article'
variable should probably be set to nil.  (Either that, or something
from the temporal browser should be used to set the variable to the
last-browsed page.)


\begin{verbatim}
(defvar delete-article-hook nil)

(defun delete-article (name)
  (interactive (list (read-article-name)))
  (let ((article (get-article name)))
    (if article
        (progn
          (remhash name article-table)
          (when (equal name name-of-current-article)
            (setq name-of-current-article nil))
          (run-hooks 'delete-article-hook))
      (error "No article by that name found"))))
\end{verbatim}

\subsubsection{On `remove-appearances-in-history'}
\label{sec:org55be1d5}

This function will run inside the scope of `delete-article'.


\begin{verbatim}
(defun remove-appearances-in-history ()
  (setq sb-history (delete name sb-history)))

(add-hook 'delete-article-hook 'remove-appearances-in-history)
\end{verbatim}

\subsubsection{On `delete-scholium-associated-with-current-marked-region'}
\label{sec:orgb00f9cb}

Provides a quick way to delete the scholium attached to region
containing point.  If more than one scholium is so attached,
we bring up a menu to select items for deletion.

This function assumes that the `scholia' property is simply
comprised of a list of the names of attached scholia; I'm
not so sure that this is an accurate assumption (if not,
then we should be able to easily extract such a list from
the actual `scholia' property).

This is just one of several functions that would benefit from
the addition of progressive markup modifications.


\begin{verbatim}
(defun delete-scholium-associated-with-current-marked-region ()
  (interactive)
  (let ((linked-scholia (scholia-named-at-point)))
    (cond
     ((eq (length linked-scholia) 0)
      (message "No scholium attached here."))
     ((eq (length linked-scholia) 1)
      (delete-article (car linked-scholia)))
     (t
      (list-articles linked-scholia)
      (message
       "Inspect articles and select items for deletion with \"d\".")))))
\end{verbatim}
\subsection{Editing labels}
\label{sec:orge11e075}
\subsubsection{On `article-menu-insert-new-article'}
\label{sec:org667ecb6}

This function lets you add new articles to a recently browsed label.

For now, we assume that we really are adding a \emph{new} article
(and not some existing one); and that this new article will
take the quotidian form offered by `make-scholium' (Note 
\ref{sec:orgf246e3e}).  These assumptions may be relaxed later.

The function one of `label-article' and `label-article-insert-before'
to add the label to the new article (Note \ref{sec:orgefd12b7}, Note
\ref{sec:orgbe233f6}).

(When creating this new article, I hope that enough ancillary metadata
, \inp{type} and so on, is added to allow it to be recognized as part
of the relevant hierarchy later.)


\begin{verbatim}
(defun article-menu-insert-new-article ()
  (interactive)
  (if currently-displayed-label
      (let ((new-entry (read-string "New entry: "))
            (old-entry (save-excursion
                         (goto-char (line-beginning-position))
                         (search-forward-regexp "[. >] ." nil t)
                         (setq name-of-current-article
                               (get-text-property (point) 'name)))))
        (setq new-scholium-name new-entry)
        (let ((line (line-number-at-pos)))
          (if old-entry
              (label-article-insert-before
               new-entry old-entry currently-displayed-label)
            (label-article new-entry currently-displayed-label))
          (display-label currently-displayed-label)
          (goto-line line))
        (make-scholium))
    (message "Listing doesn't represent a label.")))

(define-key article-menu-map "i" 'article-menu-insert-new-article)
\end{verbatim}

\section{Part IX — Derivative Composition}
\label{sec:orgf29f015}
\subsection{Introduction to clusions}
\label{sec:org7bc20ff}
\subsubsection{Format of text with derivatives}
\label{sec:org27717b5}
The format of the \inp{text} field for articles with derivatives is as
follows:
\begin{verbatim}
(twd <string | clusion> ...)
\end{verbatim}
Each clusion is a link with the corresponding instruction consed
onto the front of it (cf. Note \ref{sec:org49d5148}).  The three instructions
are `transclude', `identify', and `include'.

For example,
\begin{verbatim}
(twd "This Note can be used as part of an example.\n" 
     (transclude "Format of text with derivatives"))
\end{verbatim}
or,
\begin{verbatim}
(twd "Part of this Note can be used as part of an example.\n" 
     (transclude "Format of text with derivatives" 
                 (passage 1 25)))
\end{verbatim}

There is a small break in transparency here; presumably this won't be
a problem (Note \url{2.2-Design_issues.org}).
\subsection{Transclusion}
\label{sec:orgabef2cd}
\subsubsection{On `transclude-article'}
\label{sec:orgddd20ad}
First we check to see whether the article contains
transclusions already, and if not, we put the text field
into the format used for text with transclusions
(see Note \ref{sec:org27717b5}).

Next, we divide the text of the article in two; everything prior to
point, and everything after point.  (We have to divide the
\emph{rendered} text, fairly clearly; since there might be more than
one different rendering, we hope that the different possible divisions
are consistent, or at least that we know how to do all of the
divisions.)

Of course, we also need to be able to specify the objects that are to
be transcluded!


\begin{verbatim}
;; totally not working yet!
(defun transclude-article (article)
  (interactive (list (read-article-name)))
  (let ((current (get-article name-of-current-article))
        newtext)
    ;; it really doesn't make sense to use something like this here --
    ;; we only deal with the internal format at commit time.
    (unless (and (listp current)
                 (eq (car current) 'twd))
           (setq newtext `(twd
                           ,(scholium-text current))))
    (let ((beg (point)))
      (insert (sch-plain-text (get-article article)))
      ;; this condition isn't really strong enough
      (when name-of-current-article
        (scholium
         `(derives-from ,name-of-current-article ,article ,(genref))
         nil
         `((passage (,name-of-current-article
                     ,beg
                     ,(point))))
         'derives-from
         'system)))))
\end{verbatim}
\subsection{Inclusion}
\label{sec:orgc3f33d4}
\subsubsection{On `include-article'}
\label{sec:org6b16af6}
It is simple enough to find an article and insert its text at point
(compare `insert-buffer').

\%\% We then need to add `derives-from' and `derives-to' properties (note
\%\% similarity to backlinking; indeed, we reuse `put-backlinks', relying
\%\% on the general way in which it was written; see Note
\%\% \ref{sec:org681fdb2}).


\begin{verbatim}
(defun include-article (article)
  (interactive (list (read-article-name)))
  (let ((beg (point)))
    (insert (sch-plain-text (get-article article)))
    ;; this condition isn't really strong enough
    (when name-of-current-article
      (scholium
       `(derives-from ,name-of-current-article ,article ,(genref))
       nil
       `((passage (,name-of-current-article
                   ,beg
                   ,(point))))
       'derives-from
       'system))))
\end{verbatim}

\subsubsection{By default, don't print `derives-from' scholia}
\label{sec:org702ac3e}

Typically we don't need to see `derives-from' scholia, although it
could be handy to write a special display mode in which these scholia
are printed (and probably special semantics for how they are
displayed).


\begin{verbatim}
(add-to-list 'non-printing-types 'derives-from)
\end{verbatim}
\subsection{Identification}
\label{sec:org8fefbad}
\subsubsection{On `insert-identification-at-point'}
\label{sec:org2133c2b}
This is similar to Note \ref{sec:org6b16af6}.  For now,
I'm just going to write it so that you can do identification
with other articles; later, more general objects will be allowed
(Note ).

We don't actually need to create any scholia,
but we can use the scholia property.  It should
be exactly the same when we render articles that already had
identifications recorded internally.


\begin{verbatim}
(defun insert-identification-at-point (article-name)
  (interactive (list (read-article-name)))
  (let ((beg (point)))
    (insert (sch-plain-text article-name))
    (add-to-scholia-property-within-region
     beg
     (point)
     ;; there aren't any links, so there's no proper linkid
     `(identifies-with ,article-name))))
\end{verbatim}

\subsubsection{On `propagate-changes-to-identification-source'}
\label{sec:orgd06c976}

This runs within the context of
`store-updates-from-identification-images' (when it runs).
Its purpose is to copy changes from the recipient article
in an identification to the source article.


\begin{verbatim}
(defun propagate-changes-to-identification-source ()
  (when (not (equal (buffer-substring-no-properties
                     (second (car identifications))
                     (third (car identifications)))
                    (sch-plain-text
                      (second (caar identifications)))))
    (let ((source (get-article (second (caar identifications)))))
      ;; compare `commit-edits'.  When we actually do
      ;; document versions, this should update the version
      ;; number and any other metadata about how this
      ;; version was created that we get interested in.
      (scholium (second (caar identifications))
                ;; this is bad, since it is storing
                ;; the rendered text, whereas we should of course
                ;; be storing the formatted-for-internal-storage
                ;; text.  But I suppose this is OK for testing
                ;; purposes (wherein we'll only have one level
                ;; of identification).
                (buffer-substring-no-properties
                 (second (car identifications))
                 (third (car identifications)))
                (scholium-about old-contents)
                (scholium-type old-contents)
                (scholium-bookkeeping old-contents)))))
\end{verbatim}

\subsubsection{On `store-updates-from-identification-images'}
\label{sec:org7797b94}

This function will run within the scope of `commit-edits' via the
`commit-edits-hook' (see Note \ref{sec:org283317a}).
We must first identify the identifications (as it were), which we
do by examining the contents of the `adjusted-markup' list.
Then, once these are found, we form a suitable internal
representation.

Everything \emph{between} identifications should get stored
as plain text, whereas the identifications themselves should
be stored as tags.

In addition to adjusting the internal representation of
the article with the identification commands, we should
adjust the text of the source articles, if necessary.
(For simplicity's sake, we could just store updated text
unconditionally for now.)

Concerning the use of `buffer-substring-no-properties':
zapping the properties is questionable, if
we're planning to commit these various derivative
properties serially.  Will have to think about this later.
I think that since this thing is being used to build
internal representations, zapping text properties
might actually be OK.  But I'm not sure.

For clarification on the use of `adjusted-text', see comments on
`commit-edits'.

Note that the only relevant option besides ``less'' is ``equal''
in the `if' here.


\begin{verbatim}
(defun store-updates-from-identification-images ()
  (let ((identifications (remove-if
                          (lambda (elt)
                            (not (eq (caar elt) 'identifies-with)))
                          adjusted-markup))
        (pt 1)
        formatted-contents)
    (while identifications
      (if (< pt (second (car identifications)))
          (setq formatted-contents
                (append
                 formatted-contents
                 (list (buffer-substring-no-properties
                        pt (second (car identifications)))
                       `(ident ,(second (caar identifications)))))
                pt (third (car identifications)))
        (setq formatted-contents
              (append
               formatted-contents
               (list `(ident ,(second (caar identifications)))))
              pt (third (car identifications))))
;      (propagate-changes-to-identification-source)
      (setq identifications (cdr identifications)))
    (when formatted-contents
      (when (< pt (point-max))
        (setq formatted-contents
              (append
               formatted-contents
               (list (buffer-substring-no-properties
                      pt (point-max))))))
      (setq adjusted-text (list 'twd formatted-contents)))))

(add-hook 'commit-edits-hook 'store-updates-from-identification-images)
\end{verbatim}
\subsection{Rendering articles containing derivative portions}
\label{sec:org8ef2309}
\subsubsection{Cluded parts}
\label{sec:orgb67aadd}
These variables will be modified by `unwind-derivatives' to contain a
list of the transcluded sections of a rendered document.
Specifically, the items on the list are of the form
\begin{verbatim}
(<object> <beg> <end>)
\end{verbatim}
where `object' is a link to the thing being transcluded,
and `beg' and `end' represent the beginning and end positions
of the image of the object under this particular clusion, in
the rendered version of the cluding article.

This information will subsequently be used as part of the markup
routine, where it will allow us to add appropriate text properties
indicating cluded regions.

(It may be advantageous to assume that we can always use a
\emph{cached} version of the article we're cluding.  This could be a
help when the article itself is derivative.)


\begin{verbatim}
(defvar transcluded-parts nil)
(defvar identified-parts nil)
(defvar included-parts nil)
\end{verbatim}

\subsubsection{On `unwind-derivatives'}
\label{sec:org03e13e7}
This will run within the scope of `sch-plain-text', and make recursive
calls to `sch-plain-text' as needed, to turn cluded texts into strings
suitable for display.   Specifically, a simple test has been added to
`sch-plain-text-hook' that causes `unwind-derivatives' to run whenever
rendering an article whose \inp{text} field is a list that begins with
the token `twd' (see Note
\ref{sec:orgfaac86c}).

The boundaries of the cluded regions are recorded for subsequent
use, as described in Note \ref{sec:orgb67aadd}.

The contents of the `` \textbf{Unwinding Derivatives}'' buffer needs to be
cleared out before this function first runs for it to return the
correct string.  (Um, is this all going to work out properly if we
enter into the fully recursive run of `unwind-derivatives'?)  That is
accomplished by modifications to `scholia-display-pre-update-hook';
see Note \ref{sec:org7602c41}.

The need for (extensive) recursion in this function could be done away
with if we cached a \emph{rendered} version of every article that used
clusions somewhere where it could be found by other articles that
clude from it.

However, if we are going to have things like references from cluded
documents appear in the assembled document, or (in general) if we want
to have access to the scholia attached to the cluded regions (Note
), we'll either have to pre-render the
derivative components, or come up with some scheme for mapping the
positions of markup associated with these things into suitable
positions in the assembled document.

Note that at present markup will be added by
`add-inclusion-and-transclusion-markup' (Note
\ref{sec:orgbc0024b}).


\begin{verbatim}
(defun unwind-derivatives ()
  (set-buffer (get-buffer-create " *Unwinding Derivatives*"))
  (dolist (elt (cdr text))
    (if (stringp elt)
        (insert elt)
      (let (object)
        (cond
         ((eq (car elt) 'transclude)
          (setq object (cdr elt))
          (setq transcluded-parts (cons `(,object ,(point))
                                        transcluded-parts)))
         ((eq (car elt) 'identify)
          (setq object (cdr elt))
          (setq identified-parts (cons `(,object ,(point))
                                       identified-parts)))
         (t
          (setq object elt)))
        (insert (sch-plain-text object))
        (cond
         ((eq (car elt) 'transclude)
          (setcdr (cdar transcluded-parts) `(,(point))))
         ((eq (car elt) 'ident)
          (setcdr (cdar identified-parts) `(,(point))))))))
  (setq ret (buffer-string)))
\end{verbatim}

\subsubsection{Preparation for rendering text with derivative components}
\label{sec:org7602c41}
We need to zap `transcluded-parts', `identified-parts' and the
contents of the buffer in which derivatives are to be unwound before
`unwinding-derivatives' runs.


\begin{verbatim}
(defun prep-for-rendering-text-with-derivative-components ()
  (setq transcluded-parts nil
        identified-parts nil
        included-parts nil)
  (save-excursion
    (set-buffer (get-buffer-create
                 " *Unwinding Derivatives*"))
    (erase-buffer)))

(add-hook 'scholia-display-pre-update-hook
          'prep-for-rendering-text-with-derivative-components)
\end{verbatim}

\subsubsection{Adding `unwind-derivatives' to the rendering pathway}
\label{sec:orgfaac86c}
We make a call to `unwind-derivatives' in `sch-plain-text' when the
appropriate criterion is satisifed (see Note
\ref{sec:orgc364937}).  The relevant criterion is that we are
rendering an object (i.e., something that gives us an article) whose
\inp{text} field is a list that begins with the token `twd'.

(The complex wording here has to do with the matter that we sometimes
render objects that aren't articles, e.g. a link to a certain passage.
We will have to make sure that the criterion used here is correct for
those cases as well as the easy case of rendering a whole article.
See Note \ref{sec:org66e74d8} for details.)


\begin{verbatim}
(add-hook 'sch-plain-text-hook
          '(lambda ()
             (when (and (listp text) (eq (car text) 'twd))
               (unwind-derivatives))))
\end{verbatim}

\subsubsection{On `add-inclusion-and-transclusion-markup'}
\label{sec:orgbc0024b}
For identifications, this should add the same sort of faked-up markup
that we added with `insert-identification-at-point' (Note
\ref{sec:org2133c2b}).

It might be kind of cute to put some ``corners'' in, showing
where the included text begins and ends (see Note \url{2.2-Design_issues.org}).

These modifications to `mark-things-up' appear to be desired
unconditionally (unlike e.g. the modifications to `sch-plain-text' we
just saw in Note
\ref{sec:orgfaac86c}).  So we just put
`add-inclusion-and-transclusion-markup' directly on the
`mark-things-up-hook' (cf. Note \ref{sec:org8c68add}).


\begin{verbatim}
(defun add-inclusion-and-transclusion-markup ()
  (save-excursion
    (set-buffer-to-rendering-target-buffer)
    (dolist (elt identified-parts)
      (add-to-scholia-property-within-region
       (second elt)
       (third elt)
       `(identifies-with ,(first elt))))
    ;; this may end up having to be considerably more complicated
    (dolist (elt transcluded-parts)
      (add-to-scholia-property-within-region
       (second elt)
       (third elt)
       `(transclusion-of ,(first elt))))))

(add-hook 'mark-things-up-hook 'add-inclusion-and-transclusion-markup)
\end{verbatim}
\subsection{Quick compilations and other listing tricks}
\label{sec:orgf54d38f}
\subsubsection{On `find-names-in-listing'}
\label{sec:org25b6cd6}

This can be used to find the names of listed articles.


\begin{verbatim}
(defun find-names-in-listing (just-marked)
  (let ((names (list t)))
    (save-excursion
      (set-buffer (get-buffer-create "*Generic List*"))
      (goto-char (point-min))
      (while (and (not (eobp))
                  (if just-marked
                      (search-forward-regexp "^>" nil t)
                    t))
        (let* ((next-change (next-single-property-change 
                             (point) 'name))
               (prop (when next-change
                       (get-text-property next-change 'name))))
          (if (not next-change)
              (goto-char (point-max))
            (goto-char next-change)
            (when prop 
              (nconc names (list prop)))))))
    (cdr names)))
\end{verbatim}

\subsubsection{Making a compilation from a listing of articles}
\label{sec:org78a8e3a}
In Note , we talk about making all the articles
that match a given criterion into a new article.  A quick way to
get this functionality to the user is to turn an article listing
into a compilation.  

The version here is very preliminary; eventually we'll be putting in
identifications or something like that to make the various pieces of
the compilation ``hot''.

It be nice to have various display options, either features that
screen certain kinds of content in or out at render time
(e.g. printing of attached code snippets could be optionally be made
automatic), or that add actionable features to the display (e.g. to
enable the user to expand and collapse cluded articles, or to select from a cluded label).

We present a couple of variants here.


\begin{verbatim}
(defun listing-to-compilation (just-marked-items)
  (interactive "P")
  (let ((names (find-names-in-listing just-marked-items)))
    (pop-to-buffer (get-buffer-create "*Compilation*"))
    (erase-buffer)
    (dolist (name names)
      (let ((article (get-article name)))
        (insert (upcase 
                 (propertize (format "%s" (scholium-name article))
                             'face 'italic))
                 "\n"
                 (format "%s" (scholium-text article))
                 "\n")))
    (goto-char (point-min))))

(defun listing-to-compilation-1 (just-marked-items)
  (interactive "P")
  (let ((names (find-names-in-listing just-marked-items)))
    (pop-to-buffer (get-buffer-create "*Compilation*"))
    (erase-buffer)
    (dolist (name names)
      (let ((article (get-article name)))
        (insert  "\*** "
                 (propertize (format "%s" (scholium-name article))
                             'face 'italic)
                 "

"
                 "\n"
                 (format "%s" (scholium-text article))
                 "\
"
                 "\n\n")
        (dolist (scholium (mapcar (lambda (backlink)
                                    (get-article (car backlink)))
                                  (get-backlinks name)))
          (when (typedata-includes (scholium-type scholium) 'code)
            (insert "\\b" "egin{lisp}\n"
                    (scholium-text scholium)
                    "\\e" "nd{lisp}\n\n")))))
    (goto-char (point-min))))
\end{verbatim}

\subsubsection{On `listing-to-label'}
\label{sec:org3974917}

It can be handy to turn an arbitrary listing into
a more permanent label.


\begin{verbatim}
(defun listing-to-label (label-name)
  (interactive "MLabel: ")
  (let ((names (find-names-in-listing)))
    (scholium label-name
              (cdr names)
              nil
              'label
              (sch-book))))
\end{verbatim}

\section{Part X — Persistence and Collaboration}
\label{sec:org7dfee31}
\subsection{Saving and restoring}
\label{sec:orgd6d7f8b}
\subsubsection{Autosave}
\label{sec:org8c6c055}

We might consider making some environment variable that would cause
things to be saved to disk automatically.


\begin{verbatim}
(defun save-all-scholia (filename)
  (interactive (list
                (read-file-name "Filename: ")))
  (save-window-excursion
    (gather-scholia)
    (write-file filename)
    (kill-buffer (current-buffer))))
\end{verbatim}

\subsubsection{On `gather-scholia'}
\label{sec:org6d99e67}

It might be a good idea for this function to take an optional
predicate or label, and gather only scholia that match that predicate.
We could easily cause the gathering function to run only within a
certain context as well.

This function doesn't really have anything to do with saving,
logically speaking, so perhaps it shouldn't go in this section.


\begin{verbatim}
(defun gather-scholia ()
  (interactive)
  (set-buffer (get-buffer-create "*Scholia*"))
  (delete-region (point-min) (point-max))
  (maphash (lambda (name val)
               (write-scholium (cons name val)))
             article-table)
  (display-buffer "*Scholia*"))
\end{verbatim}

\subsubsection{Improving the design of `write-scholium'}
\label{sec:org6567c2c}

One could probably make these things print a bit nicer, e.g. to make
everything fit within 80 columns, but this seems to be good enough for
the time being.


\begin{verbatim}
(defun write-scholium (article)
  (let ((nl "\n          "))
    (insert
     (concat "(scholium " (maybe-quoted-format (scholium-name article))
             nl (maybe-quoted-format (scholium-text article))
             nl (maybe-quoted-format (scholium-about article))
             nl (format "'%S" (scholium-type article))
             nl (format "'%S" (scholium-bookkeeping article))
             ")\n\n"))))

(defun maybe-quoted-format (obj)
  (if (and (not (null obj))
           (or (atom obj) (consp obj)))
      (format "'%S" obj)
    (format "%S" obj)))
\end{verbatim}

\subsubsection{Design of `read-scholia-file'}
\label{sec:orgbf27f61}

This reads and evaluates all of the scholia that have been written out
into the file stored at \inp{filepath}.


\begin{verbatim}
(defun read-scholia-file (filepath)
  (interactive "fFile: ")
  (find-file-literally filepath)
  (read-scholia-buffer)
  (kill-buffer (current-buffer)))

(defun read-scholia-buffer ()
  (while (condition-case nil
             (eval (read (current-buffer)))
           (error nil))))
\end{verbatim}

\subsubsection{Apparently excessive generality of `read-scholia-file'}
\label{sec:org8c58df3}
This system would actually read any elisp file (er, I'm not sure it
would deal well with comments).  There are built-in functions that
accomplish the same thing (`load-file' and `eval-buffer' come to
mind).  The idea here was that we might want to do something somewhat
more complicated than simply evaluating the code found in the file.
That may still happen.


\begin{verbatim}
(defvar search-directory-for-scholia t)

(add-hook 'find-file-hook 'search-directory-for-scholia)

(defun search-directory-for-scholia ()
  (list-directory default-directory t)
  (let ((sch-file
         (replace-regexp-in-string "\\..*" ".sch" (buffer-file-name))))
    (when (search-forward sch-file nil t)
      (read-scholia-file sch-file)
      (display-scholia-about-current-buffer)))
  (kill-buffer "*Directory*"))
\end{verbatim}

\section{Part XI — Bindings and Environment}
\label{sec:org5b81416}
\subsection{Bindings and environment variables}
\label{sec:orgfd4dba1}
\subsubsection{Room to improve on bindings}
\label{sec:orge51996b}

This is just an attempt to make something usable, but it is probably
nowhere near close to optimal.  One thing that would be nice would be
to have some prefix for browsing relative to all scholia versus
some other prefix for browsing relative to only the current scholium.
Thus, you could cycle between regions for the current scholium or
regions for all scholia (or go to the first region or whatever)
depending on what prefix you specified -- but the final keystroke
(``f'' for forward or whatever) would be the same.  Perhaps we
could substitute in the first register (as opposed to the second)
for changing the general style of browsing (e.g. from scholia to
temporal or whatever), but keep second and third pretty much the
same.  It would be good to spell out the analogies in a somewhat
detailed table.


\begin{verbatim}
(mapc
 (lambda (elt) (global-set-key (eval (car elt)) (eval (cdr elt))))
 '(([?\C-\;] . (make-keymap))
   ([?\C-\;?m] . (make-sparse-keymap))
   ([?\C-\;?d] . (make-sparse-keymap))
   ([?\C-\;?o] . (make-sparse-keymap))
   ([?\C-\;?s] . (make-sparse-keymap))

   ((kbd "C-; c") . 'commit-edits)
   ((kbd "C-; g") . 'gather-scholia)
   ((kbd "C-; f") . 'follow-reference-or-scholium)
   ((kbd "C-; n") . 'name-of-current-scholium)
   ((kbd "C-; r") . 'save-all-scholia)

   ((kbd "C-; v n") . 'back-to-normal)
   ((kbd "C-; v o") . 'back-to-other-view)

   ((kbd "C-; b b") . 'sb-back)
   ((kbd "C-; b f") . 'sb-forward)

   ((kbd "C-; l a") . 'article-menu-list-all-articles)
   ((kbd "C-; l l") . 'article-menu-list-labels)
   ((kbd "C-; l m") . 'article-menu-list-articles-matching-regexp)
   ((kbd "C-; l d") . 'article-menu-list-metadata-articles)
   ((kbd "C-; l p") . 'article-menu-list-plain-articles)

   ((kbd "C-; m a") . 'make-scholium-about-current-article)
   ((kbd "C-; m b") . 'make-scholium-about-current-buffer)
   ((kbd "C-; m l") . 'make-scholium-about-current-line)
   ((kbd "C-; m n") . 'make-new-undirected-article)
   ((kbd "C-; m i") . 'make-current-buffer-into-article)
   ((kbd "C-; m p") . 'make-scholium-about-part-of-current-article)
   ((kbd "C-; m P") .
    'make-scholium-about-several-parts-of-current-article)
   ((kbd "C-; m s") . 'make-scholium-about-current-scholium)

   ((kbd "C-; d a") . 'display-article)
   ((kbd "C-; d b") . 'display-scholia-about-current-buffer)
   ((kbd "C-; d l") . 'display-article-listing)
   ((kbd "C-; d p") .
    'display-an-article-that-current-article-is-about)
   ((kbd "C-; d c") .
    'display-an-article-that-current-scholium-is-about)
   ((kbd "C-; d r") . 'redisplay-article)

   ((kbd "C-; o y") . 'sch-turn-main-article-overlays-on)
   ((kbd "C-; o n") . 'sch-turn-main-article-overlays-off)

   ((kbd "C-; s n") .
    'scroll-article-display-to-next-region-for-current-scholium)
   ((kbd "C-; s p") .
    'scroll-article-display-to-previous-region-for-current-scholium)
   ((kbd "C-; s b") . 'move-to-previous-region-with-scholium)
   ((kbd "C-; s f") . 'move-to-next-region-with-scholium)
   ((quote [S-tab]) . 'move-to-next-region-with-scholium)
   ((kbd "C-; s a") . 'move-to-first-region-for-current-scholium)))
\end{verbatim}

\section{Part XII — Applications and Experiments}
\label{sec:org8720d33}
\subsection{Use the scholium system to maintain a library of projects}
\label{sec:orgff2604b}
\subsubsection{Library of major works}
\label{sec:orge60b2d7}

We have an overall structure for the digital library as a whole worked
out already (Section \ref{sec:org644943e}), but not yet a specific
list of major works.  It is convenient to have an index of these (just
like, later, it will be convenient to have many different indices of
different kinds of documents with different features).  So, we create
a virtual library to index these works in.  (Once this is set up
properly, of course the imported version of the scholium system itself
will be included.)

\textbf{However right now this isn’t working, so not exporting that code!}

\begin{verbatim}
(scholium 'major-articles nil nil 'label 'system)
\end{verbatim}
\subsection{Use the scholium system to do literate programming}
\label{sec:orgc80ef9e}
\subsubsection{Importing \LaTeX{} docs}
\label{sec:orga16cbe4}
Note that importing a \LaTeX$\backslash$ document (this one, in particular)
wouldn't be so different from importing a wiki (see Section
\ref{sec:org7047123}).

One of the issues is how we're going to represent cross references
(see Note ).  In compiled \LaTeX, they
typically appear as a number, whereas in source they appear as a tag.
In the scholium system, reference markup should presumably be used,
and I also suppose that we may as well use the name of the article
being referred to directly.  So, for example, this article would
be linked to by text that read ``see `Importing \LaTeX{} docs'.''
This is similar to the way references appear in Texinfo.

Outside references (footnotes) could be rendered in a different
color (Note ), and made browsable within
the scholium system (Note ).

On the implementation: `end' might be followed by a lisp expression
that should be attached to the note, but this should be fun for a
trial run.

The format of the scholia representing the notes is kind of weird.  We
shouldn't have junk in the text field of the article.  It would
probably make more sense for items of type ``note'' to be rendered
specially (if one wished) and maybe to store the tag as a part of a
formatted text field, or, more likely, part of the \emph{type} data.

I think I'd be relatively comfortable adding identification
properties to the regions of the larger document, to get
them to inherit from the individual pieces.  Later we could
parse the section structure.

It would, generally speaking, be a good idea if lower levels
in the hierarchy were \inp{about} their parents in such a way
that we could easily move ``up''.


\begin{verbatim}
(add-hook 'scholia-display-post-update-hook 'text-mode)

(add-to-list 'modified-type-labels '(note . note) t)
(add-to-list 'modified-type-labels '(section . section) t)
(add-to-list 'modified-type-labels '(subsection . subsection) t)
(add-to-list 'modified-type-labels '(subsubsection . subsubsection) t)
\end{verbatim}

\subsubsection{On `map-label'}
\label{sec:orgdbbba4a}
This gives you a way to apply a \inp{function} to every article that
bears a given \inp{label}.


\begin{verbatim}
(defun map-label (function label)
  (mapc function (scholium-text (get-article label))))
\end{verbatim}

\subsubsection{On `swap-out-latex-references'}
\label{sec:org0eafae0}

Does the opposite of `swap-in-latex-references' (Note 
\ref{sec:orgfab2f01}): that is, this
function makes \verb|\ref| tags
in the text look like hyperlinks.


\begin{verbatim}
(defun swap-out-latex-references ()
  (let ((tags-alist (scholium-text (get-article
                                    'Tag-to-Name-converter))))
    (map-label (lambda (name)
                 (with-temp-buffer
                   (let ((article (get-article name)))
                     (insert (scholium-text article))
                     (goto-char (point-min))
                     (while (re-search-forward
                             ;; I don't think we use "xrefs" any more.
                             "\\\\\\(x\\)?ref{\\([^}]+\\)}" nil t)
                       (let ((target (cdr
                                      (assoc (match-string 2)
                                             tags-alist))))
                         (when target
                           (replace-match target t t)
                           (let ((name-of-current-article name))
                             (make-reference-in-current-article
                              (match-beginning 0)
                              (+ (match-beginning 0) (length target))
                              target)))))
                     ;; we don't want these references to be fake
                     (scholium name
                               (buffer-substring-no-properties
                                (point-min)
                                (point-max))
                               (scholium-about article)
                               '(note)))))
               'note)))
\end{verbatim}

\subsubsection{On `import-scholium-system'}
\label{sec:org1208fa3}
For now, this is just `import-sections', but it would be good if we
could do something about sections that contain neither subsections nor
notes, for example, the preface.  Other nice features (e.g. creating
``function type'' scholia for functions, as in Note
) should be added too, eventually.  Sometimes
work arounds can be applied for the time being.

\emph\{Hint: I've found that for now one has to `(clrhash
  article-table)' before running this function for things to work
  properly.  I intend to address this issue soon.\}

(We might want to make this article use some kind of identification
routine; alternatively, make it work with a ``large structure'' map of
the document's contents.)


\begin{verbatim}
(defun import-scholium-system ()
  (interactive)
  (import-sections)
;  (label-article 'section 'major-articles)
  (swap-out-latex-references))
\end{verbatim}

\subsubsection{On `import-sections'}
\label{sec:org2e59f7f}

For each section, import any notes and any subsections.

I'm going to try to get this to import front- and back-matter (before
the first section and after the last note, respectively).  This will
make it easier to typeset everything with one command.


\begin{verbatim}
(defun import-sections ()
  (save-excursion
    (set-buffer "sbdm4cbpp.tex")
    (goto-char (point-min))
    (search-forward-regexp "^\\\\section{Prelude}")
    (goto-char (match-beginning 0))
    (scholium "Scholium system frontmatter"
              (buffer-substring-no-properties (point-min) (point))
              nil
              '(note))
    (while (re-search-forward
            (concat
             "^\\\\section\\*?{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            nil t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (section-end (save-excursion
                            (search-forward-regexp
                             "^\\\\section{.*" nil t)))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsection{.*"
                               section-end t))
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes)))
             (subsections (let ((current-parent name))
                            (import-subsections))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  `(,@notes
                    ,@subsections)
                  '((section parent))
                  '(section label))))
    (goto-char (point-max))
    (search-backward-regexp "^\\\\clearpage")
    (scholium "Scholium system backmatter"
              (buffer-substring-no-properties (point) (point-max))
              nil
              '(note))))
\end{verbatim}

\subsubsection{On `import-subsections'}
\label{sec:org1874ba8}

For each subsection, import any notes and any subsubsections.
notes are imported if they appear before the first subsubsection,
if there is one, or before the end of the subsection, otherwise,
or before the end of the section, if this is the last subsection


\begin{verbatim}
(defun import-subsections ()
  (let (subsections)
    (while (re-search-forward
            (concat
             "^\\\\subsection{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            section-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (subsection-end (or (save-excursion
                                   (search-forward-regexp
                                    "^\\\\subsection{.*"
                                    section-end t))
                                 section-end))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsubsection{.*"
                               subsection-end t))
                            subsection-end
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes)))
             (subsubsections (let ((current-parent name))
                               (import-subsubsections))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  `(,@notes
                    ,@subsubsections)
                  `((,current-parent parent))
                  '(subsection label))
        (setq subsections
              (append subsections (list name)))))
    subsections))
\end{verbatim}

\subsubsection{On `import-subsubsections'}
\label{sec:org49333a5}

For each subsubsection, import any notes that appear before
the end of the subsubsection (if this is the last subsection,
then before the end of the subsection, etc.).


\begin{verbatim}
(defun import-subsubsections ()
  (let (subsubsections)
    (while (re-search-forward
            (concat
             "^\\\\subsubsection{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            subsection-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsubsection{.*"
                               subsection-end t))
                            subsection-end
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  notes
                  `((,current-parent parent))
                  `(subsubsection label))
        (setq subsubsections
              (append subsubsections (list name)))))
    subsubsections))
\end{verbatim}

\subsubsection{On `import-notes'}
\label{sec:org3b39c07}

This imports the notes at the current level in the
section hierarchy.


\begin{verbatim}
(defun import-notes ()
  (let (notes)
    (while
        (re-search-forward (concat "\\\\begin{notate}"
                                   "{\\([^}\n]*\\)}"
                                   "\\( +\\\\label{\\)?"
                                   "\\([^}\n]*\\)?")
                           notes-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (beg (progn (next-line 1)
                         (line-beginning-position)))
             ;; no need to bound the search for the end, because we
             ;; assume that every "notate" environment is actually
             ;; closed
             (end (progn (search-forward-regexp
                          "\\\\end{notate}")
                         (match-beginning 0))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  (buffer-substring-no-properties beg end)
                  `((,current-parent parent))
                  '(note))
        (setq notes
              (append notes (list name)))
        (import-code-continuations)))
    notes))
\end{verbatim}

\subsubsection{On `import-code-continuations'}
\label{sec:orgfe3fa85}

This runs within the scope of `import-notes', to turn any Lisp chunks
that follow a given Note into scholia attached to that note.  (This
won't import the one stand-alone ``verbatim'' environment used in the
code; we could change this function, or include the environment inside
of a Note.  Or we could just put the literate programming code into
another file.  Minor issue.  Also, figure environments would be left
out, except for a small trick, namely including them within
surrounding Notes.)  Notice that previous versions of these articles
shouldn't exist at import time, or Lisp sections will be doubled.

The code continuations and the code descriptions wind up being
mutually about one another, which is kind of cute.


\begin{verbatim}
(defun import-code-continuations ()
  ;; ugly formatting = latex overrides!
  (while (looking-at (concat "\n\n\\\\b" "egin{lisp}"))
    (scholium `(code-continuation ,name)
              (let ((old-text (scholium-text
                               (get-article
                                `(code-continuation ,name))))
                    (new-text (buffer-substring-no-properties
                               (progn (next-line 3)
                                      (line-beginning-position))
                               (progn (search-forward-regexp
                                       (concat "\\\\e" "nd{lisp}"))
                                      (match-beginning 0)))))
                (if old-text 
                    (concat old-text "\n" new-text)
                  new-text))
              `(((article ,name)))
              'code)
    ;; this should add an appropriate link to the article
    ;; that this is a code-continuation of.
    (let ((article-to-edit (get-article name)))
      (scholium (scholium-name article-to-edit)
                (scholium-text article-to-edit)
                (add-to-or-start-list 
                 (scholium-about article-to-edit)
                 `(code-continuation (code-continuation ,name)))
                (scholium-bookkeeping article-to-edit)))))
\end{verbatim}

\subsubsection{Identification of notes is slow}
\label{sec:orgfda034a}

I tried identifying each note with its source region by running
\begin{idea}
(add-to-scholia-property-within-region
 beg
 end
 `(identifies-with ,name))
\end{idea}
towards the end of `import-notes', but it slowed everything down.

We may be able to get something similar by other means
anyway (Note ).


\begin{verbatim}
(defun browse-scholium-system ()
  (interactive)
  (import-scholium-system)
  (display-article 'section)
  (message "You've successfully imported the system!"))
\end{verbatim}

\subsubsection{On `export-scholium-system'}
\label{sec:org0226f0d}
We use a similar sort of ``recursive'' style to that used in the import.
First, loop through the sections.  These must of course be exported in
their own limited fashion.  Then, for each, examine the contents. The
items contained in each section are either subsections or notes.  If
the item really is a subsection, then do something similar to what we
did with sections; otherwise, it is a note and we simply export it.
The items at the penultimate level are either subsubsections or notes;
and finally, in the end, the items are all notes.

Note that getting the ``Tag-to-Name-converter'' each time it
is used in the child functions is really sort of excessive,
since it could be found once in the parent.  However, things seem
to run fast enough.


\begin{verbatim}
(defun export-scholium-system ()
  (set-buffer (get-buffer-create "*Export*"))
  (erase-buffer)
  (insert (scholium-text (get-article "Scholium system frontmatter")))
  (dolist (sect (scholium-text (get-article 'section)))
    (export-section sect)
    (let ((contents (scholium-text (get-article sect))))
      (dolist (item contents)
        (let ((current-item (get-article item)))
          (if (typedata-includes (scholium-type current-item)
                                 'subsection)
              (export-subsection (scholium-name current-item))
            (export-note current-item))))))
  (insert (scholium-text (get-article "Scholium system backmatter"))))
\end{verbatim}

\subsubsection{On `export-note'}
\label{sec:org39475fd}
This is for exporting notes.  When the note has a code
continuation it also exports that code.

To really work, this is going to have to replace references with
\verb|\refs| and \verb|\refs|.  Hopefully we're storing the relevant
information somewhere easily accessible at import time?  We should at
very least be able to do the opposite of what is done with
`swap-out-latex-references'.

We essentially need to render the article to know
what the relevant references are (and where they are).
This suggests to me that if we don't want to disrupt the
user's experience of the rendered articles appearing in
the standard display, we should be able to ``beam'' a
rendering to some other buffer and then pick it up from
there.  Also, if some references have been generated
that don't correspond to items with tags, we'll have to
accomodate that.


\begin{verbatim}
(defun export-note (note)
  (set-buffer (get-buffer "*Export*"))
  (let* ((name (scholium-name note))
         (tag (car (rassoc name (scholium-text
                                 (get-article
                                  'Tag-to-Name-converter))))))
    (insert "\*** " name "

"
            (if tag 
                (concat " \\label{" tag "}\n")
              "\n")
            (swap-in-latex-references note)
            "\
\n\n")
    (dolist (scholium (mapcar (lambda (backlink)
                                    (get-article (car backlink)))
                              (get-backlinks name)))
      ;; we were missing one function from a list of two in my last
      ;; test of exporting, should look into this.
      (when (typedata-includes (scholium-type scholium) 'code)
        (insert "\\b" "egin{lisp}\n"
                (scholium-text scholium)
                "\\e" "nd{lisp}\n\n")))))
\end{verbatim}

\subsubsection{On `swap-in-latex-references'}
\label{sec:orgfab2f01}
Maybe it would be easier if each of the references had
the name of the tag stored locally?  This doesn't
seem like it would actually help.  The point I guess
is that we don't want to detect the scholia structure
all at once, but rather, zip through and make changes
to each item we encounter, in order.  I.e., the endpoints
of the regions that we'll be modifying are always in
transition.

`move-to-next-region-with-scholium' will have to be set up to
return `nil' if there is no next scholium.  It would also be
nice if this returned the boundaries of the region to which the
scholium is attached, when there is a scholium, since we're
going to want to do a replacement of the text in that region.
(If it proves more reasonable to use a different function for
this purpose, that would be fine, but this is roughly what it
should do.)  Note that `move-to-next-region-with-scholium'
currently works in terms of overlays, which isn't really
right.

After we find the scholia at the start and end of the marked region,
we could check a complicated condition to see if there is a reference
at the beginning and another copy of the same reference at the end.
But for the time being we aren't going to work with this general case
of overlapping references, and we'll just assume one reference per
marked region and get on with things.


\begin{verbatim}
(defun swap-in-latex-references (note)
  (save-excursion
    (let ((tags-alist (scholium-text (get-article
                                      'Tag-to-Name-converter))))
      (display-article (scholium-name note))
      (set-buffer (get-buffer "Main Article Display"))
      (let ((next-region (move-to-next-region-with-scholium)))
        (while next-region
          (let ((scholium-property-at-start 
                 (get-text-property (first next-region) 'scholia))
                (scholium-property-at-end 
                 (get-text-property (second next-region) 'scholia)))
            (let* ((scholium-id (first scholium-property-at-start))
                   (scholium-name (first scholium-id))
                   (possible-reference (get-article scholium-name)))
              (when (typedata-includes 
                     (scholium-type possible-reference)
                     'reference)
                (let ((scholium-tag 
                       (car (rassoc (reference-to-article 
                                     possible-reference)
                                    tags-alist))))
                  (if scholium-tag
                      (progn (delete-region (first next-region)
                                            (second next-region))
                             (goto-char (first next-region))
                             (insert "\[[id:" scholium-tag "]]"))
                    (let ((new-tag (replace-regexp-in-string
                                    " " "-"
                                    (buffer-substring-no-properties
                                     (first next-region)
                                     (second next-region)))))
                      (delete-region (first next-region)
                                     (second next-region))
                      (goto-char (first next-region))
                      (insert "\[[id:" new-tag "]]"))))))
            (setq next-region (move-to-next-region-with-scholium)))))
      (buffer-substring-no-properties (point-min)
                                      (point-max)))))

(defun export-section (section-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc section-name (scholium-text
                                         (get-article
                                          'Tag-to-Name-converter))))))
    (insert "\\section{" section-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n"))))

(defun export-subsection (subsection-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc subsection-name (scholium-text
                                            (get-article
                                             'Tag-to-Name-converter))))))
    (insert "\\subsection{" subsection-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n")))
  (let ((contents (scholium-text current-item)))
    (dolist (item contents)
      (let ((current-item (get-article item)))
        (if (typedata-includes (scholium-type current-item)
                               'subsubsection)
            (export-subsubsection (scholium-name current-item))
          (export-note current-item))))))

(defun export-subsubsection (subsubsection-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc subsubsection-name (scholium-text
                                               (get-article
                                                'Tag-to-Name-converter))))))
    (insert "\\subsubsection{" subsubsection-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n")))
  (let ((contents (scholium-text current-item)))

    (dolist (item contents)
      (let ((current-item (get-article item)))
        (export-note current-item)))))
\end{verbatim}
\subsection{Simulating a wiki with the scholium system}
\label{sec:org7047123}
\subsubsection{On `mark-up-wiki-with-reference-scholia'}
\label{sec:org3200c73}

Find things in double brackets, possibly with an intervening ``|'',
making sure to find the minimal double bracket pair.  What
\emph{should} happen (though the current draft is a bit different) is:
a reference scholium should be created for each reference, and stuck into the
article list in some appropriate place (presumably the namespace
associated with the article in question, more specifically, on some
specific reference subspace of that space).  \emph{Then} when someone goes
to render the document in question, we grab the references out of their
storage facility and mark up the document with text properties.
(The current implementation is really just a regexp check\ldots{})


\begin{verbatim}
(defun mark-up-wiki-with-reference-scholia ()
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward
            ;; we could probably get all types of reference in
            ;; one regexp.  I'm not sure why the old
            ;; version for grabbing external references was deleted,
            ;; but it is featured in the Sept 4 printout.
            "\\[\\[\\([^]|\n]+\\)\\(|\\)?\\([^]]+?\\)?]]" nil t)
      (replace-match (propertize (or (match-string 3)
                                     (match-string 1))
                                 'scholia
                                 "Reference")))))
\end{verbatim}
\subsection{Using the scholium system for HDM things}
\label{sec:orga4fe99a}
\subsubsection{Types for the APM-\(\Xi\)}
\label{sec:org626361b}

We keep track of the sections, entries, and stubs that belong to
APM-\(\Xi\) as special types.


\begin{verbatim}
(add-to-list 'modified-type-labels '(apmxi-section . apmxi-section) t)
(add-to-list 'modified-type-labels '(apmxi-entry . apmxi-entry) t)
(add-to-list 'modified-type-labels '(apmxi-stub . apmxi-stub) t)
\end{verbatim}

\subsubsection{On `make-apmxi-sections-into-articles'}
\label{sec:org0b6954d}

This function makes every section in the APM-\(\Xi\) into its own
article.  The list of these articles is recorded on the article
`apmxi-section'.


\begin{verbatim}
(defun make-apmxi-sections-into-articles ()
  (save-window-excursion
    (find-file "../p2/Xi.tex")
    (goto-char (point-min))
    (while (re-search-forward "^\\\\section{{ \\(.+\\)}} " nil t)
      (let ((article-name (match-string-no-properties 1))
            (beg (point))
            (end (save-excursion (search-forward "\\section" nil t)
                                 (match-beginning 0))))
        (when end
          (scholium article-name
                    (buffer-substring-no-properties beg end)
                    nil
                    'apmxi-section))))))
\end{verbatim}

\subsubsection{On `chunk-out-apmxi-definitions'}
\label{sec:orgb616f99}
Apparently some of the terms in APM-\(\Xi\) were defined in multiple
sections.  At least, \emph{stubs} appear in multiple places.  This
should presumably create multiple definitions when multiple
definitions are given, or get rid of stub-like definitions, or
something.

Note that the way this is set up, even sections that contain only
stubs can also contain references to the real articles, when they
exist -- this means that the real articles may appear in several
listings, which I think is as it should be.


\begin{verbatim}
(defun chunk-out-apmxi-definitions ()
  (map-label (lambda (name)
               (with-temp-buffer
                 ;; this ensures that sexps are defined properly
                 (latex-mode)
                 (let ((topic (get-article name))
                       contents)
                   (insert (scholium-text topic))
                   (goto-char (point-min))
                   (while (re-search-forward "^(" nil t)
                     (let* ((beg (match-beginning 0))
                            (title-beg (match-end 0))
                            (title-end (progn (goto-char beg)
                                              (forward-sexp)
                                              (1- (point))))
                            (stub-p (looking-at " *$"))
                            (title (buffer-substring-no-properties
                                    title-beg
                                    title-end))
                            (end (save-excursion
                                   (search-forward-regexp "^$")))
                            (possible-previous (get-article title)))
                       (when (or (not possible-previous)
                                 (typedata-includes (scholium-type
                                                     possible-previous)
                                                    'apmxi-stub))
                         (scholium title
                                   (buffer-substring-no-properties
                                    beg
                                    end)
                                   `((,name parent))
                                   (if stub-p
                                       '(apmxi-stub apmxi-entry)
                                     'apmxi-entry)))
                       (setq contents (cons title contents))))
                   (scholium name
                             contents
                             nil
                             '(apmxi-section label)))))
             'apmxi-section))
\end{verbatim}

\subsubsection{On `import-apmxi'}
\label{sec:org75e4564}
This function puts into play all of the other functions developed
above, to fully process the APM-\(\Xi\) and get it nicely situated in
the scholium system.


\begin{verbatim}
(defun import-apmxi ()
  (make-apmxi-sections-into-articles)
  (chunk-out-apmxi-definitions))
\end{verbatim}

\subsubsection{Selecting all APM-\(\Xi\) stubs}
\label{sec:orgc4329cc}

If you want to look at a list of all stubs in the APM-\(\Xi\), run this code:
\begin{verbatim}
(article-menu-list-articles-matching-predicate 
 (lambda (name)
   (when (typedata-includes (scholium-type (get-article name))
                            'apmxi-stub)
     t)))
\end{verbatim}
(See  Note \ref{sec:org1be4115}.)


\subsubsection{Screening out APM-\(\Xi\) stubs}
\label{sec:org49de6a2}
If you want to screen \emph{out} the stubs in the APM-\(\Xi\), run
\begin{verbatim}
(display-difference-of-labels 'apmxi-entry 'apmxi-stub)
\end{verbatim}
(see Note \ref{sec:org1822408}).  Of course,
eventually we're going to want to do some more processing
to make the stubs into useful things.


\subsubsection{Facilitate collaboration between HDM authors}

\section{Part XIII — Reflections and Philosophy}
\label{sec:org59eb9e6}

\section{Part XIV — Conclusions and Appendices}
\label{sec:org14442c9}
\subsection{Appendix: Overview of specifications}
\label{sec:org7296bfd}
\subsubsection{Spec for article}
\label{sec:org305388f}

An article is an element of some namespace, by default,
the main article-table (a hash table).  
It takes the form of a quintuplet,
\begin{verbatim}
(name text about type bookkeeping)
\end{verbatim}
where, when stored in the hash table, \inp{name} is used
as the key.  (See Note .)


\subsubsection{Spec for link}
\label{sec:orgeb9e465}

Each link takes the form
\begin{verbatim}
(<target article's name> &rest <link-types>)
\end{verbatim}
The design here maintains partial symmetry between the treatment of
article types and link types; the cdr of a link can be processed
by the same typedata processing functions as the \inp{type}
data from articles.  (See Note \ref{sec:org49d5148}.)


\subsubsection{Spec for metadata article}
\label{sec:org524dd40}

An article \(A\) has metadata article \(\tilde{A}\) whose
\inp{name} is 
\begin{verbatim}
(meta <name of A>)
\end{verbatim}
The \inp{text} of a metadata article takes the form of a list of
lists, with each sub-list headed by a tag naming the contents of that
sub-list.  The \inp{about} data is `nil', the \inp{type} is `meta',
and the bookkeeping data is `system'.  (See Note
.)


\subsubsection{Spec for backlink}
\label{sec:orga74c5ee}

An article's backlinks are stored on the `backlink' field of its
metadata article.  An individual backlink
takes the form
\begin{verbatim}
(<name> <link number> [<version number>])
\end{verbatim}
where ``name'' is the name of the article being backlinked, and
link number indicates the particular link to which this backlink
corresponds.  The optional version number is used if the backlink
corresponds to a specific version of the linking article other
than the most current one.
(See Note .)


\subsubsection{Spec for link-id}
\label{sec:org4a4be26}

The purpose of a link-id is to specify a link when marking up a piece
of text with a text property corresponding to a scholium, namely the
link through with that region was indicated (see Note
; the `scholia' text property contains a
list of link-ids.).

The format of a link-id is
\begin{verbatim}
(<name> <link number>)
\end{verbatim}

Notice that link-id's also come up in the context of masks and other
places.  They are a sort of idiom used in several places in the work
(as you can easily see by looking around at the specs shown in this
appendix).  One thing to notice is that the ``usable about data'' of
Note \ref{sec:org13a277d} \emph{et seq.} leads up to markup
fairly directly, and, in particular, that it computes markup by
applying masks to links as needed.  So, it is no wonder that there is
some continuity between these various parts of the system; and, in
particular, the fact that link-id's are a part of that continuity
makes sense.


\subsubsection{Spec for mask}
\label{sec:org0640b6b}
An article's masks are stored in the `masks' field of its metadata
article.  An individual mask takes the form
\begin{verbatim}
((<name> <link number>) &rest regions)
\end{verbatim}
The regions are two-element lists, each giving the beginning and end
of a region that the link is being redirected to.  See Note
and Note \ref{sec:org537c937}, and for further discussion
of the lack of generality in the current mask format, see Note
.


\subsubsection{Spec for `usable-about-data'}
\label{sec:orga823003}

Something called ``usable-about-data'' is produced by the function
`compute-usable-about-data' (see Note
\ref{sec:org13a277d}).  This stuff is used when marking
things up (in particular, by `mark-up-scholium' and
`mark-up-reference').  The reason for documenting it here is that its
format is confusing and easy to forget.  I think that it would be best
if we could find another way to get this data to where it needs to be.

The format of the return value of `compute-usable-about-data'
is a list of elements of the form
\begin{verbatim}
((<name> <link number>) <beg end | nil>)
\end{verbatim}
where name is the name of a scholium, `beg' and `end', if specified,
give the beginning and end of a marked region (yes, only one region
per link, as mentioned in Note \url{3.2-Creating_scholia.org}),
whereas `nil' is specified if the link indicated by the `car' of this
form points at the whole of the article being rendered.  

(I am not a huge fan of this format, but it does seem to work;
however, maybe the name should be changed to ``usable about data for
markup'' or something like that, to make it clear why we are focusing
on data describing regions.)

(Also, perhaps we should note in this spec that instead of the
\inp{name}, sometimes ``(mask \inp{name})'' is used instead.  The
development here seems a bit confusing: if we use (mask \inp{name}),
is this a proper link-id?  Something to think about, I guess.)
\subsection{Appendix: Annotated non-bibliography}
\label{sec:org5f2c0ea}
\subsubsection{Outside references}
\label{sec:org76de9b2}

For now, references are contained in footnotes.  To view a compilation
of the Notes that contain footnotes, evaluate this form:
\begin{verbatim}
(progn (article-menu-list-articles-matching-regexp "\\footnote")
  (listing-to-compilation nil))
\end{verbatim}
Eventually we may have a nicer way of presenting this data.  Also,
there are a number of references made in the text for which there are
no footnotes, and the footnotes that do exist don't necessarily take a
proper or in any way standard form.  This can be fixed up eventually.
\end{document}
** Scholia browsing
:PROPERTIES:
:LATEX_LABEL: browse-scholia
:ID: browse-scholia
:END:

*** Introduction to scholia browsing                               :noexport:

The point of this section is to associate scholia with the regions of
the article that they apply to, and to enable the user to quickly find
and navigate between the marked-up regions in the displayed version of
this article and their associated scholia.


*** Moving without reparsing                                       :noexport:
:PROPERTIES:
:LATEX_LABEL: moving-with-reparsing
:ID: moving-with-reparsing
:END:

The functions for scholia browsing are likely to move you to the
``wrong place'' unless the buffer has been parsed and the scholia
locations are up-to-date (i.e., it will move you to the specified
region, but this will probably be the wrong region).


*** Problem with the design of the `move-to...-scholium' functions :noexport:

These probably shouldn't be using overlays as the source of their
 information about where scholia reside, since overlays are not
 necessarily going to be there!  

(I guess this means ``if the content has been cut and pasted.''  I'm
 guessing that there are cases where we would like to use this
 function under conditions in which cutting and pasting may have taken
 place.  I'm not sure exactly what those cases would be, since I'm not
 sure exactly when this function is called.  Seems it is, so far, only
 called in the case of scrolling the main article display to a certain
 region, namely a region with an attached scholium.  It might be
 reasonable just to use overlays in that case (?).  This is a somewhat
 curious point, and since it actually deals with something sort of
 fundamental in Emacs, maybe it would be best to give it more thought
 \emph{later}, especially since this function is probably useful right
 \emph{now}.)

They can be turned off altogether (Section
# [[id:overlays-on-off]]
) or
 one by one (Note [[id:overlay-styles]]).

(That is a good point.  Audience, what do you think?)

Anyway, the logic of the function is probably going to be similar
no matter what guts we use.

Note that there is a funny case of two references that begin
at the same point (and, possibly, end at the same point as well).
I think this case isn't handled well by the function the way it
is written.

This is a general matter that goes beyond these functions -- and
 should probably be noted as such somewhere.


*** On `move-to-next-region-with-scholium' and `move-to-previous-region-with-scholium'
:PROPERTIES:
:LATEX_LABEL: move-to-next-or-previous-region-with-scholium
:ID: move-to-next-or-previous-region-with-scholium
:END:

This moves the point to the beginning of the next region that has a
scholium about it (if there is one).

(I'm noticing a bug when the function is used interactively with the
binding selected in Section [[id:bindings]] and the cursor is
positioned on a right paren; calling the function with M-x in this
case doesn't result in the same problem.)

Note these two functions are not quite symmetrical, because we
want the cursor to end up at the beginning of the marked
region.  (I think there will be a problem if we try to go to the
beginning of a scholium that is attached at the beginning of
the article, but that isn't such a big deal.)


#+BEGIN_SRC elisp
(defun move-to-next-region-with-scholium ()
  (interactive)
  (let ((change (next-overlay-change (point))))
    (if (overlays-at change)
        (progn (goto-char change)
               (list change (next-overlay-change change)))
      (if (overlays-at (next-overlay-change change))
          (progn (goto-char (next-overlay-change change))
                 (list (next-overlay-change change)
                       (next-overlay-change (next-overlay-change 
                                             change))))
        (message "No subsequent regions with scholia about them.")
        nil))))

(defun move-to-previous-region-with-scholium ()
  (interactive)
  (let ((change (previous-overlay-change (point))))
    (if (overlays-at change)
        (progn (goto-char change)
               (list change (previous-overlay-change change)))
      (if (overlays-at (previous-overlay-change change))
          (progn (goto-char (previous-overlay-change change))
                 (list (previous-overlay-change change)
                       (previous-overlay-change (previous-overlay-change 
                                             change))))
        (message "No previous regions with scholia about them.")
        nil))))

(defun scroll-article-display-to-next-region-for-current-scholium ()
  (interactive)
  (save-excursion
    (set-buffer buffer-associated-with-current-article)
    (let (found
          (curpoint (point)))
      (while (and (not found)
                  (not (eobp))
                  (move-to-next-region-with-scholium))
        (mapc (lambda (overlay)
                (when (equal (overlay-get overlay 'scholia)
                             (name-of-current-scholium))
                  (setq found t)))
              (overlays-at (point)))
        (if found
            (recenter)))
      (when (not found)
        (goto-char curpoint)
        (message "Scholium not about further regions in buffer.")))))

(defun scroll-article-display-to-previous-region-for-current-scholium ()
  (interactive)
  (save-excursion
    (set-buffer buffer-associated-with-current-article)
    (let (found
          (curpoint (point)))
      (while (and (not found)
                  (not (bobp))
                  (move-to-previous-region-with-scholium))
        (mapc (lambda (overlay)
                (when (equal (overlay-get overlay 'scholia)
                             (name-of-current-scholium))
                  (setq found t)))
              (overlays-at (point)))
        (if found
            (recenter)))
      (when (not found)
        (goto-char curpoint)
        (message "Scholium not about previous regions in buffer.")))))
#+END_SRC

*** Cycling through regions                                        :noexport:

It wouldn't be too hard to make a variant of
`scroll-article-display-to-previous-region-for-current-scholium' that
cycles through the regions that the current scholium is about.


*** On `move-to-first-region-for-scholium'
:PROPERTIES:
:LATEX_LABEL: move-to-first-region-for-scholium
:ID: move-to-first-region-for-scholium
:END:

Move you to the beginning of the region marked up by the scholium
named \inp{name}.  Should this be made interactive?)  At present, it
is only called by `move-to-first-region-for-current-scholium'.


#+BEGIN_SRC elisp
(defun move-to-first-region-for-scholium (name)
  (pop-to-buffer (get-buffer rendering-target-buffer))
  (let ((beg (point-max))
        (about (scholium-about (get-article name))))
    (dolist (link about)
      ;; this should be revised in light of the
      ;; fact that a link can be multiply typed
      (when (and (typedata-includes-passage (link-type elt))
                 (equal (linked-to-article link)
                        name-of-current-article)
                 (< (link-beginning link) beg))
        (setq beg (link-beginning link))))
    (unless (equal beg (point-max))
      (goto-char beg))))
#+END_SRC

*** On `move-to-first-region-for-current-scholium'

This uses the function `move-to-first-region-for-scholium' from
section [[id:browse-scholia]]; the thought behind including the
function here is that it establishes a relationship between
the Scholia Display buffer and the main article buffer (however
it could probably go in section [[id:browse-scholia]] equally well).

This should probably be complemented by a function
`move-to-last-region-for-current-scholium'.

Also, it should probably have some intelligent message
(not to say ``error message'') if the scholium applies to
the article as a whole.

(Gives some error, complaining about `elt' being void.
Can this run in the Scholia Display buffer as well as the
main article buffer?)


#+BEGIN_SRC elisp
(defun move-to-first-region-for-current-scholium ()
  (interactive)
  (let ((current (name-of-current-scholium)))
    (move-to-first-region-for-scholium current)))
#+END_SRC

** Scholium programming

*** Scholium programming                                           :noexport:

The next several functions allow us to store and retrieve code
from inside of the network.


*** On `node-fun'

\ldots\todo{Explain.}
Produce a list of commands to produce temporary bindings.
Produce a list of commands to reset function values.


#+BEGIN_SRC elisp
(defun node-fun (node get-code get-links)
  (let ((code  (funcall get-code node))
        (links (funcall get-links node)))
    (list
     'lambda
     (car code)
     (cons
      'prog1
      (cons
       (append
        '(progn)
        (mapcar #'(lambda (x)
                    `(fset ',(car x)
                           (node-fun ,(cdr x)
                                     ',get-code
                                     ',get-links)))
                links)
        (cdr code))
       (mapcar #'(lambda (x)
                   (if (fboundp (car x))
                       `(fset ',(car x)
                              ',(symbol-function (car x)))
                     `(fmakunbound ',(car x))))
               links))))))
#+END_SRC

*** On `tangle-module'

Recursively replace the chunks to recover executable code.\todo{Explain.}


#+BEGIN_SRC elisp
(defun tangle-module (node get-cont ins-links)
  (insert-chunk
   (funcall get-cont node)
   (mapcar #'(lambda (x)
               (cons (car x)
                     (tangle-module (cdr x)
                                    get-cont
                                    ins-links)))
           (funcall ins-links node))))
#+END_SRC

*** On `insert-chunk'

Given a node and an association list of replacement texts, insert
the chunks at the appropriate places.


#+BEGIN_SRC elisp
(defun insert-chunk (body chunks)
  (cond ((null body) nil)
        ((null chunks) body)
        ((equal (car body) '*insert*)
         (cdr (assoc (cadr body) chunks)))
        (t (cons (insert-chunk (car body) chunks)
                 (insert-chunk (cdr body) chunks)))))
#+END_SRC

*** Functions for rewriting nemas

Several functions for rewriting nemas.\todo{How does this stuff relate to what's
going on in the vicinity of Note [[id:update-sink]]?}


#+BEGIN_SRC elisp
(defun set-src (n x)
  (if (equal n 0)
      0
    (progn (let ((old-backlink
                  (nth 1 (assoc (get-src n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((new-backlink
                  `(nth 1 (assoc x (cdr article-list)))))
             (setcdr new-backlink (cons n (cdr new-backlink))))
           (setcar (nth 1 (assoc n (cdr article-list))) x))))

(defun set-txt (n x)
  (setcar (cdr (cdr (assoc n (cdr article-list)))) x))

(defun set-snk (n x)
  (if (equal n 0)
      0
    (progn (let ((old-backlink
                  (nth 3 (assoc (get-snk n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((new-backlink
                  (nth 3 (assoc x (cdr article-list)))))
             (setcdr new-backlink (cons n (cdr new-backlink))))
           (setcar (nth 3 (assoc n (cdr article-list))) x))))

(defun ins-nod (src txt snk)
  (progn (setcdr article-list
                 (cons (list (car article-list)
                             (list src)
                             txt
                             (list snk))
                       (cdr article-list)))
         (let ((backlink
                (nth 3 (assoc snk (cdr article-list)))))
           (setcdr backlink (cons (car article-list)
                                  (cdr backlink))))
         (let ((backlink
                (nth 1 (assoc src (cdr article-list)))))
           (setcdr backlink (cons (car article-list)
                                  (cdr backlink))))
         (- (setcar article-list (+ 1 (car article-list))) 1)))

(defun del-nod (n)
  (if (or (equal n 0)
          (get-blk n)
          (get-flk n))
      nil
    (progn (let ((old-backlink
                  (nth 3 (assoc (get-snk n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((old-backlink
                  (nth 1 (assoc (get-src n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (setcdr article-list
                   (delete (assoc n (cdr article-list))
                           (cdr article-list)))
            t)))
#+END_SRC

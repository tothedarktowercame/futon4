** Using the scholium system for HDM things
:PROPERTIES:
:LATEX_LABEL: HDM-things
:ID: HDM-things
:END:

*** What is HDM and how does it relate to the scholium system?     :noexport:

The HDM (expanded: Hyperreal Dictionary of Mathematics) project is
about \emph{taking the world's mathematical knowledge, and getting it
  into a format that is as useful as possible.}

The key point to make here is that HDM will be a free culture artifact
containing lots and lots of mathematical information (definitions,
theorems, proofs, expositions, examples, and excursions, etc.) that
will need to be organized for use by both individual humans and
networks of machines.  The scholium system is part of the HDM project
because of these organizational needs -- \emph{and} (in particular) it
is being designed in such a way that it should be able to satisfy the
``AI needs'' of the project.

The revolution will be computerized -- and it will be total.


*** Application of the scholium principle for HDM                  :noexport:

We should talk about encoding different types of objects in the system
and showing their relationships using typed links; also about
assembling reports via transclusion, and so on and so forth.  We
should also show how this system can be used as a stand-in for more
``traditional'' KRR systems (SNePs, KM), and how reasoning modules can
be implemented for the system.  But this is pretty advanced stuff, and
it is going to be a little while until we get to it.

In the mean time, we have various fun things (a little music and even
less Go), and we can think about the relationships to Dirk Gently and
so on and so forth.


*** Template utilities as an example                               :noexport:

Ray was working on a set of template utilities that could be encoded
as a scholium-based document.


*** Overview of Arxana as an example                               :noexport:

It might be nice to create a simplified version of the current
document that would deal with the core functions and ideas only.  This
would presumably help people learn how to work with the system.


\subsubsection{Managing the contents of a mathematical dictionary}

*** Importing the APM-$Xi$                                         :noexport:

See [[id:import-apmxi]] (currently the main function in this section,
although we may come up with some additional functions later on).
Actually, we should probably also import the APM, however, I'm not
completely sure I can get copyright waivers for the APM's content.  I
hope so; I should investigate that.  If I can get written permission,
then I suppose we should put APM into the HDM's archive along with
APM-$\Xi$.


*** Large-scale structure of APM and APM-$\Xi$                     :noexport:

We have some words and phrases.  These phrases come up in the APM in
various places.  Each phrase has a list of problems that it is
associated with.  It also has a list of definitions that it is
associated with.  For APM, we would want the relevant definitions to
appear as attached scholia.  For APM-$\Xi$, we presumably want a
namespace for each phrase, into which we put each of the definitions
as its own article, together with the specially-designated list of
associated problems.  Here it seems like we have the opportunity to
use links with different types.  (Maybe we would just attach the list
of associated problems to the namespace as a whole.)  To parse the
document this far, the first thing to do is to break it into sections,
then parse each of these sections into lists of problems.


*** Types for the APM-$\Xi$

We keep track of the sections, entries, and stubs that belong to
APM-$\Xi$ as special types.


#+BEGIN_SRC elisp
(add-to-list 'modified-type-labels '(apmxi-section . apmxi-section) t)
(add-to-list 'modified-type-labels '(apmxi-entry . apmxi-entry) t)
(add-to-list 'modified-type-labels '(apmxi-stub . apmxi-stub) t)
#+END_SRC

*** On `make-apmxi-sections-into-articles'

This function makes every section in the APM-$\Xi$ into its own
article.  The list of these articles is recorded on the article
`apmxi-section'.


#+BEGIN_SRC elisp
(defun make-apmxi-sections-into-articles ()
  (save-window-excursion
    (find-file "../p2/Xi.tex")
    (goto-char (point-min))
    (while (re-search-forward "^\\\\section{{ \\(.+\\)}} " nil t)
      (let ((article-name (match-string-no-properties 1))
            (beg (point))
            (end (save-excursion (search-forward "\\section" nil t)
                                 (match-beginning 0))))
        (when end
          (scholium article-name
                    (buffer-substring-no-properties beg end)
                    nil
                    'apmxi-section))))))
#+END_SRC

*** On `chunk-out-apmxi-definitions'
:PROPERTIES:
:LATEX_LABEL: chunk-out-apmxi-definitions
:ID: chunk-out-apmxi-definitions
:END:

Apparently some of the terms in APM-$\Xi$ were defined in multiple
sections.  At least, \emph{stubs} appear in multiple places.  This
should presumably create multiple definitions when multiple
definitions are given, or get rid of stub-like definitions, or
something.

Note that the way this is set up, even sections that contain only
stubs can also contain references to the real articles, when they
exist -- this means that the real articles may appear in several
listings, which I think is as it should be.


#+BEGIN_SRC elisp
(defun chunk-out-apmxi-definitions ()
  (map-label (lambda (name)
               (with-temp-buffer
                 ;; this ensures that sexps are defined properly
                 (latex-mode)
                 (let ((topic (get-article name))
                       contents)
                   (insert (scholium-text topic))
                   (goto-char (point-min))
                   (while (re-search-forward "^(" nil t)
                     (let* ((beg (match-beginning 0))
                            (title-beg (match-end 0))
                            (title-end (progn (goto-char beg)
                                              (forward-sexp)
                                              (1- (point))))
                            (stub-p (looking-at " *$"))
                            (title (buffer-substring-no-properties
                                    title-beg
                                    title-end))
                            (end (save-excursion
                                   (search-forward-regexp "^$")))
                            (possible-previous (get-article title)))
                       (when (or (not possible-previous)
                                 (typedata-includes (scholium-type
                                                     possible-previous)
                                                    'apmxi-stub))
                         (scholium title
                                   (buffer-substring-no-properties
                                    beg
                                    end)
                                   `((,name parent))
                                   (if stub-p
                                       '(apmxi-stub apmxi-entry)
                                     'apmxi-entry)))
                       (setq contents (cons title contents))))
                   (scholium name
                             contents
                             nil
                             '(apmxi-section label)))))
             'apmxi-section))
#+END_SRC

*** On `import-apmxi'
:PROPERTIES:
:LATEX_LABEL: import-apmxi
:ID: import-apmxi
:END:

This function puts into play all of the other functions developed
above, to fully process the APM-$\Xi$ and get it nicely situated in
the scholium system.


#+BEGIN_SRC elisp
(defun import-apmxi ()
  (make-apmxi-sections-into-articles)
  (chunk-out-apmxi-definitions))
#+END_SRC

*** Special reference types                                        :noexport:
:PROPERTIES:
:LATEX_LABEL: special-reference-types
:ID: special-reference-types
:END:

In the mathematics domain, would be handy to have ``related to'',
``depends on'', ``proof of'' and ``prerequisite for understanding''
reference sub-types.  It is easy enough to create a subtype -- just
add the secondary category to the \inp{type} variable along with the
``reference'' datum.  Special types of references are one of the key
semantic network-like features of the scholium system (see also Note
[[id:type-creation]]).  Maybe the reference-creating facility should
provide an optional second argument for specifying reference sub-type.


*** Selecting all APM-$\Xi$ stubs

If you want to look at a list of all stubs in the APM-$\Xi$, run this code:
#+BEGIN_SRC elisp :tangle no
(article-menu-list-articles-matching-predicate 
 (lambda (name)
   (when (typedata-includes (scholium-type (get-article name))
                            'apmxi-stub)
     t)))
#+END_SRC
(See  Note [[id:article-menu-list-articles-matching-predicate]].)


*** Screening out APM-$\Xi$ stubs
:PROPERTIES:
:LATEX_LABEL: apmxi-stub-processing
:ID: apmxi-stub-processing
:END:

If you want to screen \emph{out} the stubs in the APM-$\Xi$, run
#+BEGIN_SRC elisp :tangle no
(display-difference-of-labels 'apmxi-entry 'apmxi-stub)
#+END_SRC
(see Note [[id:display-difference-of-labels]]).  Of course,
eventually we're going to want to do some more processing
to make the stubs into useful things.


\subsubsection{Facilitate collaboration between HDM authors}

*** Use a simple scheme                                            :noexport:

The collaboration scheme is described in Section
[[id:multiuser-cooperation]].  I might try to make that version
``general'' and in this section implement some ``specifics''.


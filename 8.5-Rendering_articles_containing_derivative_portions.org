** Rendering articles containing derivative portions
:PROPERTIES:
:LATEX_LABEL: rendering-derivatives
:ID: rendering-derivatives
:END:

*** Cluded parts
:PROPERTIES:
:LATEX_LABEL: cluded-parts
:ID: cluded-parts
:END:

These variables will be modified by `unwind-derivatives' to contain a
list of the transcluded sections of a rendered document.
Specifically, the items on the list are of the form
#+BEGIN_SRC elisp :tangle no
(<object> <beg> <end>)
#+END_SRC
where `object' is a link to the thing being transcluded,
and `beg' and `end' represent the beginning and end positions
of the image of the object under this particular clusion, in
the rendered version of the cluding article.

This information will subsequently be used as part of the markup
routine, where it will allow us to add appropriate text properties
indicating cluded regions.

(It may be advantageous to assume that we can always use a
\emph{cached} version of the article we're cluding.  This could be a
help when the article itself is derivative.)


#+BEGIN_SRC elisp
(defvar transcluded-parts nil)
(defvar identified-parts nil)
(defvar included-parts nil)
#+END_SRC

*** On `unwind-derivatives'
:PROPERTIES:
:LATEX_LABEL: unwind-derivatives
:ID: unwind-derivatives
:END:

This will run within the scope of `sch-plain-text', and make recursive
calls to `sch-plain-text' as needed, to turn cluded texts into strings
suitable for display.   Specifically, a simple test has been added to
`sch-plain-text-hook' that causes `unwind-derivatives' to run whenever
rendering an article whose \inp{text} field is a list that begins with
the token `twd' (see Note
[[id:adding-unwind-derivatives-to-rendering-pathway]]).

The boundaries of the cluded regions are recorded for subsequent
use, as described in Note [[id:cluded-parts]].

The contents of the `` *Unwinding Derivatives*'' buffer needs to be
cleared out before this function first runs for it to return the
correct string.  (Um, is this all going to work out properly if we
enter into the fully recursive run of `unwind-derivatives'?)  That is
accomplished by modifications to `scholia-display-pre-update-hook';
see Note [[id:prep-for-rendering-text-with-derivatives]].

The need for (extensive) recursion in this function could be done away
with if we cached a \emph{rendered} version of every article that used
clusions somewhere where it could be found by other articles that
clude from it.

However, if we are going to have things like references from cluded
documents appear in the assembled document, or (in general) if we want
to have access to the scholia attached to the cluded regions (Note
[[id:fancy-derivatives]]), we'll either have to pre-render the
derivative components, or come up with some scheme for mapping the
positions of markup associated with these things into suitable
positions in the assembled document.

Note that at present markup will be added by
`add-inclusion-and-transclusion-markup' (Note
[[id:add-inclusion-and-transclusion-markup]]).


#+BEGIN_SRC elisp
(defun unwind-derivatives ()
  (set-buffer (get-buffer-create " *Unwinding Derivatives*"))
  (dolist (elt (cdr text))
    (if (stringp elt)
        (insert elt)
      (let (object)
        (cond
         ((eq (car elt) 'transclude)
          (setq object (cdr elt))
          (setq transcluded-parts (cons `(,object ,(point))
                                        transcluded-parts)))
         ((eq (car elt) 'identify)
          (setq object (cdr elt))
          (setq identified-parts (cons `(,object ,(point))
                                       identified-parts)))
         (t
          (setq object elt)))
        (insert (sch-plain-text object))
        (cond
         ((eq (car elt) 'transclude)
          (setcdr (cdar transcluded-parts) `(,(point))))
         ((eq (car elt) 'ident)
          (setcdr (cdar identified-parts) `(,(point))))))))
  (setq ret (buffer-string)))
#+END_SRC

*** Preparation for rendering text with derivative components
:PROPERTIES:
:LATEX_LABEL: prep-for-rendering-text-with-derivatives
:ID: prep-for-rendering-text-with-derivatives
:END:

We need to zap `transcluded-parts', `identified-parts' and the
contents of the buffer in which derivatives are to be unwound before
`unwinding-derivatives' runs.


#+BEGIN_SRC elisp
(defun prep-for-rendering-text-with-derivative-components ()
  (setq transcluded-parts nil
        identified-parts nil
        included-parts nil)
  (save-excursion
    (set-buffer (get-buffer-create
                 " *Unwinding Derivatives*"))
    (erase-buffer)))

(add-hook 'scholia-display-pre-update-hook
          'prep-for-rendering-text-with-derivative-components)
#+END_SRC

*** Adding `unwind-derivatives' to the rendering pathway
:PROPERTIES:
:LATEX_LABEL: adding-unwind-derivatives-to-rendering-pathway
:ID: adding-unwind-derivatives-to-rendering-pathway
:END:

We make a call to `unwind-derivatives' in `sch-plain-text' when the
appropriate criterion is satisifed (see Note
[[id:sch-plain-text-hook]]).  The relevant criterion is that we are
rendering an object (i.e., something that gives us an article) whose
\inp{text} field is a list that begins with the token `twd'.

(The complex wording here has to do with the matter that we sometimes
render objects that aren't articles, e.g. a link to a certain passage.
We will have to make sure that the criterion used here is correct for
those cases as well as the easy case of rendering a whole article.
See Note [[id:sch-plain-text]] for details.)


#+BEGIN_SRC elisp
(add-hook 'sch-plain-text-hook
          '(lambda ()
             (when (and (listp text) (eq (car text) 'twd))
               (unwind-derivatives))))
#+END_SRC

*** On `add-inclusion-and-transclusion-markup'
:PROPERTIES:
:LATEX_LABEL: add-inclusion-and-transclusion-markup
:ID: add-inclusion-and-transclusion-markup
:END:

For identifications, this should add the same sort of faked-up markup
that we added with `insert-identification-at-point' (Note
[[id:insert-identification-at-point]]).

It might be kind of cute to put some ``corners'' in, showing
where the included text begins and ends (see Note [[id:monochrome]]).

These modifications to `mark-things-up' appear to be desired
unconditionally (unlike e.g. the modifications to `sch-plain-text' we
just saw in Note
[[id:adding-unwind-derivatives-to-rendering-pathway]]).  So we just put
`add-inclusion-and-transclusion-markup' directly on the
`mark-things-up-hook' (cf. Note [[id:mark-things-up-hook]]).


#+BEGIN_SRC elisp
(defun add-inclusion-and-transclusion-markup ()
  (save-excursion
    (set-buffer-to-rendering-target-buffer)
    (dolist (elt identified-parts)
      (add-to-scholia-property-within-region
       (second elt)
       (third elt)
       `(identifies-with ,(first elt))))
    ;; this may end up having to be considerably more complicated
    (dolist (elt transcluded-parts)
      (add-to-scholia-property-within-region
       (second elt)
       (third elt)
       `(transclusion-of ,(first elt))))))

(add-hook 'mark-things-up-hook 'add-inclusion-and-transclusion-markup)
#+END_SRC

*** Should identifications be unwound recursively?                 :noexport:

I think they won't need to be; if someone asks to identify a region
with some other region that also contains identification, then you
might expect that we'd need to follow through to identify the
indicated portion of the new article with that other earlier source.
That's probably the right way to do things; however, I suppose we
could do something simpler in the mean time, since if we don't write
documents that depend on documents with identifications in them, the
case we've been discussing won't come up!  Besides, it would probably
be instructive to have on hand a non-recursive function that does a
similar job to the function written for transclusions.

(Note that labels can sometimes be used to limit complexity of certain
operations, see Note [[id:cost-of-maintaining-labels]].


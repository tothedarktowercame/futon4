* Logical model

Arxana manages a single logical hypergraph. The core primitives are:

- Nema :: Universal node record with stable id, labels, optional endpoints, and payload.
- Article :: A nema labeled :label/article, holding text and core metadata.
- Metadata scholium :: A nema paired 1–1 with an article, caching backlinks, labels, and indexes.
- Event (hyperedge) :: A nema representing a relation or annotation, with :hx/type and N endpoints.
- Plexus :: A nema that names a working set or profile and carries configuration.

Classic Arxana entities, relations, and scholia embed cleanly:

- Entities → article nemas with derived identifiers.
- Relations → 2-end events (:hx/*) between nemas.
- Scholia → events and/or metadata nemas attached to articles.
- Inclusion / clusion / provenance → multi-end events with appropriate :role values.

** Storage substrates

All storage backends implement the same logical model.

*** In-memory storage of one form or another
- Historically, nemas, articles, events, and plexuses were held in hash tables / HONEY-style networks.
- This is the reference representation; other substrates hydrate/dehydrate it.

*** Document-based substrates
- Literate sources (e.g., LaTeX, Org, Markdown, TEI) could be parsed into nemas and events.
- Arxana can — in principle and, increasingly, in practice — both read *and write* these formats, keeping ids and links stable across round-trips.

*** Historical: Relational substrate
- Common Lisp provided a bridge to SQL that encode relations in tables.
- Semantics are those of a structured triple store: subjects, predicates, objects, plus spans and provenance.
- Suitable for durability, multi-user access, and heavy queries.

*** Possible future: Triple-store substrate
- Direct RDF/quad representation of the same model — not implemented but it could be if we want it.
- Again, we could in principle read and write external knowledge graphs (and integrate SPARQL tooling).

*** Current reality: EAV in Clojure (Datascript + XTDB)

Instead of going the triple route, all storage backends in the current
‘beta’ generation converge on an open **entity–attribute–value (EAV)**
model.  Each record—whether an article, event, or plexus—is
represented as a set of attribute–value pairs attached to a unique
entity id.  This design keeps the schema *open*, so new attributes or
link types can appear dynamically without migration.

The canonical implementation uses:

- **Datascript** for in-memory, client-side operation.  
  - Pure Clojure; lightweight and immutable.  
  - Supports live queries, undo/redo, and fast incremental updates.  
  - Ideal for interactive use inside Emacs or JVM clients.

- **XTDB** for durable, time-traveling storage.  
  - Schemaless documents mirror the same EAV keys verbatim.  
  - Transactions are append-only; every version of the graph is queryable.  
  - Perfect for provenance, journaling, and long-term archives.

Together these give Arxana an *open-schema substrate*: a graph database where nemas, events, and
plexuses are all entities, and attributes such as `:hx/type`, `:article/text`, or `:plexus/members`
are just first-class keys.  Queries can run over the generic EAV view, or use higher-level helpers
that expose structured projections (e.g., “articles”, “hyperedges”, “plexuses”).

> **Design posture:** Start open (EAV); specialize only when scale or semantics demand it.  
> Structured views—relational tables, triple stores, materialized indexes—can be layered on
> demand without altering the underlying data model.

This approach keeps computational properties stable: query complexity
and transaction semantics stay identical whether data are viewed as
triples, hash maps, or SQL rows.  It also makes cross-substrate
replication trivial: each backend stores the same `(entity attribute
value)` facts, differing only in query language and persistence model.

** Emacs client (Arxana classic)

The Emacs Lisp implementation in this repository provides:

- Interactive creation and editing of articles and scholia.
- Browsing modes over the in-memory graph.
- Operations for inclusion, derivation, and provenance as events.
- Import/export for specific document formats (historically LaTeX/Org).

Internally, it maintains the logical model in memory and (optionally)
syncs with external substrates (files, SQL backend).
* Preface                                                          :noexport:

\title{\emph{Arxana}}

\author{Joseph Corneli\thanks{The content of this file is available
    under your choice of the GNU Free Documentation License (FDL) and
    the GNU General Public License (GPL). If the FDL is selected, be
    advised that this document has no Invariant Sections, no
    Front-Cover Texts, and and no Back-Cover Texts.}}

\date{\today\ (draft)}

\maketitle

# %% The system's design draws on ideas from Ted Nelson's ``Project
# %% Xanadu'', combining them with the ``semantic network'' strategy
# %% from artificial intelligence.

# \abstract{A scholia-based document model for commons-based peer
#   production informs an advanced Emacs-based hypertext system.}

# %% 1. Revise links and backlinks.

# %% 2. Put together an appendix with simple specs.  (Done for the
# %% basic objects; not necessarily with all of the operations that
# %% effect these objects.)

# %% 3. After that, there are many user-friendly features that one could
# %% tackle.  Additional history lists for multi-dimensional browsing,
# %% various useful consistency-maintaining features (not unlike
# %% mascons!), versioning support, and so on.  Presumably many of these
# %% items can be left for other people to work on after the release.

# %% 4. I still haven't completely worked out the theory of
# %% "transclusion" (live-updating quotes) to my satisfaction, and this
# %% (and its bi-directional variant, "identification") is the "killer
# %% ap" I'd like to get into the software before I release it.

# \tableofcontents

# \newpage

This document may look like a paper, but it is also runable code.
The code implements a hypertext system.  You can use this
hypertext system to browse and edit the code and documentation
that describes the system itself.

To do that, when viewing the document's source code with Emacs,
evaluate this form (in place). *To restore*

# #+BEGIN_SRC lisp :tangle no
# (progn 
# (require 'cl)
# (save-excursion
#   (let ((beg (search-forward "\\begin{verbatim}"))
#         (end (progn (search-forward "\\end{verbatim}")
#                     (match-beginning 0))))
#     (eval-region beg end)
#     (lit-eval)
#   (browse-scholium-system))))
# #+END_SRC

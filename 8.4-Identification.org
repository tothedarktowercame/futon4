** Identification
:PROPERTIES:
:LATEX_LABEL: identification
:ID: identification
:END:

*** Identification from a design perspective                       :noexport:

Basically, identification is ``like transclusion for editing'': we
have direct write access to the original, as well as read access.
Identification is more powerful than transclusion; and, obviously, one
can only objects that one has permission to modify can be edited
through identification.

Unlike inclusion and transclusion, identified copies should be marked
up with uniform, sticky, text properties.  (The user
should be careful that text from the current buffer that wasn't
intended to be part of the identified copy doesn't get stuck
to the identification by mistake!)


*** The identification algorithm                                   :noexport:
:PROPERTIES:
:LATEX_LABEL: the-identification-algorithm
:ID: the-identification-algorithm
:END:

The object that we're identifying with should be inserted and marked
up with an `identifies-with' text property at render time.  Any
markup of this text (e.g. processing of transclusions or
identifications within the text) should be carried out just as if
the source was being edited directly.  At commit time, text bearing
the `identifies-with' property should be compared with the object
it derives from.  If it has been changed, a new version of that
object should be committed.  As for the derivative article, an
internal representation similar to the one described in Note
[[id:format-of-text-with-derivatives]] should be stored.


*** Precedent for identification                                   :noexport:
:PROPERTIES:
:LATEX_LABEL: precedent-for-identification
:ID: precedent-for-identification
:END:

The emacs package ``all.el'' is abstractly
similar\footnote{http://ftp.gnu.org/savannah/files/auctex/attic/auctex/all.el}, as
is the idea of shared list structure (Note
[[id:including-transcluding-and-lisp]]).


*** Identification use case                                        :noexport:
:PROPERTIES:
:LATEX_LABEL: identification-use-case
:ID: identification-use-case
:END:

Just for instance, one could use this style of transclusion to render
two articles into the same buffer and cut and paste portions of each
into the other, and have the changes mapped back appropriately.


*** On `insert-identification-at-point'
:PROPERTIES:
:LATEX_LABEL: insert-identification-at-point
:ID: insert-identification-at-point
:END:

This is similar to Note [[id:include-article]].  For now,
I'm just going to write it so that you can do identification
with other articles; later, more general objects will be allowed
(Note [[id:allowable-sources]]).

We don't actually need to create any scholia,
but we can use the scholia property.  It should
be exactly the same when we render articles that already had
identifications recorded internally.


#+BEGIN_SRC elisp
(defun insert-identification-at-point (article-name)
  (interactive (list (read-article-name)))
  (let ((beg (point)))
    (insert (sch-plain-text article-name))
    (add-to-scholia-property-within-region
     beg
     (point)
     ;; there aren't any links, so there's no proper linkid
     `(identifies-with ,article-name))))
#+END_SRC

*** On `propagate-changes-to-identification-source'

This runs within the context of
`store-updates-from-identification-images' (when it runs).
Its purpose is to copy changes from the recipient article
in an identification to the source article.


#+BEGIN_SRC elisp
(defun propagate-changes-to-identification-source ()
  (when (not (equal (buffer-substring-no-properties
                     (second (car identifications))
                     (third (car identifications)))
                    (sch-plain-text
                      (second (caar identifications)))))
    (let ((source (get-article (second (caar identifications)))))
      ;; compare `commit-edits'.  When we actually do
      ;; document versions, this should update the version
      ;; number and any other metadata about how this
      ;; version was created that we get interested in.
      (scholium (second (caar identifications))
                ;; this is bad, since it is storing
                ;; the rendered text, whereas we should of course
                ;; be storing the formatted-for-internal-storage
                ;; text.  But I suppose this is OK for testing
                ;; purposes (wherein we'll only have one level
                ;; of identification).
                (buffer-substring-no-properties
                 (second (car identifications))
                 (third (car identifications)))
                (scholium-about old-contents)
                (scholium-type old-contents)
                (scholium-bookkeeping old-contents)))))
#+END_SRC

*** On `store-updates-from-identification-images'

This function will run within the scope of `commit-edits' via the
`commit-edits-hook' (see Note [[id:commit-edits-hook]]).
We must first identify the identifications (as it were), which we
do by examining the contents of the `adjusted-markup' list.
Then, once these are found, we form a suitable internal
representation.

Everything \emph{between} identifications should get stored
as plain text, whereas the identifications themselves should
be stored as tags.

In addition to adjusting the internal representation of
the article with the identification commands, we should
adjust the text of the source articles, if necessary.
(For simplicity's sake, we could just store updated text
unconditionally for now.)

Concerning the use of `buffer-substring-no-properties':
zapping the properties is questionable, if
we're planning to commit these various derivative
properties serially.  Will have to think about this later.
I think that since this thing is being used to build
internal representations, zapping text properties
might actually be OK.  But I'm not sure.

For clarification on the use of `adjusted-text', see comments on
`commit-edits'.

Note that the only relevant option besides ``less'' is ``equal''
in the `if' here.


#+BEGIN_SRC elisp
(defun store-updates-from-identification-images ()
  (let ((identifications (remove-if
                          (lambda (elt)
                            (not (eq (caar elt) 'identifies-with)))
                          adjusted-markup))
        (pt 1)
        formatted-contents)
    (while identifications
      (if (< pt (second (car identifications)))
          (setq formatted-contents
                (append
                 formatted-contents
                 (list (buffer-substring-no-properties
                        pt (second (car identifications)))
                       `(ident ,(second (caar identifications)))))
                pt (third (car identifications)))
        (setq formatted-contents
              (append
               formatted-contents
               (list `(ident ,(second (caar identifications)))))
              pt (third (car identifications))))
;      (propagate-changes-to-identification-source)
      (setq identifications (cdr identifications)))
    (when formatted-contents
      (when (< pt (point-max))
        (setq formatted-contents
              (append
               formatted-contents
               (list (buffer-substring-no-properties
                      pt (point-max))))))
      (setq adjusted-text (list 'twd formatted-contents)))))

(add-hook 'commit-edits-hook 'store-updates-from-identification-images)
#+END_SRC

*** Working identifications into the rendering pathway             :noexport:

We'll need to modify rendering to look at the ``ident'' objects
in the document's representation, and mark these up as identifications.

The way identifications and transclusions are expanded will be
similar.  (See section [[id:rendering-derivatives]] for more on this.)


*** Visible identification markup                                  :noexport:

It would be handy to optionally have overlays showing which regions
are marked up as identifications, and also to have scholia that say
what they are identified to.  (This seems like a good example of a
situation in which it would be be best if the scholia only showed up
when the regions they applied to appeared onscreen.)


*** Cutting and pasting identifications in multi-user environment  :noexport:

One should be careful that passages that have been marked up as
identifications, which are copied and pasted into other articles which
don't have the same permission-set associated with them, are no longer
treated as identifications.  Perhaps some identifying information
(`name-of-current-article' being a likely candidate) can be added to
the text property added by `insert-identification-at-point', and some
additional checks put into the commit phase.


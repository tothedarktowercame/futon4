** Finding revised `about' data by parsing text properties
:PROPERTIES:
:LATEX_LABEL: parsing
:ID: parsing
:END:

*** Mini-overview of parsing text properties                       :noexport:

This section concerns the topic of finding changes to \inp{about} data
of scholia that are induced by changes to the \inp{text} of an article
that they are \inp{about}.


*** Overview of parsing text-properties                            :noexport:
:PROPERTIES:
:LATEX_LABEL: overview-of-parsing-text-properties
:ID: overview-of-parsing-text-properties
:END:

By finding the places in a marked-up buffer where the `scholia'
property changes and examining its value before and after the change
point, the beginning and end of each marked region can be found.  (See
the description of this property in Note [[id:the-scholia-property]].)

More specifically: (1) we must find all the places where the `scholia'
property changes; (2) then figure out what was new or what went away
at each change point; (3) and update a list of beginnings and endings
in the approximate form of an \inp{about} list.  This is a first step
in the lengthier process of committing edits (see Section
[[id:committing]]).


*** Indicator functions                                            :noexport:
:PROPERTIES:
:LATEX_LABEL: indicator-functions
:ID: indicator-functions
:END:

We can have marked regions that overlap to any depth; overlapping
scholia can also have non-trivial non-overlapping regions.

In a mathematical abstraction, we might see scholia like
$\indicator{[0,3]}$, $\chi_{[1,10]}'$, $\chi_{[2,5]}''$,
$\chi_{[8,9]}'''$ (as pictured in Figure
# [[id:Simulation-with-indicator-functions]]).
We could even have
different regions from the same scholium overlap.

It would be nice to be able to indicate arbitrary subsets of the
\inp{text} that we're presented with.  The actual set of available
indicators is a $\sigma$-algebra, if I remember correctly.

For LISP code, picking out arbitrary bits of list structure would be
handy (see Note [[id:including-transcluding-and-lisp]]).


*** On `scholia-property-at-changepoints'

This returns a list of pairs; points where
the `scholia' property changes paired with the value of the `scholia'
property at those points.

\begin{figure}
\begin{center}
%% in LaTeX, ascii art is a little bit trickier than usual
{\tt
\begin{tabular}{l}
\ \ \ \ \ \ \ \ -- \\
\ \ ------ \\
\ ------------------  \\
------  \\
1234567890
\end{tabular}}
\end{center}
\caption{Markup simulated with indicator functions \label{Simulation-with-indicator-functions}}
\end{figure}


#+BEGIN_SRC elisp
(defun scholia-property-at-changepoints ()
  (let ((next-change-point (point-min))
        change-points)
    (while next-change-point
      (setq change-points (cons (list next-change-point
                                      (get-text-property
                                       next-change-point
                                       'scholia)) 
                                change-points))
      (setq next-change-point (next-single-property-change+predicate
                               next-change-point
                               'scholia
                               'equal)))
    (when (not (null (get-text-property
                      (caar change-points)
                      'scholia)))
      (setq change-points (cons (point-max) change-points)))
    (reverse change-points)))
#+END_SRC

*** On `detect-scholia-structure'
:PROPERTIES:
:LATEX_LABEL: detect-scholia-structure
:ID: detect-scholia-structure
:END:

This function says which passages of the current article have been
marked up with which scholia.  Typically, this function will be run
after editing, to recover the modified markup information and
propagate it to attached scholia (see Section [[id:committing]]).

The way the function works is as follows.  At each of the change
points, we find the the annotations that have either just appeared or
just disappeared, by using the `set-difference' function to compare
the value of the `scholia' property at the \emph{upcoming} change
point with the value at the \emph{current} one.  We then sort the
elements of this difference into ``opening'' and ``closing'' sets
based on whether they are present at the \emph{upcoming} change point,
or the \emph{current} one.  In order to ensure that there is an
adequate basis for comparison in all cases, exogenous points at
``$-\infty$'' and ``$\infty$'' are introduced, with no scholia
attached to them.

Every ``opening'' element corresponds to some as-yet-unseen marked-up
region; when encountering such an item, we add a term to the return
value that looks like ``(VALUE BEG)'' where VALUE and BEG are,
respectively
\begin{itemize}
\item the value of the `scholia' property -- which will be the
 name of a scholium together with a unique link identifier, as
 described in Note [[id:the-scholia-property]];
\item and the point where this link starts to attach to the current
 article.
\end{itemize}
Similarly, every ``closing'' element corresponds to the end of some
already-seen marked-up region.  When encountering such elements, we
modify the corresponding previously added term in the return value to
read ``(VALUE BEG END)'', END here being the point where the link in
question stops attaching to the current document.

Note that since `scholia-property-at-changepoints' gives us the values
in increasing order, new ``opening'' items are encountered and added
to the list in increasing order as well.  This property is important
for later.


#+BEGIN_SRC elisp
(defun detect-scholia-structure ()
  (let ((begs-and-ends
         (cons '(-infinity nil)
               (append
                (scholia-property-at-changepoints)
                (list '(infinity nil)))))
        marked-regions)
    (while (> (length begs-and-ends) 1)
      (let ((difference (set-difference (second
                                         (first begs-and-ends))
                                        (second
                                         (second begs-and-ends))))
            opening
            closing)
        (when difference
          (dolist (elt difference)
            (if (member elt (second (second begs-and-ends)))
                (setq opening (cons elt opening))
              (setq closing (cons elt closing))))
          (dolist (elt opening)
            (setq marked-regions
                  (add-to-or-start-list
                   marked-regions
                   `(,elt ,(first (second begs-and-ends))))))
          (dolist (elt closing)
            (let ((found (member-if (lambda (pass)
                                      (equal (first pass) elt))
                                    marked-regions)))
              (setcdr (cdr (car found))
                      (list (first (second begs-and-ends)))))))
        (setq begs-and-ends (cdr begs-and-ends))))
    marked-regions))
#+END_SRC

*** New scholia added while editing                                :noexport:

I don't \emph{think} that new scholia added while editing will need to
be treated any differently during the reparsing process from scholia
that were created before editing started.  Scholium-creation should be
a self-contained process that gets everything stored properly; the
only special concern is that text properties would need to be added to
the buffer that is being edited, but that's obvious enough.


*** Finding changes in scholia about the whole article             :noexport:
:PROPERTIES:
:LATEX_LABEL: changes-in-scholia-about-whole-article
:ID: changes-in-scholia-about-whole-article
:END:

Presumably this data will be stored in a relevant metadata article,
rather than in text properties (contrast Aaron's picture).  We
probably won't have to do reparsing to handle scholia like this,
\emph{but we will have to do something}.


*** Make `scholia' a variable?                                     :noexport:

It would be easy enough to make `scholia' as used above
into a variable instead of hard code, so that we could read from
another text property instead.  Probably we would want to complement
this with similar changes to the code that adds text properties!


** Modifying the database                                          :noexport:

#+BEGIN_SRC lisp
;; database.lisp
(in-package arxana)
(locally-enable-sql-reader-syntax)
#+END_SRC

\subsection*{Processing strings}

*** On `string-to-id'

Return the id of `text', if present, otherwise nil.

There was a segmentation fault with clisp here at one
point, maybe because I hadn't gotten the clsql sql reader
syntax loaded up properly.  Note that calling the code
without the function wrapper did not produce the same
segfault.


#+BEGIN_SRC lisp
;; database.lisp
(defun string-to-id (text)
  (select [id]
          :from [strings]
          :where [= [text] text]))
#+END_SRC

*** On `add-string'
:PROPERTIES:
:LATEX_LABEL: add-string
:ID: add-string
:END:

Add the argument `text' to the list of strings.  If the string
is successfully created, its coordinates are returned.
Otherwise, and in particular, if the request was to create
a duplicate, nil is returned.

Should this give a message ``Adding \meta{text} to the
strings table'' when the string is added by an indirecto
function call, such as through `massage'?
(Note [[id:massage]].)


#+BEGIN_SRC lisp
;; database.lisp
(defun add-string (text)
  (handler-case
   (progn (insert :into [strings]
                  :attributes '(text)
                  :values `(,text))
          `(1 ,(string-to-id text)))
   (sql-database-data-error ()
     (warn "\"~a\" already exists."
           text))))
#+END_SRC

*** Error handling bug

The function `add-string' (Note [[id:add-string]]) exhibits
the first of several error handling calls designed to
ensure uniqueness (Note [[id:unique-things]]).
Experimentally, this works, but I'm observing that, at
least sometimes, if the user tries to add an item that's
already present in the database, the index tied to the
associated table increases even though the item isn't
added.  This is annoying.  I haven't checked whether this
happens on all possible installations of the underlying
software.


\subsection*{Parsing general input}

*** On `massage'
:PROPERTIES:
:LATEX_LABEL: massage
:ID: massage
:END:

User input to functions like `add-triple' and so on and so
forth can be strings, integers (which the function
``serializes'' as the string versions of themselves), or
as \emph{coordinates} -- lists of the form (code ref).
This function converts all of these input forms into the
last one!  It takes an optional argument `addstr' which,
if supplied, says to add string data to the database if it
wasn't there already.


#+BEGIN_SRC lisp
;; database.lisp
(defun massage (data &optional addstr)
  (cond
   ((integerp data)
    (massage (format nil "~a" data) addstr))
   ((stringp data)
    (let ((id (string-to-id data)))
      (if id
          (list 0 id)
          (when addstr
            (add-string data)))))
   ((and (listp data)
         (equal (length data) 2))
    data)
   (t nil)))
#+END_SRC


\subsection*{Processing triples}

*** On `triple-to-id'

Return the id of the triple (beg mid end),
if present, otherwise nil.


#+BEGIN_SRC lisp
;; database.lisp
(defun triple-to-id (beg mid end)
  (let ((b (massage beg))
        (m (massage mid))
        (e (massage end)))
    (select [id]
            :from [triples]
            :where [and [= [code1] (first b)]
                        [= [ref1] (second b)]
                        [= [code2] (first m)]
                        [= [ref2] (second m)]
                        [= [code3] (first e)]
                        [= [ref3] (second e)]])))
#+END_SRC

*** On `add-triple'
:PROPERTIES:
:LATEX_LABEL: add-triple
:ID: add-triple
:END:

Elements of triples are parsed by `massage'
(Note [[id:massage]]).  If the triple
is successfully created, its coordinates are returned.
Otherwise, and in particular, if the request was to create
a duplicate, nil is returned.


#+BEGIN_SRC lisp
;; database.lisp
(defun add-triple (beg mid end)
  "Add a triple comprised of BEG MID and END."
  (let ((b (massage beg t))
        (m (massage mid t))
        (e (massage end t)))
    (when (and b m e)
      (handler-case
       (progn
         (insert-records
          :into [triples] :attributes '(code1 ref1
                                        code2 ref2
                                        code3 ref3)
          :values `(,(first b) ,(second b)
                    ,(first m) ,(second m)
                    ,(first e) ,(second e)))
         `(2 ,(triple-to-id b m e)))
       (sql-database-data-error ()
         (warn "\"~a\" already entered as [~a ~a ~a]."
               (list beg mid end) b m e))))))
#+END_SRC

\subsection*{Processing theories} \label{processing-theories}

*** Things to do with theories

For the record, we want to be able to create a theory, add
elements to that theory, remove or change elements in the
theory, and, for convenience, zap everything in a theory.
Perhaps we will also want functions to remove the tables
associated with a theory as well, swap the position of two
theories, or change the name of a theory.  We will also
want to be able to export and import theories, so they can
be ``beamed'' between installations.  At appropriate
places in the Emacs interface, we'll need to set
`*write-to-heading*' and `*read-from-heading*'.


*** What can go in a theory
:PROPERTIES:
:LATEX_LABEL: what-can-go-in
:ID: what-can-go-in
:END:

Notice that there is no rule that says that a triple or
place that's part of a theory needs to point only at
strings that are in the same theory.


*** On `list-to-id'

Return the id of the theory with given `heading', if present,
otherwise, nil.


#+BEGIN_SRC lisp
;; database.lisp
(defun list-to-id (heading)
  (let ((string-id (string-to-id heading)))
    (select [id]
            :from [lists]
            :where [= [heading] string-id])))
#+END_SRC

*** On `add-theory'
:PROPERTIES:
:LATEX_LABEL: add-theory
:ID: add-theory
:END:

Add a theory to the theories table, and all the new
dimensions of the frame that comprise this theory.
(Theories have names that are strings -- it seems a
little funny to always have to translate submitted
strings to ids for lookup, but this is what we do.)


#+BEGIN_SRC lisp
;; database.lisp
(defun add-list (heading)
  (let ((string-id (second (massage heading t))))
    (handler-case
        (progn (insert :into [lists]
                       :attributes '(heading)
                       :values `(,string-id))
               (let ((k (theory-to-id heading)))
                 (execute-command
                  (format nil "CREATE TABLE lists~A (
   offset SERIAL PRIMARY KEY,
   code INT NOT NULL,
   ref INT NOT NULL
);" k))
                 `(0 ,k)))
      (sql-database-data-error
          ()
        (warn "The list \"~a\" already exists."
              heading)))))
#+END_SRC

*** On `get-lists'

Find all lists that contain `symbol'.


#+BEGIN_SRC lisp
;; database.lisp
(defun get-lists (symbol)
  (let* ((data (massage symbol))
         (type (datatype data))
         (id (second data))
         (n (caar
             (query "select count(*) from lists")))
         results)
    (loop for k from 1 upto n
          do (let ((present
                    (query (concatenate
                            'string
                            "select offset from list"
                            (format nil "~A" k)
                            " where ((code = "
                            (format nil "~A" type)
                            ") and (ref = "
                            (format nil "~A" id)
                            "))"))))
               (when present
                 ;; bit of a problem if there are multiple
                 ;; entries of that item on the given
                 ;; list.
                 (setq results (cons (list 0 k present)
                                     results)))))
    results))
#+END_SRC

*** On `save-to-list'

Record `symbol' on list named `name'.


#+BEGIN_SRC lisp
;; database.lisp
(defun save-to-list (symbol name)
  (let* ((data (massage symbol t))
         (type (datatype data))
         (string-id (string-to-id name))
         (k (select-one [id]
                        :from [lists]
                        :where [= [name] string-id]))
         (tablek (concatenate 'string
                              type (format nil "~A" k))))
    (insert-records :into (sql-expression :table tablek)
                    :attributes '(id)
                    :values `(,(second data)))))
#+END_SRC

\subsection*{Lookup by id or coordinates}

*** The data format that's best for Lisp
:PROPERTIES:
:LATEX_LABEL: what-is-best-for-lisp
:ID: what-is-best-for-lisp
:END:

It is a reasonable question to ask whether or not the an
item's id should be considered part of that item's
defining data when that data is no longer in the database.
For the functions defined here, the id is an input, and so
by default I'm not including it in the output here,
because it is already known.  However, for functions like
`triples-given-beginning' (See Note
[[id:graph-like-data]]), the id is \emph{not} part of the
known data, and so it is returned.  Therefore I am
providing the `retain-id' flag here, for cases where
output should be consistent with that of these other
functions.


#+BEGIN_SRC lisp
;; database.lisp
(defun string-lookup (id &optional retain-id)
  (let ((ret (select [text]
                     :from [strings]
                     :where [= [id] id])))
    (if retain-id
        (list id ret)
        ret)))

(defun triple-lookup (id &optional retain-id)
  (let ((ret (select [code1] [ref1]
                     [code2] [ref2]
                     [code3] [ref3]
                     :from [triples]
                     :where [= [id] id])))
    (if retain-id
        (cons id ret)
        ret)))

(defun list-lookup (id &optional retain-id)
  (let ((ret (select [name]
                     :from [lists]
                     :where [= [id] id])))
    (if retain-id
        (list id ret)
        ret)))
#+END_SRC

*** Succinct idioms for following pointers

Here are some variants on the functions above which save
us from needing to extract the id of the item from its
coordinates.


#+BEGIN_SRC lisp
;; database.lisp
(defun string-contents (coords)
  (string-lookup (second coords)))

(defun place-contents (coords)
  (place-lookup (second coords)))

(defun triple-contents (coords)
  (triple-lookup (second coords)))
#+END_SRC

*** Switchboard
:PROPERTIES:
:LATEX_LABEL: switchboard
:ID: switchboard
:END:

Even more succinctly, one function that can get
the object indicated by any set of coordinates.


#+BEGIN_SRC lisp
;; database.lisp
(defun switchboard (coords)
  (cond ((eq (first coords) 0)
         (string-contents coords))
        ((eq (first coords) 1)
         (place-contents coords))
        ((eq (first coords) 2)
         (triple-contents coords))))
#+END_SRC

*** Anti-pasti

The readability of this code could perhaps be improved if
we used functions like `switchboard' more frequently.
(More to the point, it seems it's not currently used.)  In
particular, it would be nice if we could sweep idioms like
\verb+`(2 ,(car triple))+ under the rug.


#+BEGIN_SRC lisp
;; database.lisp
(locally-disable-sql-reader-syntax)
#+END_SRC

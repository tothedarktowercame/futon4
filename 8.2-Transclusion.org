** Transclusion
:PROPERTIES:
:LATEX_LABEL: transclusion
:ID: transclusion
:END:

*** On `transclude-article'
:PROPERTIES:
:LATEX_LABEL: transclude-article
:ID: transclude-article
:END:

First we check to see whether the article contains
transclusions already, and if not, we put the text field
into the format used for text with transclusions
(see Note [[id:format-of-text-with-derivatives]]).

Next, we divide the text of the article in two; everything prior to
point, and everything after point.  (We have to divide the
\emph{rendered} text, fairly clearly; since there might be more than
one different rendering, we hope that the different possible divisions
are consistent, or at least that we know how to do all of the
divisions.)

Of course, we also need to be able to specify the objects that are to
be transcluded!


#+BEGIN_SRC elisp
;; totally not working yet!
(defun transclude-article (article)
  (interactive (list (read-article-name)))
  (let ((current (get-article name-of-current-article))
        newtext)
    ;; it really doesn't make sense to use something like this here --
    ;; we only deal with the internal format at commit time.
    (unless (and (listp current)
                 (eq (car current) 'twd))
           (setq newtext `(twd
                           ,(scholium-text current))))
    (let ((beg (point)))
      (insert (sch-plain-text (get-article article)))
      ;; this condition isn't really strong enough
      (when name-of-current-article
        (scholium
         `(derives-from ,name-of-current-article ,article ,(genref))
         nil
         `((passage (,name-of-current-article
                     ,beg
                     ,(point))))
         'derives-from
         'system)))))
#+END_SRC

*** Transclusion markup design                                     :noexport:
:PROPERTIES:
:LATEX_LABEL: transclusion-markup-design
:ID: transclusion-markup-design
:END:

The idea is that when some object $T$ is transcluded into the current
buffer, $\mathrm{im}(T)$ is marked up in the following way.  Character
$i$ in this image is given a text property that says ``This is
character $i$ of $n$ contiguous characters that have been transcluded
from the object $T$.''  Then, when parsing, if these text properties
show up in new places (e.g. non-contiguously) or if some of the
numbers fail to show up at all, we'll know to initiate new
transclusions or to change the definition of the current one being
scanned.

The reason for doing things this way is similar to the issue discussed
in the ``Not Intervals'' node of the Elisp manual\footnote{(info
  "(elisp)Not Intervals")}.  If the image of a transclusion was simply
marked up with a property that said ``This is the image of the object
$T$ under transclusion,'' then elements of the region that bears this
text property could be rearranged without anything registering at the
system level (Figure
# [[id:Rearrangement-not-detected-using-uniform-text-properties]]).
This would pretty much be a disaster.

The idea here is that \emph{we should be able to edit texts coming
  from transclusion} and continue to have the transclusion basically
work.  In Note [[id:splitting-text-properties]], we decided that text
inserted into a quotation should not take on the ``derives-from''
property that the surrounding text bears.  Thus, if a transcluded
region is broken up, or pieces of it are deleted, we assume that new
transclusions are being requested by the user.

These remarks apply to the representation of transclusions in rendered
documents; the internal representation is discussed in Note
[[id:format-of-text-with-derivatives]].

\begin{figure}
\begin{center}
\begin{tabular}{ccc}
\verb|-----#| &             &  \verb|-----#| \\
\verb|----##| &             &  \verb|-#--##| \\
\verb|---###| &$\rightarrow$&  \verb|---###| \\
\verb|--####| &             &  \verb|--##-#| \\
\verb|-#####| &             &  \verb|-#####|
\end{tabular}
\end{center}
\caption{Rearrangement isn't detected using uniform text properties
\label{Rearrangement-not-detected-using-uniform-text-properties}}
\end{figure}


*** Changing boundaries in source documents                        :noexport:
:PROPERTIES:
:LATEX_LABEL: changing-boundaries-in-source-documents
:ID: changing-boundaries-in-source-documents
:END:

In Note [[id:transclusion-markup-design]], we talked about adapting
transclusion boundaries to changes in the derivative document.
However, it should be noted that boundaries may shift in source
documents as well: if the object being transcluded is ``the region
between character position 10 and character position 250 from article
$A$'' and a lengthy header is inserted, the idea behind the
transclusion may be completely swept away.  The way to be safest here
is to specify objects without referring to their boundaries, e.g.
``Article $A$'' should be safe.

\emph{There may be a way of maintaining the boundaries recorded on the
  transclusions themselves in such a way that edits to the source
  article are reflected in updated information in the transclusion;
  i.e., if text is inserted into the region that is being transcluded,
  the boundaries could grow, for example.  But doing this seems tricky
  (at least modestly tricker than maintaining backlinks, for example),
  and I think I will hold off on doing anything like this until I get
  some clue that it is actually feasible to do it right.}


*** The transclusion algorithm                                     :noexport:
:PROPERTIES:
:LATEX_LABEL: the-transclusion-algorithm
:ID: the-transclusion-algorithm
:END:

(1) The first thing is to run a function to select an object
to transclude.

(2) Then we render it to plain text and insert that text in the
current article.  Appropriate text properties indicating that it is a
transclusion are added next.  (If instead of adding a new
transclusion, we simply wish to render an article that includes
transclusions, we must render each transcluded item in this way.)

(3)  We let the user go wild.

(4) If things have changed at commit time, we need to put new
transclusion instructions together.  This new information replaces the
old.  And, in any event, the rendered transclusions are converted to
an internal format for storage (Note [[id:format-of-text-with-derivatives]]).


*** Simple selection makes for expediency                          :noexport:
:PROPERTIES:
:LATEX_LABEL: simple-selection-for-transclusion
:ID: simple-selection-for-transclusion
:END:

In light of the comments in Note
[[id:changing-boundaries-in-source-documents]], for the time being we
choose the simple method of only allowing the transclusion of whole
articles.  There don't appear to be any major theoretical obstructions
to the transclusion of passages, but let's start with something that
will clearly be manageable.  (See Note
[[id:principle-of-minimality]].)


*** Derivative predicates for transclusions                        :noexport:

Some sort of `derives-from' predicate may have to be maintained for
transclusions, although here such a `derives-from' predicate might be
deduced from the transclusion \inp{text} directly.  (This is similar
the approach we took with inclusions.)


** Use the scholium system to do literate programming
:PROPERTIES:
:LATEX_LABEL: literate
:ID: literate
:END:

*** Importing LaTeX docs
:PROPERTIES:
:LATEX_LABEL: importing-latex-docs
:ID: importing-latex-docs
:END:

Note that importing a \LaTeX\ document (this one, in particular)
wouldn't be so different from importing a wiki (see Section
[[id:wiki]]).

One of the issues is how we're going to represent cross references
(see Note [[id:cross-refs-in-latex]]).  In compiled \LaTeX, they
typically appear as a number, whereas in source they appear as a tag.
In the scholium system, reference markup should presumably be used,
and I also suppose that we may as well use the name of the article
being referred to directly.  So, for example, this article would
be linked to by text that read ``see `Importing LaTeX docs'.''
This is similar to the way references appear in Texinfo.

Outside references (footnotes) could be rendered in a different
color (Note [[id:fancy-references]]), and made browsable within
the scholium system (Note [[id:nero2]]).

On the implementation: `end' might be followed by a lisp expression
that should be attached to the note, but this should be fun for a
trial run.

The format of the scholia representing the notes is kind of weird.  We
shouldn't have junk in the text field of the article.  It would
probably make more sense for items of type "note" to be rendered
specially (if one wished) and maybe to store the tag as a part of a
formatted text field, or, more likely, part of the \emph{type} data.

I think I'd be relatively comfortable adding identification
properties to the regions of the larger document, to get
them to inherit from the individual pieces.  Later we could
parse the section structure.

It would, generally speaking, be a good idea if lower levels
in the hierarchy were \inp{about} their parents in such a way
that we could easily move ``up''.


#+BEGIN_SRC elisp
(add-hook 'scholia-display-post-update-hook 'text-mode)

(add-to-list 'modified-type-labels '(note . note) t)
(add-to-list 'modified-type-labels '(section . section) t)
(add-to-list 'modified-type-labels '(subsection . subsection) t)
(add-to-list 'modified-type-labels '(subsubsection . subsubsection) t)
#+END_SRC

*** On `map-label'
:PROPERTIES:
:LATEX_LABEL: map-label
:ID: map-label
:END:

This gives you a way to apply a \inp{function} to every article that
bears a given \inp{label}.


#+BEGIN_SRC elisp
(defun map-label (function label)
  (mapc function (scholium-text (get-article label))))
#+END_SRC

*** Example of mapping across a label                              :noexport:
:PROPERTIES:
:LATEX_LABEL: mapping-across-a-subcollection
:ID: mapping-across-a-subcollection
:END:

Notice that we use `map-label' (Note [[id:map-label]]) in the APM-$\Xi$
importing routine, to convert once-processed content to a more useful
format.  See Note [[id:chunk-out-apmxi-definitions]].


*** On `swap-out-latex-references'

Does the opposite of `swap-in-latex-references' (Note 
[[id:swap-in-latex-references]]): that is, this
function makes \verb|\ref| tags
in the text look like hyperlinks.


#+BEGIN_SRC elisp
(defun swap-out-latex-references ()
  (let ((tags-alist (scholium-text (get-article
                                    'Tag-to-Name-converter))))
    (map-label (lambda (name)
                 (with-temp-buffer
                   (let ((article (get-article name)))
                     (insert (scholium-text article))
                     (goto-char (point-min))
                     (while (re-search-forward
                             ;; I don't think we use "xrefs" any more.
                             "\\\\\\(x\\)?ref{\\([^}]+\\)}" nil t)
                       (let ((target (cdr
                                      (assoc (match-string 2)
                                             tags-alist))))
                         (when target
                           (replace-match target t t)
                           (let ((name-of-current-article name))
                             (make-reference-in-current-article
                              (match-beginning 0)
                              (+ (match-beginning 0) (length target))
                              target)))))
                     ;; we don't want these references to be fake
                     (scholium name
                               (buffer-substring-no-properties
                                (point-min)
                                (point-max))
                               (scholium-about article)
                               '(note)))))
               'note)))
#+END_SRC

*** On `import-scholium-system'
:PROPERTIES:
:LATEX_LABEL: import-scholium-system
:ID: import-scholium-system
:END:

For now, this is just `import-sections', but it would be good if we
could do something about sections that contain neither subsections nor
notes, for example, the preface.  Other nice features (e.g. creating
``function type'' scholia for functions, as in Note
[[id:elisp-function-type]]) should be added too, eventually.  Sometimes
work arounds can be applied for the time being.

\emph{Hint: I've found that for now one has to `(clrhash
  article-table)' before running this function for things to work
  properly.  I intend to address this issue soon.}

(We might want to make this article use some kind of identification
routine; alternatively, make it work with a ``large structure'' map of
the document's contents.)


#+BEGIN_SRC elisp
(defun import-scholium-system ()
  (interactive)
  (import-sections)
;  (label-article 'section 'major-articles)
  (swap-out-latex-references))
#+END_SRC

*** Shorthand for editing the text of a scholium                   :noexport:

It would certainly be nice to have some short-hand
from the "editing" section to make it so that we didn't
have to use the `scholium' function every time we wanted
to edit some article.


*** Autobacklink to label                                          :noexport:
:PROPERTIES:
:LATEX_LABEL: autobacklink-to-label
:ID: autobacklink-to-label
:END:

Also, it would be nice if the mere inclusion of ``section'' in the
``major-articles'' label meant that there would be a ``parent''
(back)link from ``section'' to ``major-articles'' (see Note
[[id:import-scholium-system]] for the source of this example).

Such backlinks would let you navigate from things that bear a certain
label to the label itself and thence to the peers within that label.
(This certainly seems like a good idea!)


*** On `import-sections'

For each section, import any notes and any subsections.

I'm going to try to get this to import front- and back-matter (before
the first section and after the last note, respectively).  This will
make it easier to typeset everything with one command.


#+BEGIN_SRC elisp
(defun import-sections ()
  (save-excursion
    (set-buffer "sbdm4cbpp.tex")
    (goto-char (point-min))
    (search-forward-regexp "^\\\\section{Prelude}")
    (goto-char (match-beginning 0))
    (scholium "Scholium system frontmatter"
              (buffer-substring-no-properties (point-min) (point))
              nil
              '(note))
    (while (re-search-forward
            (concat
             "^\\\\section\\*?{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            nil t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (section-end (save-excursion
                            (search-forward-regexp
                             "^\\\\section{.*" nil t)))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsection{.*"
                               section-end t))
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes)))
             (subsections (let ((current-parent name))
                            (import-subsections))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  `(,@notes
                    ,@subsections)
                  '((section parent))
                  '(section label))))
    (goto-char (point-max))
    (search-backward-regexp "^\\\\clearpage")
    (scholium "Scholium system backmatter"
              (buffer-substring-no-properties (point) (point-max))
              nil
              '(note))))
#+END_SRC

*** On `import-subsections'

For each subsection, import any notes and any subsubsections.
notes are imported if they appear before the first subsubsection,
if there is one, or before the end of the subsection, otherwise,
or before the end of the section, if this is the last subsection


#+BEGIN_SRC elisp
(defun import-subsections ()
  (let (subsections)
    (while (re-search-forward
            (concat
             "^\\\\subsection{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            section-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (subsection-end (or (save-excursion
                                   (search-forward-regexp
                                    "^\\\\subsection{.*"
                                    section-end t))
                                 section-end))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsubsection{.*"
                               subsection-end t))
                            subsection-end
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes)))
             (subsubsections (let ((current-parent name))
                               (import-subsubsections))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  `(,@notes
                    ,@subsubsections)
                  `((,current-parent parent))
                  '(subsection label))
        (setq subsections
              (append subsections (list name)))))
    subsections))
#+END_SRC

*** On `import-subsubsections'

For each subsubsection, import any notes that appear before
the end of the subsubsection (if this is the last subsection,
then before the end of the subsection, etc.).


#+BEGIN_SRC elisp
(defun import-subsubsections ()
  (let (subsubsections)
    (while (re-search-forward
            (concat
             "^\\\\subsubsection{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            subsection-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsubsection{.*"
                               subsection-end t))
                            subsection-end
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  notes
                  `((,current-parent parent))
                  `(subsubsection label))
        (setq subsubsections
              (append subsubsections (list name)))))
    subsubsections))
#+END_SRC

*** On `import-notes'

This imports the notes at the current level in the
section hierarchy.


#+BEGIN_SRC elisp
(defun import-notes ()
  (let (notes)
    (while
        (re-search-forward (concat "\\\\begin{notate}"
                                   "{\\([^}\n]*\\)}"
                                   "\\( +\\\\label{\\)?"
                                   "\\([^}\n]*\\)?")
                           notes-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (beg (progn (next-line 1)
                         (line-beginning-position)))
             ;; no need to bound the search for the end, because we
             ;; assume that every "notate" environment is actually
             ;; closed
             (end (progn (search-forward-regexp
                          "\\\\end{notate}")
                         (match-beginning 0))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  (buffer-substring-no-properties beg end)
                  `((,current-parent parent))
                  '(note))
        (setq notes
              (append notes (list name)))
        (import-code-continuations)))
    notes))
#+END_SRC

*** On `import-code-continuations'

This runs within the scope of `import-notes', to turn any Lisp chunks
that follow a given Note into scholia attached to that note.  (This
won't import the one stand-alone ``verbatim'' environment used in the
code; we could change this function, or include the environment inside
of a Note.  Or we could just put the literate programming code into
another file.  Minor issue.  Also, figure environments would be left
out, except for a small trick, namely including them within
surrounding Notes.)  Notice that previous versions of these articles
shouldn't exist at import time, or Lisp sections will be doubled.

The code continuations and the code descriptions wind up being
mutually about one another, which is kind of cute.


#+BEGIN_SRC elisp
(defun import-code-continuations ()
  ;; ugly formatting = latex overrides!
  (while (looking-at (concat "\n\n\\\\b" "egin{lisp}"))
    (scholium `(code-continuation ,name)
              (let ((old-text (scholium-text
                               (get-article
                                `(code-continuation ,name))))
                    (new-text (buffer-substring-no-properties
                               (progn (next-line 3)
                                      (line-beginning-position))
                               (progn (search-forward-regexp
                                       (concat "\\\\e" "nd{lisp}"))
                                      (match-beginning 0)))))
                (if old-text 
                    (concat old-text "\n" new-text)
                  new-text))
              `(((article ,name)))
              'code)
    ;; this should add an appropriate link to the article
    ;; that this is a code-continuation of.
    (let ((article-to-edit (get-article name)))
      (scholium (scholium-name article-to-edit)
                (scholium-text article-to-edit)
                (add-to-or-start-list 
                 (scholium-about article-to-edit)
                 `(code-continuation (code-continuation ,name)))
                (scholium-bookkeeping article-to-edit)))))
#+END_SRC

*** A theoretical issue with code continuations                    :noexport:

I like to think of the notes as being scholia
attached to the code, rather than the code as scholia attached
to the notes.  But the way the importing routine is set up,
this relationship is reversed.


*** Rendering code continuations                                   :noexport:

If we know what kind of code is stored in the code continuation
articles, we may want to render it in the appropriate mode.  (The use
of connection coloration is disruptive to this kind of display, so
we'd want to use some other mechanism for showing associations, if
these need to be shown.  See Note [[id:color-and-style]].)


*** Identification of notes is slow

I tried identifying each note with its source region by running
\begin{idea}
(add-to-scholia-property-within-region
 beg
 end
 `(identifies-with ,name))
\end{idea}
towards the end of `import-notes', but it slowed everything down.

We may be able to get something similar by other means
anyway (Note [[id:alternative-to-identification]]).


#+BEGIN_SRC elisp 
(defun browse-scholium-system ()
  (interactive)
  (import-scholium-system)
  (display-article 'section)
  (message "You've successfully imported the system!"))
#+END_SRC

*** Finding all articles with code continuations                   :noexport:
:PROPERTIES:
:LATEX_LABEL: with-code
:ID: with-code
:END:

Cf. Note [[id:article-menu-list-articles-matching-predicate]].
\begin{idea}
(article-menu-list-articles-matching-predicate
 (lambda (name)
   (let ((article (get-article name)))
     (and (member-if (lambda (link)
                       (typedata-includes (cdr link) 
                                          'code-continuation))
                     (scholium-about article))
          (typedata-includes (scholium-type article)
                             'note)))))
\end{idea}
You can then run `listing-to-compilation' to get a new document that
drops all the interstitial chit chat found in this one.


*** Finding all articles without code continuations                :noexport:
:PROPERTIES:
:LATEX_LABEL: without-code
:ID: without-code
:END:

For our friends from the liberal arts,
\begin{idea}
(article-menu-list-articles-matching-predicate
 (lambda (name)
   (let ((article (get-article name)))
     (and (not (member-if (lambda (link)
                            (typedata-includes (cdr link) 
                                               'code-continuation))
                          (scholium-about article)))
          (typedata-includes (scholium-type article)
                             'note)))))
\end{idea}

(Curiously enough, this document currently seems pretty balanced in
that the code plus immediately important documentation takes up just
about the same amount of space as the philosophical musings.  Well,
almost as much.  And of course those verbatim environments are long.)


*** Finding all articles with emphasized parenthetical remarks     :noexport:

Cf. Note [[id:article-menu-list-articles-matching-regexp]].  These are
the articles that contain side remarks that should eventually be turned
into scholia.
\begin{idea}
(progn (article-menu-list-articles-matching-regexp "\\\\emph{(")
       (listing-to-label "Comments"))
\end{idea}


*** Exporting LaTeX docs                                           :noexport:
:PROPERTIES:
:LATEX_LABEL: exporting-latex-docs
:ID: exporting-latex-docs
:END:

This should give an inverse to importing
\LaTeX\ documents (Note [[id:importing-latex-docs]]).
Exporting in one go is a cheap alternative to live updating via
identifications (Section [[id:identification]]).  Either would
work, but exporting seems a little easier to get going quickly.
(Incidentally, exporting is similar to producing a compilation;
see Section [[id:quick-compilations]].)


*** On `export-scholium-system'
:PROPERTIES:
:LATEX_LABEL: export-scholium-system
:ID: export-scholium-system
:END:

We use a similar sort of "recursive" style to that used in the import.
First, loop through the sections.  These must of course be exported in
their own limited fashion.  Then, for each, examine the contents. The
items contained in each section are either subsections or notes.  If
the item really is a subsection, then do something similar to what we
did with sections; otherwise, it is a note and we simply export it.
The items at the penultimate level are either subsubsections or notes;
and finally, in the end, the items are all notes.

Note that getting the ``Tag-to-Name-converter'' each time it
is used in the child functions is really sort of excessive,
since it could be found once in the parent.  However, things seem
to run fast enough.


#+BEGIN_SRC elisp
(defun export-scholium-system ()
  (set-buffer (get-buffer-create "*Export*"))
  (erase-buffer)
  (insert (scholium-text (get-article "Scholium system frontmatter")))
  (dolist (sect (scholium-text (get-article 'section)))
    (export-section sect)
    (let ((contents (scholium-text (get-article sect))))
      (dolist (item contents)
        (let ((current-item (get-article item)))
          (if (typedata-includes (scholium-type current-item)
                                 'subsection)
              (export-subsection (scholium-name current-item))
            (export-note current-item))))))
  (insert (scholium-text (get-article "Scholium system backmatter"))))
#+END_SRC

*** Child functions                                                :noexport:
:PROPERTIES:
:LATEX_LABEL: child-functions
:ID: child-functions
:END:

Notice the sort of interesting use of the words ``child'' and
``parent'' in Note [[id:export-scholium-system]]; this is what comes
of working on section listings most of the day.  No reason that I can
think of not to view code this way.  Eventually we may want to parse
Lisp functions and annotate them with hierarchies representing this
sort of information.


*** Stable import/export                                           :noexport:

The text, import, and export routines are all adapted to each other
well enough to make it so that the text is stable under importing and
subsequent exporting.  We'll have to do more extensive testing to be
sure that it is also behaving properly with regard to intervening
editing operations, but things are currently looking pretty good in
this regard.  (But be careful, and back up your work!)


*** On `export-note'
:PROPERTIES:
:LATEX_LABEL: export-note
:ID: export-note
:END:

This is for exporting notes.  When the note has a code
continuation it also exports that code.

To really work, this is going to have to replace references with
\verb|\refs| and \verb|\refs|.  Hopefully we're storing the relevant
information somewhere easily accessible at import time?  We should at
very least be able to do the opposite of what is done with
`swap-out-latex-references'.

We essentially need to render the article to know
what the relevant references are (and where they are).
This suggests to me that if we don't want to disrupt the
user's experience of the rendered articles appearing in
the standard display, we should be able to ``beam'' a
rendering to some other buffer and then pick it up from
there.  Also, if some references have been generated
that don't correspond to items with tags, we'll have to
accomodate that.


#+BEGIN_SRC elisp
(defun export-note (note)
  (set-buffer (get-buffer "*Export*"))
  (let* ((name (scholium-name note))
         (tag (car (rassoc name (scholium-text
                                 (get-article
                                  'Tag-to-Name-converter))))))
    (insert "\*** " name "

"
            (if tag 
                (concat " \\label{" tag "}\n")
              "\n")
            (swap-in-latex-references note)
            "\
\n\n")
    (dolist (scholium (mapcar (lambda (backlink)
                                    (get-article (car backlink)))
                              (get-backlinks name)))
      ;; we were missing one function from a list of two in my last
      ;; test of exporting, should look into this.
      (when (typedata-includes (scholium-type scholium) 'code)
        (insert "\\b" "egin{lisp}\n"
                (scholium-text scholium)
                "\\e" "nd{lisp}\n\n")))))
#+END_SRC

*** On `swap-in-latex-references'
:PROPERTIES:
:LATEX_LABEL: swap-in-latex-references
:ID: swap-in-latex-references
:END:

Maybe it would be easier if each of the references had
the name of the tag stored locally?  This doesn't
seem like it would actually help.  The point I guess
is that we don't want to detect the scholia structure
all at once, but rather, zip through and make changes
to each item we encounter, in order.  I.e., the endpoints
of the regions that we'll be modifying are always in
transition.

`move-to-next-region-with-scholium' will have to be set up to
return `nil' if there is no next scholium.  It would also be
nice if this returned the boundaries of the region to which the
scholium is attached, when there is a scholium, since we're
going to want to do a replacement of the text in that region.
(If it proves more reasonable to use a different function for
this purpose, that would be fine, but this is roughly what it
should do.)  Note that `move-to-next-region-with-scholium'
currently works in terms of overlays, which isn't really
right.

After we find the scholia at the start and end of the marked region,
we could check a complicated condition to see if there is a reference
at the beginning and another copy of the same reference at the end.
But for the time being we aren't going to work with this general case
of overlapping references, and we'll just assume one reference per
marked region and get on with things.


#+BEGIN_SRC elisp
(defun swap-in-latex-references (note)
  (save-excursion
    (let ((tags-alist (scholium-text (get-article
                                      'Tag-to-Name-converter))))
      (display-article (scholium-name note))
      (set-buffer (get-buffer "Main Article Display"))
      (let ((next-region (move-to-next-region-with-scholium)))
        (while next-region
          (let ((scholium-property-at-start 
                 (get-text-property (first next-region) 'scholia))
                (scholium-property-at-end 
                 (get-text-property (second next-region) 'scholia)))
            (let* ((scholium-id (first scholium-property-at-start))
                   (scholium-name (first scholium-id))
                   (possible-reference (get-article scholium-name)))
              (when (typedata-includes 
                     (scholium-type possible-reference)
                     'reference)
                (let ((scholium-tag 
                       (car (rassoc (reference-to-article 
                                     possible-reference)
                                    tags-alist))))
                  (if scholium-tag
                      (progn (delete-region (first next-region)
                                            (second next-region))
                             (goto-char (first next-region))
                             (insert "\[[id:" scholium-tag "]]"))
                    (let ((new-tag (replace-regexp-in-string
                                    " " "-"
                                    (buffer-substring-no-properties
                                     (first next-region)
                                     (second next-region)))))
                      (delete-region (first next-region)
                                     (second next-region))
                      (goto-char (first next-region))
                      (insert "\[[id:" new-tag "]]"))))))
            (setq next-region (move-to-next-region-with-scholium)))))
      (buffer-substring-no-properties (point-min)
                                      (point-max)))))

(defun export-section (section-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc section-name (scholium-text
                                         (get-article
                                          'Tag-to-Name-converter))))))
    (insert "\\section{" section-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n"))))

(defun export-subsection (subsection-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc subsection-name (scholium-text
                                            (get-article
                                             'Tag-to-Name-converter))))))
    (insert "\\subsection{" subsection-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n")))
  (let ((contents (scholium-text current-item)))
    (dolist (item contents)
      (let ((current-item (get-article item)))
        (if (typedata-includes (scholium-type current-item)
                               'subsubsection)
            (export-subsubsection (scholium-name current-item))
          (export-note current-item))))))

(defun export-subsubsection (subsubsection-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc subsubsection-name (scholium-text
                                               (get-article
                                                'Tag-to-Name-converter))))))
    (insert "\\subsubsection{" subsubsection-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n")))
  (let ((contents (scholium-text current-item)))
                              
    (dolist (item contents)
      (let ((current-item (get-article item)))
        (export-note current-item)))))
#+END_SRC

*** Name conflicts                                                 :noexport:

As we talked about vis a vis namespaces (Note
[[id:labels-and-namespaces]]), it would be nice if
we could deal with multiple different things having
the same name, say a Section and a Note, or two
Notes in different sections.  A disambiguation page
could be created whenever the ambiguity needed to be
paid attention to.


*** Revise to support ``function'' type articles                   :noexport:
:PROPERTIES:
:LATEX_LABEL: elisp-function-type
:ID: elisp-function-type
:END:

Instead of referring to Notes that describe functions, sometimes
we may prefer to refer to ``function'' articles, which will
include the function and the note that describes it.


*** Group functions sharing scope                                  :noexport:

Objects with type functions could have ``runs
within the scope of this function'' slots.  This would facilitate
propagating changes in notation.


*** Other features for function articles                           :noexport:

As top-level objects, functions could be fitted
out with their own fora and FAQ's.  They could be
displayed with the appropriate mode turned on
by default.

A short document containing only the functions that
one had been working on recently could be created easily;
see Note [[id:making-a-compilation]] and Note [[id:recent-referents]].


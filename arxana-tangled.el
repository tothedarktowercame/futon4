;; Autogenerated from Arxana spine

;; from 2.3-Elisp_requirements.el
(require 'align)
(require 'cl)
(load "cl-seq")
(load "cl-extra")


;; from 2.4-Lisp_preliminaries.el
(defun add-or-replace (lis elt pred)
  (let ((found nil)
        (n 0)
        (len (length lis)))
    (while (and (not found)
                (< n len))
      (when (funcall pred (nth n lis))
        (setcar (nthcdr n lis) elt)
        (setq found t))
      (setq n (1+ n)))
    (if found
        (1- n)
      (nconc lis (list elt))
      n)))

(defun add-to-or-start-list (possible-list element)
  (cond ((null possible-list)
         (list element))
        ((listp possible-list)
         (if (member element possible-list)
             possible-list
           (append possible-list (list element))))
        (t (list possible-list element))))

(defun next-single-property-change+predicate (pos prop &optional test)
  (let ((starting (get-text-property pos prop))
        (index pos)
        (cmpfct (or test
                    'eq)))
    (save-excursion
      (while (and (setq index (1+ index))
                  (< index (point-max))
                  (funcall cmpfct
                           starting
                           (get-text-property index prop)))))
    (when (< index (point-max))
      index)))

(defun delete-all-dups (list)
  (let ((tail list)
        ret)
    (while tail
      (cond ((member (car tail) (cdr tail))
             (setq tail (delete (car tail) tail)))
            (t
             (setq ret (cons (car tail) ret)
                   tail (cdr tail)))))
    ret))

(defun set-difference (A B)
  (delete-all-dups (append A B)))

(defun zip (A B)
  (let ((ret (make-hash-table)))
    (while A
      (puthash (car A)
               (car B)
               ret)
      (setq A (cdr A)
            B (cdr B)))
    ret))

(defun flatten (list-structure)
  (apply 'concatenate 'list (list list-structure)))


;; from 3.1-The_digital_library.el
(defvar article-table
  (make-hash-table :test 'equal))

(defun put-article (name value)
  (puthash name value article-table))

(defun get-article (name)
  (let ((content (gethash name article-table)))
    (when content
      (cons name content))))

(defvar name-of-current-article nil)

(defun current-article ()
  (get-article name-of-current-article))

(require 'json)
(require 'url)

(defgroup futon4 nil
  "Arxana <-> Futon1 integration."
  :group 'tools)

(defcustom futon4-base-url "http://localhost:8080/api/alpha"
  "Base URL for Futon1 API (ASCII alias for /api/Î±)."
  :type 'string)

(defcustom futon4-enable-sync t
  "When non-nil, mirror article and relation edits to Futon1."
  :type 'boolean)

(defcustom futon4-log-requests nil
  "When non-nil, log each Futon1 POST and its JSON payload."
  :type 'boolean)

(defun futon4--post-json (path payload &optional cb)
  "POST PAYLOAD as JSON to Futon1 PATH and run CB on the decoded body."
  (when futon4-enable-sync
    (let* ((json-body (json-encode payload))
           (url-request-method "POST")
           (url-request-extra-headers '(("Content-Type" . "application/json")))
           (url-request-data (encode-coding-string json-body 'utf-8)))
      (when futon4-log-requests
        (message "futon4 POST %s %s" path json-body))
      (condition-case err
          (url-retrieve
           (concat futon4-base-url path)
           (lambda (_status)
            (goto-char (point-min))
            (when (re-search-forward "\n\n" nil t)
               (let* ((json-object-type 'alist)
                      (json-array-type 'list)
                      (json-key-type 'keyword)
                      (body (ignore-errors (json-read))))
                 (when cb (funcall cb body))))
             (let ((buf (current-buffer)))
               (when (buffer-live-p buf)
                 (kill-buffer buf)))))
        (error
         (message "futon4 request to %s failed: %S" path err))))))

(defun futon4--canonical-path (path)
  "Return a canonicalized representation of PATH, or nil."
  (when path
    (convert-standard-filename (expand-file-name path))))

(defun futon4--article-id (path)
  "Build a stable Futon1 article id from PATH or BUFFER name."
  (when path
    (concat "arxana:article:" (format "%s" path))))

(defvar futon4--article-id-cache (make-hash-table :test 'equal)
  "Cache mapping scholium names to Futon1 ids.")

(defun futon4-register-article (name id)
  "Remember that NAME corresponds to Futon1 article ID."
  (when (and name id)
    (puthash name id futon4--article-id-cache)
    id))

(defun futon4-lookup-article-id (name)
  "Return Futon1 article id cached for NAME, if any."
  (and name (gethash name futon4--article-id-cache)))

(defun futon4--article-id-for (name &optional path)
  "Return or derive the Futon1 id for NAME, optionally using PATH."
  (or (futon4-lookup-article-id name)
      (let ((derived (futon4--article-id (or path name))))
        (when derived
          (futon4-register-article name derived)))))

(defun futon4--link-label (link)
  "Return a readable label string for LINK's metadata."
  (let ((meta (cdr-safe link)))
    (if meta
        (mapconcat (lambda (piece)
                     (cond
                      ((stringp piece) piece)
                      ((symbolp piece) (symbol-name piece))
                      (t (format "%S" piece))))
                   meta
                   " | ")
      "")))

(defun futon4--sync-about-links (source-name about)
  "Mirror ABOUT links for SOURCE-NAME into Futon1."
  (when (and futon4-enable-sync about)
    (let ((src-id (futon4-lookup-article-id source-name)))
      (when src-id
        (dolist (link about)
          (let* ((target (car-safe link))
                 (dst-id (and target
                              (futon4--article-id-for target))))
            (when dst-id
              (futon4-store-nema-simple src-id dst-id
                                        (futon4--link-label link)))))))))

(defun futon4--article-context-for-buffer (buffer)
  "Return plist with :id, :name, and :path for BUFFER."
  (let* ((path (or (futon4--canonical-path (buffer-file-name buffer))
                   (buffer-name buffer)))
         (id (futon4--article-id path))
         (name (buffer-name buffer)))
    (list :id id :name name :path path)))

(defun futon4-ensure-article-entity (id name path &optional spine-p cb)
  "Ensure Futon1 has an article entity with ID, NAME, and PATH.
SPINE-P marks the article as belonging to the current spine when non-nil.
CB is an optional callback that receives the decoded response body."
  (when id
    (let* ((props-alist (delq nil (list (when path
                                          (cons 'path path))
                                        (when spine-p
                                          (cons 'spine t)))))
           (payload (delq nil (list (cons 'id id)
                                    (cons 'name (if (symbolp name)
                                                    (symbol-name name)
                                                  name))
                                    (cons 'type "arxana/article")
                                    (when props-alist
                                      (cons 'props props-alist))))))
      (futon4--post-json "/entity" payload cb))))

(defun futon4-store-nema-simple (src-id dst-id &optional label cb)
  "Store a simple scholium-style relation between SRC-ID and DST-ID."
  (when (and src-id dst-id)
    (futon4--post-json
     "/relation"
     `((type . "arxana/scholium")
       (src . ,src-id)
       (dst . ,dst-id)
       (props . ((label . ,(or label "")))))
     cb)))


;; from 3.2-Creating_scholia.el
(defalias 'scholium-name 'first)
(defalias 'scholium-text 'second)
(defalias 'scholium-about 'third)
(defalias 'scholium-type 'fourth)
(defalias 'scholium-bookkeeping 'fifth)

(defalias 'linked-to-article 'first)
(defalias 'link-type 'cdr)

(defun link-type-accessor (link type)
  (car (member-if (lambda (type-elt)
                    (or (eq type-elt type)
                        (and (listp type-elt)
                             (eq (car type-elt) type))))
                  (cdr link))))

(defun link-beginning (link)
  (second (link-type-accessor link 'passage)))

(defun link-end (link)
  (third (link-type-accessor link 'passage)))

(defun link-version (link)
  (second (link-type-accessor link 'version)))

(defvar new-scholium-hook nil)
(defvar scholium-modified-text-hook nil)
(defvar scholium-modified-about-hook nil)
(defvar scholium-modified-type-hook nil)
(defvar scholium-modified-book-hook nil)

(defun scholium (name text &optional about type book)
  (let* ((old-version (get-article name))
         (old-about (and old-version (scholium-about old-version)))
         (maybe-path (and (stringp text)
                          (fboundp 'typedata-includes)
                          (typedata-includes type 'file)
                          (fboundp 'futon4--canonical-path)
                          (futon4--canonical-path text)))
         (article-id (and (fboundp 'futon4--article-id-for)
                          (futon4--article-id-for name maybe-path))))
    (put-article name (list text about type book))
    (when (and article-id
               (not (bufferp text))
               (or (not (fboundp 'typedata-includes))
                   (not (typedata-includes type 'file)))
               (fboundp 'futon4-ensure-article-entity))
      (futon4-ensure-article-entity article-id name maybe-path))
    (let ((meta-override (metadata-override)))
      (when (and (not meta-override)
                 (fboundp 'futon4--sync-about-links)
                 (not (equal old-about about)))
        (futon4--sync-about-links name about))
      (when (not meta-override)
        (if (not old-version)
            (run-hooks 'new-scholium-hook)
          (when (not (equal (scholium-text old-version) text))
            (run-hooks 'scholium-modified-text-hook))
          (when (not (equal (scholium-about old-version) about))
            (run-hooks 'scholium-modified-about-hook))
          (when (not (equal (scholium-type old-version) type))
            (run-hooks 'scholium-modified-type-hook))
          (when (not (equal (scholium-bookkeeping old-version) book))
            (run-hooks 'scholium-modified-book-hook)))))))

(defun metadata-override ()
  (when (or (typedata-includes type 'meta)
            (typedata-includes type 'fake))
    t))

(defun article-names-from-about-data (about)
  (delete-dups (mapcar (lambda (elt) (car elt)) about)))

(defun typedata-includes (typedata specific-type)
  (cond ((eq typedata specific-type) t)
        ((and (listp typedata)
              (member specific-type typedata)) t)
        (t nil)))

(defun typedata-includes-element-of-list (typedata list-of-types)
  (let (ret)
    (while (and list-of-types
                (not ret))
      (when (typedata-includes typedata (car list-of-types))
        (setq ret t))
      (setq list-of-types (cdr list-of-types)))
    ret))

(defun typedata-includes-passage (typedata)
  (let (ret)
    (when (listp typedata)
      (while (and typedata
                  (not ret))
        (when (eq (car (car typedata)) 'passage)
          (setq ret (car typedata)))))
    ret))


;; from 3.3-Metadata.el
(defun metadata-article-name-p (name)
  (when (and (listp name)
             (eq (car name) 'meta))
    t))

(defun base-name-from-metadata-name (name)
  (second name))

(defun metadata-article (name)
  (get-article (list 'meta name)))

(defun put-metadata-field (field value name)
  (let* ((metadata (metadata-article name))
         (old-value (assoc field (scholium-text metadata)))
         new-text)
    (if old-value
        (setq new-text (progn (setcdr old-value value)
                              (scholium-text metadata)))
      (setq new-text `((,field . ,value))))
    (scholium (list 'meta name)
              new-text
              nil
              'meta
              'system)))

(defun get-metadata-field (field name)
  (cdr (assoc field (scholium-text (metadata-article name)))))

(defun delete-backlink (linked-to-article link-number)
  (let* ((metaarticle (metadata-article linked-to-article))
         (metatext (scholium-text metaarticle))
         (metafield (assoc 'backlinks metatext))
         (backlinks (remove (list name link-number)
                            (cdr metafield))))
    (setcdr metafield backlinks)
    (scholium (list 'meta linked-to-article)
              metatext
              nil
              'meta
              'system)))

(defun add-backlink (linked-to-article link-number)
  (let* ((metaarticle (metadata-article linked-to-article))
         (metatext (scholium-text metaarticle))
         (metafield (assoc 'backlinks metatext))
         (backlinks (add-to-or-start-list
                     (cdr metafield)
                     (list name link-number))))
    (cond
     (metafield
      (setcdr metafield backlinks))
     (metatext
      (setcdr metatext
              `(((backlinks . ,backlinks)))))
     (t
      (setq metatext
            `((backlinks . ,backlinks)))))
    (scholium (list 'meta linked-to-article)
              metatext
              nil
              'meta
              'system)))

(defun put-backlinks ()
  (let ((old-about (scholium-about old-version))
        (link-number 0))
    (dolist (link old-about)
      (setq link-number (1+ link-number))
      (delete-backlink (car link) link-number)))
  (let ((link-number 0))
    (dolist (link about)
      (setq link-number (1+ link-number))
      (add-backlink (car link) link-number))))

(add-hook 'new-scholium-hook 'put-backlinks)
(add-hook 'scholium-modified-about-hook 'put-backlinks)


;; from 3.5-Subcollections.el
(defvar modified-type-labels '((nil . plain)
                               (label . label)
                               (meta . metadata)
                               (list . list)
                               (reference . reference)
                               (section . section)))

(defun label-article (name article-label)
  (scholium article-label
            (add-to-or-start-list (scholium-text
                                   (get-article article-label))
                                  name)
            nil
            'label))

(defun label-article-insert-before (name before-this article-label)
  (let* ((contents (scholium-text (get-article article-label)))
         (before-this-headed (member before-this contents)))
    (when before-this-headed
      (let ((len (- (length contents)
                    (length before-this-headed)
                    1)))
        (if (> len -1)
            (setcdr (nthcdr len contents)
                    (cons name before-this-headed))
          (setq contents (cons name before-this-headed))))
      (scholium article-label
                contents
                nil
                'label))))

(defun put-type-labels ()
  (unless (typedata-includes type 'label)
    (dolist (type-label modified-type-labels)
      (when (typedata-includes type (car type-label))
        (label-article name (cdr type-label))))))

(add-hook 'new-scholium-hook 'put-type-labels)
(add-hook 'scholium-modified-type-hook 'put-type-labels)

(defun generalized-put-article (path name value)
  (puthash name value (generalized-get-article path)))

(defun generalized-get-article (path &optional current)
  (let ((first-step (get-article path)))
    (cond 
     ((and (not current) first-step)
      first-step)
     ((cdr path)
      (if (typedata-includes (get-article (car path)) 'namespace)
          (generalized-get-article (cdr path) (car path))
        (error "Path element not a namespace")))
     ((and (car path) current)
      (gethash current (car path)))
     ((car path) (get-article (car path))))))


;; from 3.6-Data_access_and_conversion.el
(defun label-to-list (label)
  (mapcar (lambda (name)
            (format "%s" name))
          (scholium-text (get-article label))))

(defun label-to-propertized-list (label)
  (mapcar (lambda (name)
            (propertize (format "%s" name) 'name name))
          (scholium-text (get-article label))))

(defun get-backlinks (name)
  (get-metadata-field 'backlinks name))

(defun get-links (name)
  (cdr (assoc 'links (scholium-text (metadata-article name)))))

(defun read-article-name ()
  (let* ((completion-ignore-case t)
         (strings (turn-article-table-into-list))
         (string-found (completing-read
                        "Article: "
                        strings))
         (place (- (length strings)
                   (length (member string-found strings)))))
    (nth place (turn-article-table-into-names))))

(defun read-article-path (&optional namespace path)
  (let* ((completion-ignore-case t)
         (strings (if namespace
                      (turn-namespace-into-list namespace)
                    (turn-article-table-into-list)))
         (string-found (completing-read
                        "Article: "
                        strings))
         (place (- (length strings)
                   (length (member string-found strings))))
         (ret (nth place (if namespace
                             (turn-namespace-into-names namespace)
                           (turn-article-table-into-names)))))
    (setq path (append path (list ret)))
    (if (and (typedata-includes ret 'namespace)
             (y-or-n-p "Read further? "))
        (read-article-path namespace path))
    path))

(defun link-about-article-p (link article-name)
  (equal (linked-to-article link) article-name))


;; from 3A.1-Preliminaries.el
(require 'cl)

(defun filter (pred stuff)
  (let ((ans nil))
    (dolist (item stuff (reverse ans))
      (if (funcall pred item)
            (setq ans (cons item ans))
        nil))))

(defun intersection (&rest arg)
  (cond ((null arg) nil)
        ((null (cdr arg)) (car arg))
        (t (let ((ans nil))
             (dolist (elmt (car arg) ans)
               (let ((remainder (cdr arg)))
                 (while (and remainder
                             (member elmt (car remainder)))
                   (setq remainder (cdr remainder))
                   (when (null remainder)
                     (setq ans (cons elmt ans))))))))))

(defun mapply (f l)
  (if (member nil l) nil
    (cons (apply f (mapcar 'car l))
          (mapply f (mapcar 'cdr l)))))

(defun sublis (sub lis)
  (cond
   ((null lis) nil)
   ((assoc lis sub) (cadr (assoc lis sub)))
   ((atom lis) lis)
   (t (cons (sublis sub (car lis))
            (sublis sub (cdr lis))))))


;; from 3A.2-Core_definitions.el
(defvar plexus-registry '(0 nil))
(defvar current-plexus nil)

(defun add-plexus ()
  "Create a new plexus."
  (let ((newbie (list '*plexus*
                      1                               ; nema counter
                      (make-hash-table :test 'equal)  ; nema table
                      (make-hash-table :test 'equal)  ; forward links
                      (make-hash-table :test 'equal)  ; backward links
                      (make-hash-table :test 'equal)  ; forward labels
                      (make-hash-table :test 'equal)  ; backward labels
                      (car plexus-registry))))
    ;; Define ground and type nodes.
    (puthash 0 '(0 0) (nth 2 newbie))
    (puthash 1 '(0 0) (nth 2 newbie))
    (puthash 0 '((0 . 0) (1 . 0)) (nth 3 newbie))
    (puthash 0 '((0 . 0) (1 . 0)) (nth 4 newbie))
    (puthash 0 '"ground" (nth 5 newbie))
    (puthash '"ground" 0 (nth 6 newbie))
    (puthash 1 '"type" (nth 5 newbie))
    (puthash '"type" 1 (nth 6 newbie))
    ;; Register the new object and return it.
    (setq plexus-registry
	  (append
	   `(,(+ (car plexus-registry) 1)
	     ,newbie)
	   (cdr plexus-registry)))
    newbie))

(defun remove-plexus (plex)
  "Remove a plexus."
  ;; Wipe out the hash tables
  (dotimes (i 5)
    (clrhash (nth (+ i 2) plex)))
  ;; Remove the entry from the registry.
  (setq plexus-registry
        (cons
         (car plexus-registry)
         (delete
          (assoc (nth 7 plex)
                 (cdr plexus-registry))
          (cdr plexus-registry)))))

(defun show-plexus-registry ()
  plexus-registry)

(defun set-current-plexus (plex)
  "Examine a different plexus instead."
  (setq current-plexus plex))

(defmacro with-current-plexus (plex &rest expr)
  (declare (debug (&rest form)))
  (append `(let ((current-plexus ,plex))) expr))

(defun show-current-plexus ()
  "Return the plexus currently being examined."
  current-plexus)

(defun next-unique-id ()
  "Produce a yet unused unique identifier."
  (1+ (cadr current-plexus)))

(defun reset-plexus ()
  "Reset the database to its initial configuration."
  ; Reset nema counter and hash tables.
  (setcar (cdr current-plexus) 1)
  (dotimes (n 5)
    (clrhash (nth (+ n 2) current-plexus)))
  ;; Define ground and nema-type.
  (puthash 0 '(0 0) (nth 2 current-plexus))
  (puthash 1 '(0 0) (nth 2 current-plexus))
  (puthash 0 '((0 . 0) (1 . 0)) (nth 3 current-plexus))
  (puthash 0 '((0 . 0) (1 . 0)) (nth 4 current-plexus))
  (puthash 0 '"ground" (nth 5 current-plexus))
  (puthash '"ground" 0 (nth 6 current-plexus))
  (puthash 1 '"type" (nth 5 current-plexus))
  (puthash '"type" 1 (nth 6 current-plexus))
  nil)


;; from 3A.3-Individual_Operations.el
(defun add-nema (src txt snk)
  "Enter a new nema to the database."
  (let ((uid (next-unique-id)))
    ;; Add record to nema table.
    (puthash uid
             `(,src ,snk . ,txt)
             (nth 2 current-plexus))
    ;; Add record to list of forward links of source.
    (puthash src
             (cons `(,uid . ,snk)
                   (gethash src (nth 3 current-plexus) nil))
             (nth 3 current-plexus))
    ;; Add record to list of backward links of sink.
    (puthash snk
             (cons
              `(,uid . ,src)
              (gethash snk (nth 4 current-plexus) nil))
             (nth 4 current-plexus))
    ;; Update the counter for long-term storage
    (setcar (cdr current-plexus) uid)
    ;; Return the id of the new nema.
    uid))

(defun get-content (uid)
  "Return the content of the nema."
  (cddr (gethash uid (nth 2 current-plexus))))

(defun get-source (uid)
  "Return the source of the nema."
  (car (gethash uid (nth 2 current-plexus))))

(defun get-sink (uid)
  "Return the sink of the nema."
  (cadr (gethash uid (nth 2 current-plexus))))

(defun get-triple (uid)
  (list (get-source uid)
        (get-content uid)
        (get-sink uid)))

(defun update-content (uid txt)
  "Replace the content of the nema."
  (puthash uid
              (let ((x (gethash uid (nth 2 current-plexus))))
                     `(,(car x)    ; old source
                              ,(cadr x) . ; old sink
                                     ,txt))      ; new content
                 (nth 2 current-plexus)))

(defun update-source (uid new-src)
  "Replace the source of the nema."
  (let* ((x (gethash uid (nth 2 current-plexus)))
         (old-src (car x))   ; extract current source
         (old-snk (cadr x))  ; extract current sink
         (old-txt (cddr x))) ; extract current content
    ;; Update the entry in the nema table.
    (puthash uid
             `(,new-src ,old-snk . ,old-txt)
             (nth 2 current-plexus))
    ;; Remove the entry with the old source in the
    ;; forward link table.  If that is the only entry
    ;; filed under old-src, remove it from table.
    (let ((y (delete `(,uid . ,old-snk)
                     (gethash old-src
                              (nth 3 current-plexus)
                              nil))))
      (if y
          (puthash old-src y (nth 3 current-plexus))
        (remhash old-src (nth 3 current-plexus))))
    ;; Add an entry with the new source in the
    ;; forward link table.
    (puthash new-src
             (cons `(,uid . ,old-snk)
                   (gethash old-src (nth 3 current-plexus) nil))
             (nth 3 current-plexus))
    ;; Update the entry in the backward link table.
    (puthash old-snk
             (cons `(,uid . ,new-src)
                   (delete `(,uid . ,old-src)
                           (gethash old-src
                                    (nth 4 current-plexus)
                                    nil)))
             (nth 4 current-plexus))))

(defun update-sink (uid new-snk)
  "Change the sink of the nema."
  (let* ((x (gethash uid (nth 2 current-plexus)))
          (old-src (car x))   ; extract current source
           (old-snk (cadr x))  ; extract current sink
            (old-txt (cddr x))) ; extract current content
    ; Update the entry in the nema table.
    (puthash uid
             `(,old-src ,new-snk . ,old-txt)
             (nth 2 current-plexus))
    ;; Remove the entry with the old sink in the
    ;; backward link table.  If that is the only entry
    ;; filed under old-src, remove it from table.
    (let ((y (delete `(,uid . ,old-src)
                     (gethash old-snk
                              (nth 4 current-plexus)
                              nil))))
      (if y
          (puthash old-snk y (nth 4 current-plexus))
        (remhash old-snk (nth 4 current-plexus))))
    ;; Add an entry with the new source in the
    ;; backward link table.
    (puthash new-snk
             (cons `(,uid . ,old-src)
                   (gethash old-snk
                            (nth 4 current-plexus)
                            nil))
             (nth 4 current-plexus))
    ;; Update the entry in the forward link table.
    (puthash old-src
             (cons `(,uid . ,new-snk)
                   (delete `(,uid . ,old-snk)
                           (gethash old-src
                                    (nth 3 current-plexus)
                                    nil)))
             (nth 3 current-plexus))))

(defun remove-nema (uid)
  "Remove this nema from the database."
  (let ((old-src (car (gethash uid (nth 2 current-plexus))))
        (old-snk (cadr (gethash uid (nth 2 current-plexus)))))
  ;; Remove forward link created by nema.
  (let ((new-fwd (delete `(,uid . ,old-snk)
                          (gethash old-src (nth 3 current-plexus)))))
    (if new-fwd
        (puthash old-src new-fwd (nth 3 current-plexus))
      (remhash old-src (nth 3 current-plexus))))
  ;; Remove backward link created by nema.
  (let ((new-bkw (delete `(,uid . ,old-src)
                          (gethash old-snk (nth 4 current-plexus)))))
    (if new-bkw
        (puthash old-snk new-bkw (nth 4 current-plexus))
      (remhash old-snk (nth 4 current-plexus))))
  ;; Remove record from nema table.
  (remhash uid (nth 2 current-plexus))))

(defun get-forward-links (uid)
  "Return all links having given object as source."
  (mapcar 'car (gethash uid (nth 3 current-plexus))))

(defun get-backward-links (uid)
  "Return all links having given object as sink."
  (mapcar 'car (gethash uid (nth 4 current-plexus))))

(defun label-nema (uid label)
  "Assign the label to the given object."
  (puthash uid label (nth 5 current-plexus))
  (puthash label uid (nth 6 current-plexus)))

(defun label2uid (label)
  "Return the unique identifier corresponding to a label."
  (gethash label (nth 6 current-plexus) nil))

(defun uid2label (uid)
  "Return the label associated to a unique identifier."
  (gethash uid (nth 5 current-plexus) nil))


;; from 3A.4-Bulk_Operations.el
(defun download-en-masse ()
  "Produce a representation of the database as quintuples."
  (let ((plex nil))
    (maphash (lambda (uid tplt)
               ;; Unpack triplet.
               (let ((src (car tplt))
                     (snk (nth 1 tplt))
                     (txt (nthcdr 2 tplt)))
                 ;; Obtain label if exists.
                 (setq lbl (gethash uid
                                    (nth 5 current-plexus)
                                    nil))
                 ;; Write data to list.
                 (setq plex (cons `(,uid ,lbl ,src ,snk . ,txt)
                                 plex))))
             (nth 2 current-plexus))
    ;; Return list of data.
    (reverse plex)))

(defun upload-en-masse (plex)
  "Load a representation of a database as quintuples into memory."
  (dolist (qplt plex t)
    ; unpack quintuplet
    (let ((uid (car qplt))
            (lbl (nth 1 qplt))
              (src (nth 2 qplt))
                (snk (nth 3 qplt))
                  (txt (nthcdr 4 qplt)))
      ; plug into tables
      (puthash uid
                      `(,src ,snk . ,txt)
                             (nth 2 current-plexus))
      (puthash src
                      (cons `(,uid . ,snk)
                                 (gethash src (nth 3 current-plexus) nil))
                             (nth 3 current-plexus))
      (puthash snk
                      (cons
                       `(,uid . ,src)
                       (gethash snk (nth 4 current-plexus) nil))
                             (nth 4 current-plexus))
      (when lbl
          (progn
                (puthash uid lbl (nth 5 current-plexus))
                    (puthash lbl uid (nth 6 current-plexus))))
      ; Bump up nema counter if needed.
      (when (> uid (cadr current-plexus))
             (setcar (cdr current-plexus) uid)))))

(defun add-en-masse (plex)
  "Add multiple nemata given as list of quartuplets."
  (mapcar (lambda (qplt)
            (let ((uid (next-unique-id)))
              (add-nema (nth 1 plex)
                        (nthcar 2 plex)
                        (nth 2 plex))
              (label-nema uid (car qplt))))
          plex))


;; from 3A.5-Query.el
(defun uid-p (uid)
  "Is this a valid uid?"
  (let ((z '(())))
    (not (eq z (gethash uid (nth 2 current-plexus) z)))))

(defun uid-list ()
  "List of all valid uid's."
  (maphash (lambda (key val) key)
           (nth 2 current-plexus)))

(defun ground-p (uid)
  "Is this nema the ground?"
  (= uid 0))

(defun source-p (x y)
  "Is the former nema the sink of the latter?"
  (equal x (get-source y)))

(defun sink-p (x y)
  "Is the former nema the sink of the latter?"
  (equal x (get-sink y)))

(defun links-from (x y)
  "Return all links from nema x to nema y."
  (filter '(lambda (z) (source-p x z))
            (get-backward-links y)))

(defun links-p (x y)
  "Does nema x link to nema y?"
  (when (member x (mapcar
                      'get-source
                      (get-backward-links y)))
    t))

(defun triple-p (x y z)
  "Do the three items form a triplet?"
  (and (source-p y x)
       (sink-p y z)))

(defun plexus-p (x)
  "Is this object a plexus?"
  (let ((ans t))
    (setq ans (and ans
                      (equal (car x) "*plexus*")))
    (setq ans (and ans
                      (integrp (cadr x))))
    (dotimes (n 5)
          (setq ans (and ans (hash-table-p
                                    (nth (+ n 2) x)))))
    ans))


;; from 3A.6-Iteration.el
(defmacro do-plexus (var res body)
  `((maphash (lambda (,var val) ,body)
             (nth 2 current-plexus))
    ,res))

;; This maps over the keys; func should be
;; defined appropriately.
(defun map-plexus (func)
  (let ((ans nil))
    (maphash
     (lambda (key val)
       (push (apply func (list key)) ans))
     (nth 2 current-plexus))
    ans))

(defun filter-plexus (pred)
  (let ((ans nil))
    (maphash
     (lambda (key val)
       (when (apply pred (list key))
         (push key ans)))
       (nth 2 current-plexus))
     ans))

(defun nemas-given-beginning (node)
  "Get triples outbound from the given NODE."
  (filter-plexus
   (lambda (x) (when (equal (get-source x)
                            node)
                 (list node
                       (get-content x)
                       (get-sink x))))))

(defun nemas-given-end (node)
  "Get triples inbound into NODE."
  (filter-plexus
   (lambda (x) (when (equal (get-sink x)
                            node)
                 (list (get-source x)
                       (get-content x)
                       node)))))

(defun nemas-given-middle (edge)
  "Get the triples that run along EDGE."
  (filter-plexus
   (lambda (x) (when (equal (get-content x)
                            edge)
                 (list (get-source x)
                       edge
                       (get-sink x))))))

(defun nemas-given-middle-and-end (edge node)
  "Get the triples that run along EDGE into NODE."
  (filter-plexus
   (lambda (x) (when (and
                      (equal (get-content x)
                             edge)
                      (equal (get-sink x)
                             node))
                 (list (get-source x)
                       edge
                       node)))))

(defun nemas-given-beginning-and-middle (node edge)
  "Get the triples that run from NODE along EDGE."
  (filter-plexus
   (lambda (x) (when (and
                      (equal (get-source x)
                             node)
                      (equal (get-content x)
                             edge))
                 (list node
                       edge
                       (get-sink x))))))

(defun nemas-given-beginning-and-end (node1 node2)
  "Get the triples that run from NODE1 to NODE2."
  (filter-plexus
   (lambda (x) (when (and
                      (equal (get-source x)
                             node1)
                      (equal (get-sink x)
                             node2))
                 (list node1
                       (get-content x)
                       node2)))))

(defun nemas-exact-match (node1 edge node2)
  "Get the triples that run from NODE1 along EDGE to
NODE2."
  (filter-plexus
   (lambda (x) (when (and
                      (equal (get-source x)
                             node1)
                      (equal (get-content x)
                             edge)
                      (equal (get-sink x)
                             node2))
                 (list node1
                       edge
                       node2)))))

(defun get-src (n)
  (car (nth 0 (cdr (assoc n (cdr article-list))))))

(defun get-flk (n)
  (cdr (nth 0 (cdr (assoc n (cdr article-list))))))

(defun get-txt (n)
  (nth 1 (cdr (assoc n (cdr article-list)))))

(defun get-snk (n)
  (car (nth 2 (cdr (assoc n (cdr article-list))))))

(defun get-blk (n)
  (cdr (nth 2 (cdr (assoc n (cdr article-list))))))

(defun get-ids nil
  (mapcar (quote car) (cdr article-list)))

(defun get-gnd nil 0)

(defmacro search-cond (vars prop)
  "Find all n-tuplets satisfying a condition"
  (let ((foo '(lambda (vars cmnd)
                (if vars
                    Wrap in a loop.
                    `(dolist (,(car vars) uids)
                       ,(funcall foo (cdr vars) cmnd))
                    cmnd))))
    (funcall foo vars prop)))

(defun scheduler (new-nodes links sched)
  (if (null new-nodes)
      sched
    (let ((remaining-nodes new-nodes)
          (candidate nil)
          (ties nil)
          (old-nodes (mapcar 'car sched)))
      (while (null ties)
        (setq candidate (car remaining-nodes))
        (setq remaining-nodes (cdr remaining-nodes))
        (setq ties
              (filter '(lambda (x)
                         (or
                          (and (eq (first x) (car candidate))
                               (member (third x) old-nodes))
                          (and (member (first x) old-nodes)
                               (eq (third x) (car candidate)))))
                      links)))
      (scheduler (remove candidate new-nodes)
                 links
                 (cons (list (car candidate)
                             (cdr candidate)
                             ties)
                       sched)))))

(defun tplts2cmd (var tplts)
  (cons 'intersection
        (mapcar
         #'(lambda (tplt)
             (cond ((and (eq (third tplt) var)
                         (eq (second tplt) 'src))
                    `(get-flk ,(first tplt)))
                   ((and (eq (third tplt) var)
                         (eq (second tplt) 'snk))
                    `(get-blk ,(first tplt)))
                   ((and (eq (first tplt) var)
                         (eq (second tplt) 'src))
                    `(list (get-src ,(third tplt))))
                   ((and (eq (first tplt) var)
                         (eq (second tplt) 'snk))
                    `(list (get-snk ,(third tplt))))
                   (t nil)))
         tplts)))

(defun add-filt (var preds tplts)
  `(,var
    (filter
     #'(lambda (,var)
         ,(cons 'and
                (mapcar
                 #'(lambda (pred)
                     (list pred
                           (list 'get-txt var)))
                 preds)))
     ,(tplts2cmd var tplts))))

(defun first2cmd (preds)
  `(let ((ans nil))
     (dolist (node (get-ids) ans)
       (when
           ,(cons 'and
                  (mapcar
                   #'(lambda (pred)
                       (cons pred '((get-txt node))))
                   preds))
         (setq ans (cons node ans))))))

(defun query2cmd (query)
  (let ((backwards (reverse query)))
    (reverse
     (cons
      (list (caar backwards)
            (first2cmd (cdar backwards)))
      (mapcar
       #'(lambda (x)
           (add-filt (first x) (second x) (third x)))
       (cdr backwards))))))

(defun matcher (assgmt reqmts)
  (if (null reqmts) (list assgmt)
    (apply 'append
           (mapcar
            #'(lambda (x)
                (matcher (cons (list (caar reqmts) x)
                               assgmt)
                         (cdr reqmts)))
            (apply 'intersection
                   (eval `(let ,assgmt
                            (mapcar 'eval
                                    (cdar reqmts)))))))))

(defun search (query)
  (matcher nil
           (reverse
            (query2cmd
             (scheduler
              (cdar query)
              (cadr query)
              (list (caar query)))))))


;; from 3A.7-Scholium_programming.el
(defun node-fun (node get-code get-links)
  (let ((code  (funcall get-code node))
        (links (funcall get-links node)))
    (list
     'lambda
     (car code)
     (cons
      'prog1
      (cons
       (append
        '(progn)
        (mapcar #'(lambda (x)
                    `(fset ',(car x)
                           (node-fun ,(cdr x)
                                     ',get-code
                                     ',get-links)))
                links)
        (cdr code))
       (mapcar #'(lambda (x)
                   (if (fboundp (car x))
                       `(fset ',(car x)
                              ',(symbol-function (car x)))
                     `(fmakunbound ',(car x))))
               links))))))

(defun tangle-module (node get-cont ins-links)
  (insert-chunk
   (funcall get-cont node)
   (mapcar #'(lambda (x)
               (cons (car x)
                     (tangle-module (cdr x)
                                    get-cont
                                    ins-links)))
           (funcall ins-links node))))

(defun insert-chunk (body chunks)
  (cond ((null body) nil)
        ((null chunks) body)
        ((equal (car body) '*insert*)
         (cdr (assoc (cadr body) chunks)))
        (t (cons (insert-chunk (car body) chunks)
                 (insert-chunk (cdr body) chunks)))))

(defun set-src (n x)
  (if (equal n 0)
      0
    (progn (let ((old-backlink
                  (nth 1 (assoc (get-src n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((new-backlink
                  `(nth 1 (assoc x (cdr article-list)))))
             (setcdr new-backlink (cons n (cdr new-backlink))))
           (setcar (nth 1 (assoc n (cdr article-list))) x))))

(defun set-txt (n x)
  (setcar (cdr (cdr (assoc n (cdr article-list)))) x))

(defun set-snk (n x)
  (if (equal n 0)
      0
    (progn (let ((old-backlink
                  (nth 3 (assoc (get-snk n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((new-backlink
                  (nth 3 (assoc x (cdr article-list)))))
             (setcdr new-backlink (cons n (cdr new-backlink))))
           (setcar (nth 3 (assoc n (cdr article-list))) x))))

(defun ins-nod (src txt snk)
  (progn (setcdr article-list
                 (cons (list (car article-list)
                             (list src)
                             txt
                             (list snk))
                       (cdr article-list)))
         (let ((backlink
                (nth 3 (assoc snk (cdr article-list)))))
           (setcdr backlink (cons (car article-list)
                                  (cdr backlink))))
         (let ((backlink
                (nth 1 (assoc src (cdr article-list)))))
           (setcdr backlink (cons (car article-list)
                                  (cdr backlink))))
         (- (setcar article-list (+ 1 (car article-list))) 1)))

(defun del-nod (n)
  (if (or (equal n 0)
          (get-blk n)
          (get-flk n))
      nil
    (progn (let ((old-backlink
                  (nth 3 (assoc (get-snk n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (let ((old-backlink
                  (nth 1 (assoc (get-src n)
                                (cdr article-list)))))
             (setcdr old-backlink
                     (delete n (cdr old-backlink))))
           (setcdr article-list
                   (delete (assoc n (cdr article-list))
                           (cdr article-list)))
            t)))


;; from 3A.8-Initialization.el
(set-current-plexus (add-plexus))


;; from 4A.1-Database_interaction.el
(defun article-2 (name contents &optional heading)
  (let ((coordinates (add-nema name
                               "has content"
                               contents)))
    (when heading (add-nema coordinates "in" heading))
    coordinates))

(defun scholium-2 (beginning link end &optional heading)
  (let ((coordinates (add-nema beginning
                               link
                               end)))
    (when heading (add-nema coordinates "in" heading))
    coordinates))

(defun get-article (name)
  (get-sink
   (first
    (nemas-given-beginning-and-middle
     (first
      (nemas-given-beginning-and-end
       name "arxana-merge.tex"))
     "has content"))))

(defun get-names (&optional heading)
  (mapcar #'get-source
   (mapcar #'get-source (nemas-given-middle "has content"))))


;; from 4.1-Supplying_initial_bookkeeping_information.el
(defun sch-book ()
  `((created ,user-login-name ,(current-time-string))))


;; from 4.2-Adding_text_from_an_existing_source.el
(defun make-buffer-into-article (&optional buffer name)
  (let* ((buffer (or buffer
                     (get-buffer (read-buffer
                                  "Buffer: "
                                  (buffer-name
                                   (current-buffer))
                                  t))))
         (name (or name
                   (read-string "Name: "
                                nil
                                nil
                                (buffer-name buffer))))
         (sync-context (and (fboundp 'futon4--article-context-for-buffer)
                            (futon4--article-context-for-buffer buffer))))
    (scholium name buffer nil nil (sch-book))
    (when sync-context
      (let* ((article-path (plist-get sync-context :path))
             (article-id (and (fboundp 'futon4--article-id-for)
                              (futon4--article-id-for name article-path))))
        (when (and article-id (fboundp 'futon4-ensure-article-entity))
          (futon4-ensure-article-entity article-id name article-path))))))

(defun make-current-buffer-into-article (name)
  (interactive (list (read-string
                      (concat "Name (default "
                              (buffer-name (current-buffer)) "): ")
                      nil
                      nil
                      (buffer-name (current-buffer)))))
  (make-buffer-into-article (current-buffer) name))

(defun make-file-into-article (path name)
  (interactive
   (let* ((bufn (buffer-file-name))
          (pth (read-file-name
                (if bufn
                    (concat "File (default: " bufn "): ")
                  (concat "File: "))
                nil
                (if bufn
                    bufn
                  (default-directory))))
          (dnme (file-name-nondirectory pth))
          (nme (read-string (concat "Name (default: " dnme "): ")
                            nil
                            nil
                            dnme)))
     (list pth nme)))
  (scholium name path nil '(file) (sch-book))
  (let* ((canonical (and (fboundp 'futon4--canonical-path)
                         (futon4--canonical-path path)))
         (article-id (and (fboundp 'futon4--article-id-for)
                          (futon4--article-id-for name canonical))))
    (when (and article-id (fboundp 'futon4-ensure-article-entity))
      (futon4-ensure-article-entity article-id name canonical))))


;; from 4.3-Interactively_supplying_text.el
(defvar new-scholium-name nil "Name of our new scholium.")
(defvar new-scholium-about nil "What the new scholium is about.")

(define-minor-mode new-scholium-mode
  "Mode for composing a new scholium.
\\{new-scholium-mode-map}"
  :init-value nil
  :keymap '(("\C-c\C-c" . escape-scholium-creation)))

(defun escape-scholium-creation ()
  (interactive)
  (scholium new-scholium-name
            (buffer-substring-no-properties (point-min) (point-max))
            new-scholium-about
            nil
            (sch-book))
  (kill-buffer (concat "Editing scholium: " new-scholium-name))
  (set-window-configuration sch-win-config)
  (setq new-scholium-name nil
        new-scholium-about nil))

(defun make-scholium ()
  (setq sch-win-config (current-window-configuration))
  ;; we allow this to be set elsewhere
  (unless new-scholium-name
    (setq new-scholium-name (read-string "Scholium name: ")))
  (set-buffer (get-buffer-create "Scholia Display"))
  (other-window -1)
  (split-window-vertically)
  (other-window 1)
  (switch-to-buffer (get-buffer-create (concat "Editing scholium: "
                                               new-scholium-name)))
  (new-scholium-mode))

(defun make-scholium-about-current-article ()
  (interactive)
  (when name-of-current-article
    (setq new-scholium-about `(((,name-of-current-article))))
    (make-scholium)))

(defun make-scholium-about-part-of-current-article (beg end)
  (interactive "r")
  (if name-of-current-article
      (progn
        (setq new-scholium-about
              `((,name-of-current-article
                  (passage 
                   ,beg
                   ,end))))
        (make-scholium)
        (deactivate-mark)
        (message (concat (format "%s--%s" beg end) " added.")))
    (message "Make some article current first.")))

(defun make-scholium-about-current-line ()
  (interactive)
  (make-scholium-about-part-of-current-article (line-beginning-position)
                                               (line-end-position)))

(defun make-scholium-about-current-line-quickly ()
  (interactive)
  (setq new-scholium-name (buffer-substring-no-properties
                           (line-beginning-position)
                           (line-end-position)))
  (make-scholium-about-part-of-current-article (line-beginning-position)
                                               (line-end-position)))

(defun make-scholium-about-current-line-quickly-and-completely ()
  (interactive)
  (scholium (buffer-substring-no-properties
                           (line-beginning-position)
                           (line-end-position))
            (buffer-substring-no-properties
                           (line-beginning-position)
                           (line-end-position))
            `((,name-of-current-article 
               (passage
                ,(line-beginning-position)
                ,(line-end-position))))
            nil
            (sch-book)))

(defun make-scholium-about-current-sentence ()
  (interactive)
  (make-scholium-about-part-of-current-article (line-beginning-position)
                                               (line-end-position)))

(define-minor-mode reading-regions-mode
  "Mode for reading in regions.
\\{new-scholium-mode-map}"
  :init-value nil
  :keymap '(("\C-c\C-c" . add-region)
            ("\C-c\C-g" . escape-reading-regions-mode))
  (message "C-c C-c to add regions; C-c C-g to make scholium."))

(defun add-region (beg end)
  (interactive "r")
  (setq new-scholium-about
        (cons `(,name-of-current-article
                 (passage 
                  ,(region-beginning)
                  ,(region-end)))
              new-scholium-about))
  (deactivate-mark)
  (message (concat (format "%s--%s" beg end) " added.")))

(defun escape-reading-regions-mode ()
  (interactive)
  (reading-regions-mode -1)
  (make-scholium))

(defun make-scholium-about-several-parts-of-current-article ()
  (interactive)
  (let ((article (get-article name-of-current-article)))
    (if (article-buffered article)
        (switch-to-buffer (get-buffer (scholium-text article)))
      (switch-to-buffer "Main Article Display"))
    (setq new-scholium-about nil)
    (reading-regions-mode 1)))

(defun call-if-user-adds-current-buffer-to-article-list (fct)
  (when (y-or-n-p "Buffer not an article, add to list? ")
        (make-current-buffer-into-article
         (read-string (concat "Name (default: "
                              (buffer-name
                               (current-buffer)) "): ")
                      nil
                      nil
                      (buffer-name (current-buffer))))
        (funcall fct)))

(defun make-scholium-about-current-buffer ()
  (interactive)
  (let ((article (get-article (buffer-name (current-buffer)))))
    (if (not article)
        (call-if-user-adds-current-buffer-to-article-list
         'make-scholium-about-current-buffer)
      (setq new-scholium-about
            `(((,(buffer-name (current-buffer))))))
      (make-scholium))))

(defvar *reference-counter* 0)

(defun genref ()
  (setq *reference-counter* (1+ *reference-counter*)))

(defun make-reference-in-current-article (beg end &optional target)
  (interactive "r")
  (let ((target (or target
                    (read-article-name))))
    (if name-of-current-article
        (when target
          (scholium `(reference ,name-of-current-article ,(genref))
                    nil
                    `((,name-of-current-article
                       (passage 
                        ,beg
                        ,end))
                      (,target))
                    'reference)
          (deactivate-mark))
      ;; Maybe the message should instead be an offer to make
      ;; a scholium about the current buffer?
      (message "Make some article current first."))))

(defun create-follow-reference ()
  (interactive)
  (let ((name (buffer-substring (point) (mark))))
    (unless (get-article name)
      (save-excursion
        (set-buffer (get-buffer-create name))
        (make-current-buffer-into-article name)))
    (make-reference-in-current-article (min (point) (mark))
                                       (max (point) (mark))
                                       name)
    (display-article name)))

(defun reference-source-link (reference)
  (first (scholium-about reference)))

(defun reference-from-article (reference)
  (car (reference-source-link reference)))

(defun reference-to-article (reference)
 (car (second (scholium-about reference))))

(defun make-new-undirected-article ()
  (interactive)
  (setq new-scholium-about nil)
  (make-scholium))

(defun name-of-current-scholium ()
  (interactive)
  (save-excursion
    (set-buffer (get-buffer-create "Scholia Display"))
    (let ((ret (car (scholia-named-at-point))))
      (if ret
          (message (format "%s" ret))
        (message "Position cursor on a scholium in Scholia Display."))
      ret)))

(defun make-scholium-about-current-scholium ()
  (interactive)
  (when (equal (buffer-name (current-buffer)) "Scholia Display")
    (let ((cur (name-of-current-scholium)))
      (when cur
        (progn (setq new-scholium-about `(((,cur))))
               (make-scholium))))))


;; from 5.1-Formatting_articles_for_display.el
(defvar sch-plain-text-hook nil)

(defun sch-plain-text (title-or-article)
  ;; this overloading of the input & reliance upon `get-article' to
  ;; sort things out... could probably be revised into something
  ;; better
  (let* ((obj (or (get-article title-or-article)
                  title-or-article))
         (text (scholium-text obj))
         (type (scholium-type obj))
         ret)
    ;; This seems like the correct way to override a `cond' form.
    (run-hooks 'sch-plain-text-hook)
    (when (not ret)
      (cond
       ((bufferp text)
        (save-excursion (set-buffer (get-buffer text))
                        (setq ret (buffer-string))))
       ((typedata-includes type 'file)
        (let ((bufs (buffer-list))
              (live nil))
          (while (and bufs (not live))
            (when (equal (buffer-file-name (car bufs))
                         (expand-file-name text))
              (setq live (car bufs)))
            (setq bufs (cdr bufs)))
          (if live
              (progn (set-buffer live)
                     (setq ret (buffer-string)))
            (find-file text)
            (setq ret (buffer-string))
            (kill-buffer (current-buffer)))))
       ;; these quoted things should presumably themselves be rendered
       ;; as links (and we probably don't need the crazy markup for
       ;; things about the whole buffer, ever)
       ((typedata-includes type 'reference)
        (if (equal (reference-to-article obj)
                   name-of-current-article)
            (setq ret
                  ;; it might be kind of cool to at least include a
                  ;; snippet of the context of this link, say 3 lines
                  ;; worth
                  (format "\"%s\" links here."
                          (reference-from-article obj)))
          (setq ret
                (format "This is a link from \"%s\" to \"%s\"."
                        (reference-from-article obj)
                        (reference-to-article obj)
                        obj))))
       ((stringp text)
        (setq ret text))
       (t
        (setq ret (format "%S" text)))))
    ret))


;; from 5.2-Managing_windows_and_buffers.el
(defvar pre-sch-win-config nil "Saved window configuration.")
(defvar sch-win-config nil "Saved window configuration.")

(defvar buffer-associated-with-current-article nil)

(defun article-buffered (article)
  (bufferp (scholium-text article)))

(defun scholia-overwhelm-display (text)
  (unless pre-sch-win-config
    (setq pre-sch-win-config (current-window-configuration)))
  (delete-other-windows)
  (split-window-horizontally)
  (if rendering-target-buffer
      (pop-to-buffer rendering-target-buffer t)
    (switch-to-buffer (get-buffer-create "Main Article Display") t))
  (erase-buffer)
  (insert text)
  (goto-char (point-min))
  (setq buffer-associated-with-current-article (current-buffer))
  (other-window 1)
  (switch-to-buffer (get-buffer-create "Scholia Display") t)
  (erase-buffer))

(defun back-to-normal ()
  (interactive)
  (setq sch-win-config (current-window-configuration))
  (set-window-configuration pre-sch-win-config)
  (setq pre-sch-win-config nil))

(defun back-to-other-view ()
  (interactive)
  (setq pre-sch-win-config (current-window-configuration))
  (set-window-configuration sch-win-config)
  (setq sch-win-config nil))


;; from 5.3-Sorting_scholia_for_markup_purposes.el
(defun first-beginning-about-article (about article)
  (cond
   ;; condition for the scholium to be about the article as a whole.
   ;; The condition is that there is _some_ link to the article that
   ;; is NOT a ``passage''-type link.  In this case, we just return 0.
   ((member-if (lambda (link) 
                 (and (equal (car link) article)
                      (not (link-type-accessor link 'passage))))
               about)
    0)
   ;; else, collect the regions of `article' that `about' indicates,
   ;; and sort them.
   (t
    (let* ((marking-links
            (let (marked)
              (mapc (lambda (elt)
                      (when (and
                             (typedata-includes-passage (link-type elt))
                             (equal (linked-to-article elt) article))
                        (setq marked (cons elt marked))))
                    about)
              marked))
           (earliest-link
            (car (sort
                  marking-links
                  (lambda (link1 link2)
                    (< (link-beginning link1)
                       (link-beginning link2)))))))
      (link-beginning earliest-link)))))

(defun sort-scholia-by-beg-position (scholia article)
  (setq
   scholia
   (sort scholia
         (lambda (scholium1 scholium2)
           (let ((beg1 (first-beginning-about-article 
                        (scholium-about scholium1)
                        article))
                 (beg2 (first-beginning-about-article
                        (scholium-about scholium2)
                        article)))
             (and beg1
                  beg2
                  (< beg1 beg2)))))))


;; from 5.4-Marking_things_up.el
(defmacro new-simple-scholium-face (num color doc)
  (let ((prop (intern (concat "sch-face-" (int-to-string num)))))
    `(progn
       (defvar  ,prop ',prop)
       (defface ,prop
         '((t (:foreground ,(symbol-name color)
               :underline ,(symbol-name color)))) ,doc))))

(new-simple-scholium-face 1 maroon1 "First scholium face.")
(new-simple-scholium-face 2 aquamarine1 "Second scholium face.")
(new-simple-scholium-face 3 IndianRed1 "Third scholium face.")
(new-simple-scholium-face 4 yellow1 "Fourth scholium face.")
(new-simple-scholium-face 5 firebrick1 "Fifth scholium face.")
(new-simple-scholium-face 6 plum1 "Sixth scholium face.")

(defface sch-reference-face
  '((t (:foreground "red" :underline "red")))
  "Face for references in the scholium system.")

(defvar scholia-count 0 "Number of scholia about the article found.")

(defun scholium-face ()
  (let ((short-count (mod scholia-count 6)))
    (cond ((eq short-count 0)
           'sch-face-1)
          ((eq short-count 1)
           'sch-face-2)
          ((eq short-count 2)
           'sch-face-3)
          ((eq short-count 3)
           'sch-face-4)
          ((eq short-count 4)
           'sch-face-5)
          ((eq short-count 5)
           'sch-face-6))))

(defvar use-crazy-font-lock t)
(defvar main-article-overlays nil)
(defvar scholia-overlays nil)

(defun get-rendering-target-buffer ()
  (get-buffer (or rendering-target-buffer
                  (get-buffer "Main Article Display"))))

(defun set-buffer-to-rendering-target-buffer ()
  (set-buffer (get-rendering-target-buffer)))

(defun add-to-scholia-property-within-region (start end value)
  (while (< start end)
    (put-text-property start (1+ start) 'scholia
                       (add-to-or-start-list
                        (get-text-property start 'scholia)
                        value))
    (setq start (1+ start))))

(defvar current-markup nil)

(defun mark-up-region (start end value)
  (add-to-scholia-property-within-region start end value)
  (setq current-markup
        (add-to-or-start-list current-markup
                              (list value start end))))

(defvar non-printing-types nil)

(defun compute-usable-about-data ()
  (let (usable-data
        (about (scholium-about scholium))
        (masks (get-metadata-field 'masks
                                   (scholium-name
                                    scholium)))
        (link-number 0))
    (dolist (link about)
      (setq link-number (1+ link-number))
      (when (link-about-article-p link name-of-current-article)
        (let* ((link-id (list (scholium-name scholium) link-number))
               (mask (assoc link-id masks)))
          (if mask
              (dolist (reg (cdr mask))
                (setq usable-data
                      (add-to-or-start-list
                       usable-data
                       `((mask ,(car mask)) ,@reg))))
            (setq usable-data
                  (add-to-or-start-list
                   usable-data
                   (append (list (list (scholium-name scholium)
                                       link-number))
                           (let ((beg (link-beginning link)))
                             (if beg 
                                 (list beg (link-end link))
                               (list nil))))))))))
    usable-data))

(defvar mark-things-up-customizations nil)

(defvar scholia-display-pre-update-hook nil)

(defun pre-mark-up ()
  (setq current-markup nil)
  (save-excursion
    (set-buffer-to-rendering-target-buffer)
    (remove-list-of-text-properties (point-min)
                                    (point-max)
                                    '(scholia)))
  (mapcar #'delete-overlay main-article-overlays)
  (setq main-article-overlays nil)
  (setq scholia-count 0))

(defvar mark-things-up-hook nil)

(defun mark-things-up ()
  (pre-mark-up)
  (let ((scholia (sort-scholia-by-beg-position
                  raw-scholia
                  name-of-current-article)))
    (dolist (scholium scholia)
      (unless (typedata-includes-element-of-list
               (scholium-type scholium)
               non-printing-types)
        (let ((usable-about-data (compute-usable-about-data))
              (current-position-in-scholia-display (point)))
          (cond
           ((and
             (typedata-includes (scholium-type scholium) 'reference)
             (equal (reference-from-article scholium)
                    name-of-current-article))
            (mark-up-reference))
           (t
            (mark-up-scholium)))))))
  (run-hooks 'mark-things-up-hook))

(defun add-overlays-in-scholia-display-buffer ()
  (setq scholia-overlays
        (cons
         (make-overlay current-position-in-scholia-display
                       (point)
                       (get-buffer "Scholia Display")
                       t)
         scholia-overlays))
  (overlay-put (car scholia-overlays)
               'face (scholium-face)))

(defun add-overlays-in-rendering-target-buffer ()
  (setq main-article-overlays
        (cons
         (make-overlay (second elt)
                       (third elt)
                       (get-rendering-target-buffer)
                       t)
         main-article-overlays))
  (overlay-put (car main-article-overlays)
               'face (scholium-face)))

(defun mark-up-reference ()
  (save-excursion
    (set-buffer-to-rendering-target-buffer)
    (dolist (elt usable-about-data)
      (mark-up-region (second elt)
                      (third elt)
                      (first elt))
      (when use-crazy-font-lock
        (setq main-article-overlays
              (cons
               (make-overlay (second elt)
                             (third elt)
                             (get-rendering-target-buffer)
                             t)
               main-article-overlays))
        (overlay-put (car main-article-overlays)
                     'face 'sch-reference-face)))))

(defun mark-up-scholium ()
  ;; this part takes place in the scholia display buffer
  (insert (sch-plain-text (scholium-name scholium)))
  (add-to-scholia-property-within-region
   current-position-in-scholia-display
   (point)
   ;; add a list to make it possible to reuse the scholium property
   (list (scholium-name scholium)))
  (when use-crazy-font-lock
    (add-overlays-in-scholia-display-buffer))
  (insert "\n\n")
  ;; this part is relevant to the buffer containing the main article
  (dolist (elt usable-about-data)
    (when (second elt)
      (save-excursion
        (set-buffer-to-rendering-target-buffer)
        (mark-up-region (second elt)
                        (third elt)
                        (first elt))
        (when use-crazy-font-lock
          (add-overlays-in-rendering-target-buffer)))))
  ;; adjust count once everything else is done here, so same count
  ;; applies in both buffers (useful for coloration purposes)
  (setq scholia-count (1+ scholia-count)))


;; from 5.5-Display_interface.el
(defvar rendering-target-buffer nil)

(defvar scholia-display-post-update-hook nil)

(add-to-list 'non-printing-types 'fake)

(defun scholia-display-extras ()
  ;; this setting is useful for presentations.
  (goto-char (point-min))
  ;; Be careful that this is ignored when the article is saved or
  ;; otherwise processed internally.
  (insert
   "Title: "
   (propertize (format "%s" name-of-current-article) 'face 'italic)
   "\n\n")
  (goto-char (point-max))
  (run-hooks 'scholia-display-extras-hook)
  (goto-char (point-min)))

(defvar display-style 'plain)

(defvar window-displayed-substring nil)

(defun set-display-style (style)
  (cond ((eq style 'contextual)
         ;; we may need a "double hook" here, so we get the local
         ;; hooks set up in the correct window
         (add-hook 'display-article-hook
                   'initiate-contextual-updating)
         (setq display-style 'contextual))
        (t
         (remove-hook 'display-article-hook
                      'initiate-contextual-updating)
         (setq display-style 'plain))))

(defun initiate-contextual-updating ()
  (unless (typedata-includes (scholium-type article) 'label)
    (save-excursion (set-buffer rendering-target-buffer)
                    (add-hook 'window-scroll-functions 
                              'maybe-update-scholia-display nil t))))

(defun maybe-update-scholia-display ()
  (set-window-displayed-substring)
  ;; this is just a ridiculous thing to run -- for testing purposes
  ;; only.  Eventually, we'll actually want to analyse the text, 
  ;; figure out which scholia are relevant, and update the scholia
  ;; display.
  (save-excursion (set-buffer (get-buffer-create "*scratch*"))
                  (erase-buffer)
                  (insert window-displayed-substring)))

(defun set-window-displayed-substring ()
  (setq window-displayed-substring
        (buffer-substring (window-start)
                          (window-end))))

(defvar display-article-hook nil)

(defun raw-scholia-selector (&optional what-is-displayed)
  (cond ((eq what-is-displayed 'label)
         (remove-if                
          (lambda (scholium)
            (member-if (lambda (link)
                         (member 'parent (cdr link)))
                       (scholium-about scholium)))
          (mapcar (lambda (backlink)
                    (get-article (car backlink)))
                  (get-backlinks name-of-current-article))))
        (t (mapcar (lambda (backlink)
                     (get-article (car backlink)))
                   (get-backlinks name-of-current-article)))))

;; (eq display-style 'contextual)
;;          (save-excursion (set-buffer (get-buffer-create "*scratch*"))
;;                          (erase-buffer)
;;                          (insert window-displayed-substring))
;;          nil

(defun display-article (path)
  (interactive (list (read-article-path)))
  (let* ((article (generalized-get-article path))
         (name (scholium-name article)))
    (if (not article)
        (error "No article by that name found")
      (setq name-of-current-article name)
      (cond
       ((typedata-includes (scholium-type article) 'label)
        (display-label name)
        (setq rendering-target-buffer "*Generic List*")
        (switch-to-buffer (get-buffer "*Generic List*"))
        (setq buffer-read-only nil)
        (switch-to-buffer (get-buffer-create "Scholia Display") t)
        (erase-buffer)
        (let ((raw-scholia (raw-scholia-selector 'label)))
          (mark-things-up))
        (scholia-display-extras)
        (switch-to-buffer (get-buffer "*Generic List*"))
        (setq buffer-read-only t)
        (pop-to-buffer "Scholia Display")
        (other-window -1))
       (t
        (if (article-buffered article)
            (setq rendering-target-buffer (scholium-text article))
          (setq rendering-target-buffer nil))
        (run-hooks 'scholia-display-pre-update-hook)
        (scholia-overwhelm-display (sch-plain-text article))
        (let ((raw-scholia (raw-scholia-selector)))
          (mark-things-up))
        (scholia-display-extras)
        (pop-to-buffer (get-rendering-target-buffer))
        (run-hooks 'scholia-display-post-update-hook)))
      (run-hooks 'display-article-hook))))

(defun redisplay-article ()
  (interactive)
  (display-article name-of-current-article))

(defun display-scholia-about-current-buffer ()
  (interactive)
  (let ((article (get-article (buffer-name (current-buffer)))))
    (if article
        (progn
          (setq rendering-target-buffer (current-buffer))
          (run-hooks 'scholia-display-pre-update-hook)
          (scholia-overwhelm-display (sch-plain-text article))
          (let ((raw-scholia
                 (mapcar (lambda (backlink)
                          (get-article (car backlink)))
                         (get-backlinks name-of-current-article))))
            (mark-things-up))
          (scholia-display-extras)
          (pop-to-buffer (get-rendering-target-buffer))
          (run-hooks 'scholia-display-post-update-hook)
          ;; weird!
          (run-hooks 'display-article-hook))
      (call-if-user-adds-current-buffer-to-article-list
       'display-scholia-about-current-buffer))))

(defvar display-label-hook nil)

(defvar currently-displayed-label nil)

(defun display-label (name)
  (interactive 
   (list
    (let* ((completion-ignore-case t)
           (label-names
            (scholium-text (get-article 'label)))
           (label-strings (mapcar (lambda (name) 
                                    (format "%s" name))
                                  label-names))
           (string-found (completing-read
                          "Label: "
                          label-strings))
           (place (- (length label-strings)
                     (length (member string-found label-strings)))))
      (nth place label-names))))
  (article-menu-listing (label-to-propertized-list name))
  (run-hooks 'display-label-hook))

(add-hook 'display-label-hook (lambda ()
                                (setq currently-displayed-label name)))

(defalias 'list-label 'display-label)

(defun display-intersection-of-labels (&rest labels)
  (let ((intersection (label-to-list (car labels)))
        (ctn (cdr labels)))
    (while ctn
      (setq intersection (intersection intersection
                                       (label-to-list (car ctn))
                                       :test 'equal))
      (setq ctn (cdr ctn)))
    (article-menu-listing (turn-list-into-propertized-list
                           intersection))))

(defun display-difference-of-labels (label-A label-B)
  (article-menu-listing (turn-list-into-propertized-list
                         (set-difference (label-to-list label-A)
                                         (label-to-list label-B)))))

(defun find-marked-regions ()
  (let (names-and-positions
        (next-change-point (point-min)))
    (while next-change-point
      (let ((next-region (find-next-marked-region)))
        (when next-region
          (setq names-and-positions
                (cons next-region
                      names-and-positions)))))
    names-and-positions))

(defun find-next-marked-region ()
  (let* ((beg (next-single-property-change next-change-point
                                           'scholia))
         (end (when beg
                (next-single-property-change beg
                                             'scholia))))
    (setq next-change-point end)
    (when end
      (list
       (get-text-property beg 'scholia)
       (list (cons beg end))))))

(defun sch-turn-main-article-overlays-off ()
  (interactive)
  (mapcar #'delete-overlay main-article-overlays)
  (setq main-article-overlays nil))

(defun sch-turn-scholia-overlays-off ()
  (interactive)
  (mapcar #'delete-overlay scholia-overlays)
  (setq scholia-overlays nil))

(defun sch-turn-main-article-overlays-on ()
  (interactive)
  ;; to save from potential overlap weirdness
  (sch-turn-main-article-overlays-off)
  (save-excursion
    (let ((names-and-positions (find-marked-regions)))
        (dolist (info names-and-positions)
    (let* ((name (car info))
           (marked-regions (cadr info))
           (scholium (get-article name))
           (beg (point)))
      (save-excursion
        (set-buffer-to-rendering-target-buffer)
        (dolist (reg marked-regions)
          ;; add "transient" overlay
          (when use-crazy-font-lock
            (setq main-article-overlays
                  (cons
                   (make-overlay (car reg)
                                 (cdr reg)
                                 (get-rendering-target-buffer)
                                 t)
                   main-article-overlays))
            ;; using `scholium-face' here is a bit weird
            (overlay-put (car main-article-overlays)
                         'face (scholium-face))))))))))

(defun sch-turn-scholia-overlays-on ()
  (interactive)
  )


;; from 6.1-Scholia_browsing.el
(defun move-to-next-region-with-scholium ()
  (interactive)
  (let ((change (next-overlay-change (point))))
    (if (overlays-at change)
        (progn (goto-char change)
               (list change (next-overlay-change change)))
      (if (overlays-at (next-overlay-change change))
          (progn (goto-char (next-overlay-change change))
                 (list (next-overlay-change change)
                       (next-overlay-change (next-overlay-change 
                                             change))))
        (message "No subsequent regions with scholia about them.")
        nil))))

(defun move-to-previous-region-with-scholium ()
  (interactive)
  (let ((change (previous-overlay-change (point))))
    (if (overlays-at change)
        (progn (goto-char change)
               (list change (previous-overlay-change change)))
      (if (overlays-at (previous-overlay-change change))
          (progn (goto-char (previous-overlay-change change))
                 (list (previous-overlay-change change)
                       (previous-overlay-change (previous-overlay-change 
                                             change))))
        (message "No previous regions with scholia about them.")
        nil))))

(defun scroll-article-display-to-next-region-for-current-scholium ()
  (interactive)
  (save-excursion
    (set-buffer buffer-associated-with-current-article)
    (let (found
          (curpoint (point)))
      (while (and (not found)
                  (not (eobp))
                  (move-to-next-region-with-scholium))
        (mapc (lambda (overlay)
                (when (equal (overlay-get overlay 'scholia)
                             (name-of-current-scholium))
                  (setq found t)))
              (overlays-at (point)))
        (if found
            (recenter)))
      (when (not found)
        (goto-char curpoint)
        (message "Scholium not about further regions in buffer.")))))

(defun scroll-article-display-to-previous-region-for-current-scholium ()
  (interactive)
  (save-excursion
    (set-buffer buffer-associated-with-current-article)
    (let (found
          (curpoint (point)))
      (while (and (not found)
                  (not (bobp))
                  (move-to-previous-region-with-scholium))
        (mapc (lambda (overlay)
                (when (equal (overlay-get overlay 'scholia)
                             (name-of-current-scholium))
                  (setq found t)))
              (overlays-at (point)))
        (if found
            (recenter)))
      (when (not found)
        (goto-char curpoint)
        (message "Scholium not about previous regions in buffer.")))))

(defun move-to-first-region-for-scholium (name)
  (pop-to-buffer (get-buffer rendering-target-buffer))
  (let ((beg (point-max))
        (about (scholium-about (get-article name))))
    (dolist (link about)
      ;; this should be revised in light of the
      ;; fact that a link can be multiply typed
      (when (and (typedata-includes-passage (link-type elt))
                 (equal (linked-to-article link)
                        name-of-current-article)
                 (< (link-beginning link) beg))
        (setq beg (link-beginning link))))
    (unless (equal beg (point-max))
      (goto-char beg))))

(defun move-to-first-region-for-current-scholium ()
  (interactive)
  (let ((current (name-of-current-scholium)))
    (move-to-first-region-for-scholium current)))


;; from 6.2-Local_browsing.el
(defun read-scholia-property-at-point ()
  (get-text-property (point) 'scholia))

(defun scholia-named-at-point ()
  (mapcar (lambda (id)
            (if (eq (car id) 'mask)
                (car (second id))
              (car id)))
          (read-scholia-property-at-point)))

(defun follow-scholium ()
  (interactive)
  (let ((current (name-of-current-scholium)))
    (when current
      (display-article current))))

(defun follow-reference ()
  (interactive)
  (let ((references
         (remove-if (lambda (name)
                      (not (typedata-includes
                            (scholium-type (get-article name))
                            'reference)))
                    (scholia-named-at-point))))
    (cond
     ((equal (length references) 1)
      (let* ((ref (get-article (car references)))
             (to-article (reference-to-article ref)))
        (if (equal to-article name-of-current-article)
            (display-article (reference-from-article ref))
          (display-article to-article)))
      ;; maybe `display-article' should be returning
      ;; some non-`nil' value so that we don't have to do this.
      t)
     (references
      ;; this sort of disambiguation is really only needed if the
      ;; references have different targets.  Two distinct references
      ;; to the same thing overlaying each other could be treated as
      ;; one for simple following purposes.
      (list-articles references))
     (t
      (message "No reference at point.")
      nil))))

(defun follow-reference-or-scholium ()
  (interactive)
  (unless (follow-reference)
    (follow-scholium)))

(defun display-an-article-that-current-article-is-about ()
  (interactive)
  (let ((abouts (scholium-about
                 (get-article name-of-current-article))))
    (cond
     ((equal (length abouts) 1)
      (display-article (car abouts)))
     (abouts
      (list-articles abouts))
     (t
      (message "Article isn't about any other articles.")))))

(defun current-scholium-is-about ()
  (scholium-about (get-article (name-of-current-scholium))))

(defun display-an-article-that-current-scholium-is-about ()
  (interactive)
  (let ((abouts (current-scholium-is-about)))
    (cond
     ((equal (length abouts) 1)
      (display-article (car abouts))
      (message "Note: scholium is only about current article."))
     (abouts
      (list-articles abouts))
     (t
      (message "Article isn't about any other articles.")))))


;; from 6.3-Catalog_browsing.el
(defmacro make-generic-menu-mode
  (mode bindings)
  (let* ((modedash (downcase (replace-regexp-in-string " " "-" mode)))
         (modesymbol (intern (concat modedash "-mode")))
         (mapname (intern (concat modedash "-map"))))
    `(progn
       (defvar ,mapname)
       (setq ,mapname (make-keymap))
       (suppress-keymap ,mapname t)
       (dolist (binding ,bindings)
         (define-key ,mapname (car binding) (cdr binding)))
       (defun ,modesymbol ()
         (kill-all-local-variables)
         (use-local-map ,mapname)
         (setq major-mode (quote ,modesymbol))
         (setq mode-name ,mode)
         (setq truncate-lines t)
         (setq buffer-read-only t)))))

(defun generic-menu-noselect (objects accessors)
  (let (cols)
    (dolist (get-this accessors)
      ;; if we built this front-to-back rather than back-to-front,
      ;; that would be better
      (setq cols (cons
                  (cons (car get-this)
                        (mapcar (cdr get-this) objects))
                  cols)))
    ;; find the width of the columns.
    (let ((lens (mapcar (lambda (col)
                          (let ((len 0))
                            (dolist (str col)
                              (let ((candidate (length str)))
                                (when (> candidate len)
                                  (setq len candidate))))
                            len))
                        cols)))
      (with-current-buffer (get-buffer-create "*Generic List*")
        (setq buffer-read-only nil)
        (erase-buffer)
        (while cols
          (goto-char (point-min))
          (goto-char (line-end-position))
          (dolist (str (car cols))
            (insert str " ")
            ;; fill with spaces to make up for lost space
            (insert-char 32 (- (car lens) (length str)))
            (unless (equal (forward-line) 0)
              (newline))
            (goto-char (line-end-position)))
          (setq cols (cdr cols))
          (setq lens (cdr lens)))
        (goto-char (point-min))
        (current-buffer)))))

(defun Generic-menu-sort (col)
  (interactive "P")
  (save-excursion
    (sort-fields (or col 1) (progn (goto-line 2)
                                   (point))
                 (point-max))))

(defvar standard-article-menu-accessors
  '(("Name" . identity)
    ("C"    . (lambda (elt) " "))))

(defvar article-menu-listing-hook nil)

(defun article-menu-listing (&optional subset accessors)
  (interactive)
  (pop-to-buffer
   (generic-menu-noselect
    ;; maybe this should always handle propertizing itself?
    (or subset
        (label-to-propertized-list 'plain))
    (or accessors
        standard-article-menu-accessors)))
  ;; note, this runs every time, even if the current article
  ;; isn't on the list.
  (article-menu-point-out-current-article)
  (article-menu-mode)
  (run-hooks 'article-menu-listing-hook))

(add-hook 'article-menu-listing-hook (lambda ()
                                       (setq currently-displayed-label
                                             nil)))

(defun turn-article-table-into-list ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               ;; It might be nice to have %S here, but
               ;; I don't know if it would be _useful_
               (nconc names (list (format "%s" name))))
             article-table)
    (cdr names)))

(defun turn-article-table-into-names ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               (nconc names (list name)))
             article-table)
    (cdr names)))

(defun turn-article-table-into-propertized-list ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               (nconc names
                      (list 
                       (propertize (format "%s" name) 'name name))))
             article-table)
    (cdr names)))

(defun turn-list-into-propertized-list (lis)
  (let (names)
    (mapc (lambda (name)
            (setq names (cons
                         (propertize (format "%s" name) 'name name)
                         names)))
          lis)
    names))

(defun article-menu-list-plain-articles ()
  (interactive)
  (article-menu-listing))

(defun article-menu-list-all-articles ()
  (interactive)
  (article-menu-listing (turn-article-table-into-propertized-list)))

(defun article-menu-list-metadata-articles ()
  (interactive)
  (article-menu-listing (label-to-propertized-list 'metadata)))

(defun article-menu-list-labels ()
  (interactive)
  (article-menu-listing (label-to-propertized-list 'label)))

(defun list-articles (lis)
  (interactive)
  (article-menu-listing (turn-list-into-propertized-list lis)))

(defun article-menu-display-article ()
  (interactive)
  (when (> (line-number-at-pos) 1)
    (save-excursion
      (goto-char (line-beginning-position))
      (search-forward-regexp "[. >] .")
      (setq name-of-current-article
            (get-text-property (point) 'name))
      (article-menu-point-out-current-article)
      (display-article name-of-current-article))))

(defun article-menu-mark-article ()
  (interactive)
  (setq buffer-read-only nil)
  (when (> (line-number-at-pos) 1)
    (goto-char (line-beginning-position))
    (delete-char 1)
    (insert ">")
    (when (< (line-number-at-pos)
             (progn (save-excursion (goto-char (point-max))
                                    (line-number-at-pos))))
      (forward-line 1)))
  (setq buffer-read-only t))

(defun article-menu-unmark-article ()
  (interactive)
  (setq buffer-read-only nil)
  (when (and (> (line-number-at-pos) 1)
             (not (save-excursion (goto-char (line-beginning-position))
                                  (looking-at "\\."))))
    (goto-char (line-beginning-position))
    (delete-char 1)
    (insert " ")
    (when (< (line-number-at-pos)
             (progn (save-excursion (goto-char (point-max))
                                    (line-number-at-pos))))
      (forward-line 1)))
  (setq buffer-read-only t))

(defun article-menu-unmark-all-articles ()
  (interactive)
  (setq buffer-read-only nil)
  (save-excursion (goto-line 2)
                  (goto-char (line-beginning-position))
                  (while (re-search-forward "^>" nil t)
                    (replace-match " ")))
  (setq buffer-read-only t))

(defun article-menu-point-out-current-article ()
  (goto-char (point-min))
  (setq buffer-read-only nil)
  (save-excursion (when (search-forward-regexp "^\\." nil t)
                    (replace-match " ")))
  (when (and
         name-of-current-article
         (search-forward-regexp
          ;; maybe this `(format "%s" name-of-current-article)'
          ;; stuff should be stored as some kind of function,
          ;; like `print-name-of-article' or something like that
          (concat "^[. ] " (regexp-quote
                            (format "%s" name-of-current-article)))
          nil t))
    (replace-match (concat ". " (substring (match-string 0) 2))))
  (goto-char (line-beginning-position))
  (setq buffer-read-only t))

(make-generic-menu-mode "Article Menu"
                        '(("g" . article-menu-listing)
                          ("m" . article-menu-mark-article)
                          ("u" . article-menu-unmark-article)
                          ("U" . article-menu-unmark-all-articles)
                          ("q" . quit-window)
                          ("\C-m" . article-menu-display-article)))

(defun article-menu-list-articles-matching-regexp (regexp)
  (interactive "MRegexp: ")
  (let ((matches (mapcar
                  (lambda (name)
                    (propertize (format "%s" name) 'name name))
                  (remove-if
                   (lambda (elt)
                     (not
                      (with-temp-buffer
                        ;; rough, not bothering with
                        ;; `sch-plain-text'
                        (let ((article (get-article elt)))
                          (insert
                           (format "%s"
                                   (scholium-name (get-article elt)))
                           "\n"
                           (format "%s"
                                   (scholium-text article)))
                          (goto-char (point-min))
                          (search-forward-regexp regexp
                                                 nil t)))))
                   (turn-article-table-into-names)))))
    (if matches
        (article-menu-listing matches)
      (message "No hits."))))

(defun article-menu-list-articles-matching-predicate (pred)
  (let ((matches (mapcar
                  (lambda (name)
                    (propertize (format "%s" name) 'name name))
                  (remove-if (lambda (elt) (not (funcall pred elt)))
                             (turn-article-table-into-names)))))
    (if matches
        (article-menu-listing matches)
      (message "No hits."))))

(defun display-article-listing ()
  (interactive)
  (pop-to-buffer "*Generic List*"))


;; from 6.4-Temporal_browsing.el
(defvar sb-history nil)

(add-hook 'display-article-hook
          (lambda ()
            (sb-add-article-to-history name-of-current-article)))

(defun sb-add-article-to-history (article)
  (setq sb-history (nconc sb-history (list article))))

(defun sb-back ()
  (interactive)
  (let ((current (car (last sb-history)))
        (n 0)
        found)
    (while (not found)
      (if (equal (nth n sb-history) current)
          (progn (setq found t)
                 (if (> n 0)
                     (display-article (nth (1- n) sb-history))
                   (message "Already at beginning of history.")))
        (setq n (1+ n))))))

(defun sb-forward ()
  (interactive)
  (let* ((current (car (last sb-history)))
         (max (1- (length sb-history)))
         (n (1- max))
         found)
    (while (not found)
      (if (equal (nth n sb-history) current)
          (progn (setq found t)
                 (if (< n (1- max))
                     (display-article (nth (1+ n) sb-history))
                   (message "Already at end of future")))
        (setq n (1- n))))))

(defun sb-previous ()
  (car (last sb-history 2)))


;; from 6.5-Linear_browsing.el
(defun add-visible-back-temporal-link ()
  ;; this should be marked up to become a fake link (one that isn't
  ;; displayed in the main buffer)
  (when (sb-previous)
    (insert "\n\n"
            "Back (temporal): ")
    (let ((beg (point)))
      (insert (propertize 
               (format "%s" (sb-previous)) 'face 'sch-reference-face))
      (scholium 'reference-to-previous-article
                nil
                `((,name-of-current-article
                    (passage 
                     ,beg
                     ,(point)))
                  (,(sb-previous)))
                '(reference fake))
      (add-to-scholia-property-within-region
       beg
       (point)
       '(reference-to-previous-article 1 1)))))

(defun add-visible-parent-and-sibling-links ()
  ;; identify the link to the parent, if it exists.
  ;; (this assumes that there is only one parent)
  (let ((link-to-parent (car (member-if (lambda (link)
                                          (member 'parent (cdr link)))
                                         (scholium-about article)))))
    (when link-to-parent
      (let* ((parent (get-article (first link-to-parent)))
             (parent-data
              (scholium-text parent))
             (this-name-headed (member name-of-current-article
                                       parent-data))
             (next (cadr this-name-headed))
             (prev (car (last (butlast parent-data
                                       (length this-name-headed))))))
        (when parent
          (insert "\n\n"
                  "Parent: ")
          (let ((beg (point)))
            (insert (propertize (format "%s" (scholium-name parent))
                                'face 'sch-reference-face))
            (scholium 'reference-to-parent
                      nil
                      `((,name-of-current-article
                          (passage 
                           ,beg
                           ,(point)))
                        (,(scholium-name parent)))
                      '(reference fake))
            (add-to-scholia-property-within-region
             beg
             (point)
             '(reference-to-parent 1 1))))
        (when prev
          (insert "\n\n"
                  "Back (in parent): ")
          (let ((beg (point)))
            (insert (propertize (format "%s" prev) 'face 'sch-reference-face))
            (scholium 'reference-to-previous-article-in-parent
                      nil
                      `((,name-of-current-article
                          (passage 
                           ,beg
                           ,(point)))
                        (,prev))
                      '(reference fake))
            (add-to-scholia-property-within-region
             beg
             (point)
             '(reference-to-previous-article-in-parent 1 1))))
        (when next
          (insert "\n\n"
                  "Forward (in parent): ")
          (let ((beg (point)))
            (insert (propertize (format "%s" next)
                                'face 
                                'sch-reference-face))
            (scholium 'reference-to-next-article-in-parent
                      nil
                      `((,name-of-current-article
                          (passage 
                           ,beg
                           ,(point)))
                        (,next))
                      '(reference fake))
            (add-to-scholia-property-within-region
             beg
             (point)
             '(reference-to-next-article-in-parent 1 1))))))))

(add-hook 'scholia-display-extras-hook
          'add-visible-back-temporal-link)
(add-hook 'scholia-display-extras-hook
          'add-visible-parent-and-sibling-links)

(defun forward-in-parent ()
  (interactive))

(defun backward-in-parent ()
  (interactive))


;; from 7.3-Finding_revised_about_data_by_parsing_text_properties.el
(defun scholia-property-at-changepoints ()
  (let ((next-change-point (point-min))
        change-points)
    (while next-change-point
      (setq change-points (cons (list next-change-point
                                      (get-text-property
                                       next-change-point
                                       'scholia)) 
                                change-points))
      (setq next-change-point (next-single-property-change+predicate
                               next-change-point
                               'scholia
                               'equal)))
    (when (not (null (get-text-property
                      (caar change-points)
                      'scholia)))
      (setq change-points (cons (point-max) change-points)))
    (reverse change-points)))

(defun detect-scholia-structure ()
  (let ((begs-and-ends
         (cons '(-infinity nil)
               (append
                (scholia-property-at-changepoints)
                (list '(infinity nil)))))
        marked-regions)
    (while (> (length begs-and-ends) 1)
      (let ((difference (set-difference (second
                                         (first begs-and-ends))
                                        (second
                                         (second begs-and-ends))))
            opening
            closing)
        (when difference
          (dolist (elt difference)
            (if (member elt (second (second begs-and-ends)))
                (setq opening (cons elt opening))
              (setq closing (cons elt closing))))
          (dolist (elt opening)
            (setq marked-regions
                  (add-to-or-start-list
                   marked-regions
                   `(,elt ,(first (second begs-and-ends))))))
          (dolist (elt closing)
            (let ((found (member-if (lambda (pass)
                                      (equal (first pass) elt))
                                    marked-regions)))
              (setcdr (cdr (car found))
                      (list (first (second begs-and-ends)))))))
        (setq begs-and-ends (cdr begs-and-ends))))
    marked-regions))


;; from 7.4-Committing_edits.el
(defun store-link-masks ()
  (dolist (link-ext current-markup)
    (let* ((matching-regions (remove-if
                              (lambda (markup-item)
                                (not (equal (car markup-item)
                                            (car link-ext))))
                              adjusted-markup))
           (num-matching-regions (length matching-regions))
           (name-of-linking-article (if (eq (first
                                             (car link-ext)) 'mask)
                                        (first (second
                                                (first link-ext)))
                                      (first (first link-ext)))))
      (unless (and (eq num-matching-regions 1)
                   (equal (cdr (first matching-regions))
                          (cdr link-ext)))
        (if (eq (caar link-ext) 'mask)
            ;; swap in a different mask
            (let* ((masks
                    (get-metadata-field 'masks
                                        name-of-linking-article))
                   (current-mask-headed
                    (member-if (lambda (item)
                                 (equal (second (car link-ext))
                                        (car item)))
                               masks)))
              (setcdr (car current-mask-headed)
                      (mapcar (lambda (ided-reg) 
                                (cdr ided-reg))
                              matching-regions))
              (put-metadata-field 'masks
                                  masks
                                  name-of-linking-article))
          ;; create a new mask
          (let ((masks (or (get-metadata-field
                            'masks
                            name-of-linking-article)
                           (list 'masks))))
            (put-metadata-field
             'masks
             (setcdr
              masks
              (add-to-or-start-list
               (cdr masks)
               `(,(car link-ext)
                 ,@(mapcar (lambda (ided-reg) (cdr ided-reg))
                           matching-regions))))
             name-of-linking-article)))))))

(defvar commit-edits-hook nil)

(defvar after-committing-edits-hook nil)

(defun commit-edits ()
  (interactive)
  (let* ((adjusted-markup (copy-tree (detect-scholia-structure)))
         (old-contents (get-article name-of-current-article))
         (adjusted-text (buffer-substring-no-properties (point-min)
                                                        (point-max)))
         (old-text (scholium-text old-contents)))
    (store-link-masks)
    (run-hooks 'commit-edits-hook)
    ;; here is where the criterion for checking that some change has
    ;; actually been made would be inserted
    (when (not (equal adjusted-text old-text))
      (scholium name-of-current-article
                (with-temp-buffer (insert adjusted-text)
                                  (goto-char (point-max))
                                  (insert "\n")
                                  (delete-blank-lines)
                                  (buffer-substring-no-properties
                                   (point-min)
                                   (point-max)))
                ;; of course, for more advanced versions of
                ;; this code, these won't be static
                (scholium-about old-contents)
                (scholium-type old-contents)
                ;; this should be reformatted to store the old
                ;; version!
                (scholium-bookkeeping old-contents)))
    (run-hooks 'after-committing-edits-hook)))

(add-hook 'after-committing-edits-hook 'redisplay-article)


;; from 7.5-Editing_en_masse.el
(defun label-marked-articles (label)
  (interactive (list
                (intern (let ((completion-ignore-case t))
                          (completing-read
                           "Label: "
                           (label-to-list 'label))))))
  (let (article-names)
    (save-excursion
      (goto-line 2)
      (goto-char (line-beginning-position))
      (while (re-search-forward "^> ." nil t)
        (setq article-names
              (append article-names
                      (list
                       (get-text-property (point) 'name))))))
    (dolist (name article-names)
      (label-article name label))))


;; from 7.6-Deletion.el
(defvar delete-article-hook nil)

(defun delete-article (name)
  (interactive (list (read-article-name)))
  (let ((article (get-article name)))
    (if article
        (progn
          (remhash name article-table)
          (when (equal name name-of-current-article)
            (setq name-of-current-article nil))
          (run-hooks 'delete-article-hook))
      (error "No article by that name found"))))

(defun remove-appearances-in-history ()
  (setq sb-history (delete name sb-history)))

(add-hook 'delete-article-hook 'remove-appearances-in-history)

(defun delete-scholium-associated-with-current-marked-region ()
  (interactive)
  (let ((linked-scholia (scholia-named-at-point)))
    (cond
     ((eq (length linked-scholia) 0)
      (message "No scholium attached here."))
     ((eq (length linked-scholia) 1)
      (delete-article (car linked-scholia)))
     (t
      (list-articles linked-scholia)
      (message
       "Inspect articles and select items for deletion with \"d\".")))))


;; from 7.8-Editing_labels.el
(defun article-menu-insert-new-article ()
  (interactive)
  (if currently-displayed-label
      (let ((new-entry (read-string "New entry: "))
            (old-entry (save-excursion
                         (goto-char (line-beginning-position))
                         (search-forward-regexp "[. >] ." nil t)
                         (setq name-of-current-article
                               (get-text-property (point) 'name)))))
        (setq new-scholium-name new-entry)
        (let ((line (line-number-at-pos)))
          (if old-entry
              (label-article-insert-before
               new-entry old-entry currently-displayed-label)
            (label-article new-entry currently-displayed-label))
          (display-label currently-displayed-label)
          (goto-line line))
        (make-scholium))
    (message "Listing doesn't represent a label.")))

(define-key article-menu-map "i" 'article-menu-insert-new-article)


;; from 8.2-Transclusion.el
;; totally not working yet!
(defun transclude-article (article)
  (interactive (list (read-article-name)))
  (let ((current (get-article name-of-current-article))
        newtext)
    ;; it really doesn't make sense to use something like this here --
    ;; we only deal with the internal format at commit time.
    (unless (and (listp current)
                 (eq (car current) 'twd))
           (setq newtext `(twd
                           ,(scholium-text current))))
    (let ((beg (point)))
      (insert (sch-plain-text (get-article article)))
      ;; this condition isn't really strong enough
      (when name-of-current-article
        (scholium
         `(derives-from ,name-of-current-article ,article ,(genref))
         nil
         `((passage (,name-of-current-article
                     ,beg
                     ,(point))))
         'derives-from
         'system)))))


;; from 8.3-Inclusion.el
(defun include-article (article)
  (interactive (list (read-article-name)))
  (let ((beg (point)))
    (insert (sch-plain-text (get-article article)))
    ;; this condition isn't really strong enough
    (when name-of-current-article
      (scholium
       `(derives-from ,name-of-current-article ,article ,(genref))
       nil
       `((passage (,name-of-current-article
                   ,beg
                   ,(point))))
       'derives-from
       'system))))

(add-to-list 'non-printing-types 'derives-from)


;; from 8.4-Identification.el
(defun insert-identification-at-point (article-name)
  (interactive (list (read-article-name)))
  (let ((beg (point)))
    (insert (sch-plain-text article-name))
    (add-to-scholia-property-within-region
     beg
     (point)
     ;; there aren't any links, so there's no proper linkid
     `(identifies-with ,article-name))))

(defun propagate-changes-to-identification-source ()
  (when (not (equal (buffer-substring-no-properties
                     (second (car identifications))
                     (third (car identifications)))
                    (sch-plain-text
                      (second (caar identifications)))))
    (let ((source (get-article (second (caar identifications)))))
      ;; compare `commit-edits'.  When we actually do
      ;; document versions, this should update the version
      ;; number and any other metadata about how this
      ;; version was created that we get interested in.
      (scholium (second (caar identifications))
                ;; this is bad, since it is storing
                ;; the rendered text, whereas we should of course
                ;; be storing the formatted-for-internal-storage
                ;; text.  But I suppose this is OK for testing
                ;; purposes (wherein we'll only have one level
                ;; of identification).
                (buffer-substring-no-properties
                 (second (car identifications))
                 (third (car identifications)))
                (scholium-about old-contents)
                (scholium-type old-contents)
                (scholium-bookkeeping old-contents)))))

(defun store-updates-from-identification-images ()
  (let ((identifications (remove-if
                          (lambda (elt)
                            (not (eq (caar elt) 'identifies-with)))
                          adjusted-markup))
        (pt 1)
        formatted-contents)
    (while identifications
      (if (< pt (second (car identifications)))
          (setq formatted-contents
                (append
                 formatted-contents
                 (list (buffer-substring-no-properties
                        pt (second (car identifications)))
                       `(ident ,(second (caar identifications)))))
                pt (third (car identifications)))
        (setq formatted-contents
              (append
               formatted-contents
               (list `(ident ,(second (caar identifications)))))
              pt (third (car identifications))))
;      (propagate-changes-to-identification-source)
      (setq identifications (cdr identifications)))
    (when formatted-contents
      (when (< pt (point-max))
        (setq formatted-contents
              (append
               formatted-contents
               (list (buffer-substring-no-properties
                      pt (point-max))))))
      (setq adjusted-text (list 'twd formatted-contents)))))

(add-hook 'commit-edits-hook 'store-updates-from-identification-images)


;; from 8.5-Rendering_articles_containing_derivative_portions.el
(defvar transcluded-parts nil)
(defvar identified-parts nil)
(defvar included-parts nil)

(defun unwind-derivatives ()
  (set-buffer (get-buffer-create " *Unwinding Derivatives*"))
  (dolist (elt (cdr text))
    (if (stringp elt)
        (insert elt)
      (let (object)
        (cond
         ((eq (car elt) 'transclude)
          (setq object (cdr elt))
          (setq transcluded-parts (cons `(,object ,(point))
                                        transcluded-parts)))
         ((eq (car elt) 'identify)
          (setq object (cdr elt))
          (setq identified-parts (cons `(,object ,(point))
                                       identified-parts)))
         (t
          (setq object elt)))
        (insert (sch-plain-text object))
        (cond
         ((eq (car elt) 'transclude)
          (setcdr (cdar transcluded-parts) `(,(point))))
         ((eq (car elt) 'ident)
          (setcdr (cdar identified-parts) `(,(point))))))))
  (setq ret (buffer-string)))

(defun prep-for-rendering-text-with-derivative-components ()
  (setq transcluded-parts nil
        identified-parts nil
        included-parts nil)
  (save-excursion
    (set-buffer (get-buffer-create
                 " *Unwinding Derivatives*"))
    (erase-buffer)))

(add-hook 'scholia-display-pre-update-hook
          'prep-for-rendering-text-with-derivative-components)

(add-hook 'sch-plain-text-hook
          '(lambda ()
             (when (and (listp text) (eq (car text) 'twd))
               (unwind-derivatives))))

(defun add-inclusion-and-transclusion-markup ()
  (save-excursion
    (set-buffer-to-rendering-target-buffer)
    (dolist (elt identified-parts)
      (add-to-scholia-property-within-region
       (second elt)
       (third elt)
       `(identifies-with ,(first elt))))
    ;; this may end up having to be considerably more complicated
    (dolist (elt transcluded-parts)
      (add-to-scholia-property-within-region
       (second elt)
       (third elt)
       `(transclusion-of ,(first elt))))))

(add-hook 'mark-things-up-hook 'add-inclusion-and-transclusion-markup)


;; from 8.7-Quick_compilations_and_other_listing_tricks.el
(defun find-names-in-listing (just-marked)
  (let ((names (list t)))
    (save-excursion
      (set-buffer (get-buffer-create "*Generic List*"))
      (goto-char (point-min))
      (while (and (not (eobp))
                  (if just-marked
                      (search-forward-regexp "^>" nil t)
                    t))
        (let* ((next-change (next-single-property-change 
                             (point) 'name))
               (prop (when next-change
                       (get-text-property next-change 'name))))
          (if (not next-change)
              (goto-char (point-max))
            (goto-char next-change)
            (when prop 
              (nconc names (list prop)))))))
    (cdr names)))

(defun listing-to-compilation (just-marked-items)
  (interactive "P")
  (let ((names (find-names-in-listing just-marked-items)))
    (pop-to-buffer (get-buffer-create "*Compilation*"))
    (erase-buffer)
    (dolist (name names)
      (let ((article (get-article name)))
        (insert (upcase 
                 (propertize (format "%s" (scholium-name article))
                             'face 'italic))
                 "\n"
                 (format "%s" (scholium-text article))
                 "\n")))
    (goto-char (point-min))))

(defun listing-to-compilation-1 (just-marked-items)
  (interactive "P")
  (let ((names (find-names-in-listing just-marked-items)))
    (pop-to-buffer (get-buffer-create "*Compilation*"))
    (erase-buffer)
    (dolist (name names)
      (let ((article (get-article name)))
        (insert  "\*** "
                 (propertize (format "%s" (scholium-name article))
                             'face 'italic)
                 "

"
                 "\n"
                 (format "%s" (scholium-text article))
                 "\
"
                 "\n\n")
        (dolist (scholium (mapcar (lambda (backlink)
                                    (get-article (car backlink)))
                                  (get-backlinks name)))
          (when (typedata-includes (scholium-type scholium) 'code)
            (insert "\\b" "egin{lisp}\n"
                    (scholium-text scholium)
                    "\\e" "nd{lisp}\n\n")))))
    (goto-char (point-min))))

(defun listing-to-label (label-name)
  (interactive "MLabel: ")
  (let ((names (find-names-in-listing)))
    (scholium label-name
              (cdr names)
              nil
              'label
              (sch-book))))


;; from 9-Saving_and_restoring.el
(defun save-all-scholia (filename)
  (interactive (list
                (read-file-name "Filename: ")))
  (save-window-excursion
    (gather-scholia)
    (write-file filename)
    (kill-buffer (current-buffer))))

(defun gather-scholia ()
  (interactive)
  (set-buffer (get-buffer-create "*Scholia*"))
  (delete-region (point-min) (point-max))
  (maphash (lambda (name val)
               (write-scholium (cons name val)))
             article-table)
  (display-buffer "*Scholia*"))

(defun write-scholium (article)
  (let ((nl "\n          "))
    (insert
     (concat "(scholium " (maybe-quoted-format (scholium-name article))
             nl (maybe-quoted-format (scholium-text article))
             nl (maybe-quoted-format (scholium-about article))
             nl (format "'%S" (scholium-type article))
             nl (format "'%S" (scholium-bookkeeping article))
             ")\n\n"))))

(defun maybe-quoted-format (obj)
  (if (and (not (null obj))
           (or (atom obj) (consp obj)))
      (format "'%S" obj)
    (format "%S" obj)))

(defun read-scholia-file (filepath)
  (interactive "fFile: ")
  (find-file-literally filepath)
  (read-scholia-buffer)
  (kill-buffer (current-buffer)))

(defun read-scholia-buffer ()
  (while (condition-case nil
             (eval (read (current-buffer)))
           (error nil))))

(defvar search-directory-for-scholia t)

(add-hook 'find-file-hook 'search-directory-for-scholia)

(defun search-directory-for-scholia ()
  (list-directory default-directory t)
  (let ((sch-file
         (replace-regexp-in-string "\\..*" ".sch" (buffer-file-name))))
    (when (search-forward sch-file nil t)
      (read-scholia-file sch-file)
      (display-scholia-about-current-buffer)))
  (kill-buffer "*Directory*"))


;; from 11-Bindings_and_environment_variables.el
(mapc
 (lambda (elt) (global-set-key (eval (car elt)) (eval (cdr elt))))
 '(([?\C-\;] . (make-keymap))
   ([?\C-\;?m] . (make-sparse-keymap))
   ([?\C-\;?d] . (make-sparse-keymap))
   ([?\C-\;?o] . (make-sparse-keymap))
   ([?\C-\;?s] . (make-sparse-keymap))

   ((kbd "C-; c") . 'commit-edits)
   ((kbd "C-; g") . 'gather-scholia)
   ((kbd "C-; f") . 'follow-reference-or-scholium)
   ((kbd "C-; n") . 'name-of-current-scholium)
   ((kbd "C-; r") . 'save-all-scholia)

   ((kbd "C-; v n") . 'back-to-normal)
   ((kbd "C-; v o") . 'back-to-other-view)

   ((kbd "C-; b b") . 'sb-back)
   ((kbd "C-; b f") . 'sb-forward)

   ((kbd "C-; l a") . 'article-menu-list-all-articles)
   ((kbd "C-; l l") . 'article-menu-list-labels)
   ((kbd "C-; l m") . 'article-menu-list-articles-matching-regexp)
   ((kbd "C-; l d") . 'article-menu-list-metadata-articles)
   ((kbd "C-; l p") . 'article-menu-list-plain-articles)

   ((kbd "C-; m a") . 'make-scholium-about-current-article)
   ((kbd "C-; m b") . 'make-scholium-about-current-buffer)
   ((kbd "C-; m l") . 'make-scholium-about-current-line)
   ((kbd "C-; m n") . 'make-new-undirected-article)
   ((kbd "C-; m i") . 'make-current-buffer-into-article)
   ((kbd "C-; m p") . 'make-scholium-about-part-of-current-article)
   ((kbd "C-; m P") .
    'make-scholium-about-several-parts-of-current-article)
   ((kbd "C-; m s") . 'make-scholium-about-current-scholium)

   ((kbd "C-; d a") . 'display-article)
   ((kbd "C-; d b") . 'display-scholia-about-current-buffer)
   ((kbd "C-; d l") . 'display-article-listing)
   ((kbd "C-; d p") .
    'display-an-article-that-current-article-is-about)
   ((kbd "C-; d c") .
    'display-an-article-that-current-scholium-is-about)
   ((kbd "C-; d r") . 'redisplay-article)

   ((kbd "C-; o y") . 'sch-turn-main-article-overlays-on)
   ((kbd "C-; o n") . 'sch-turn-main-article-overlays-off)

   ((kbd "C-; s n") .
    'scroll-article-display-to-next-region-for-current-scholium)
   ((kbd "C-; s p") .
    'scroll-article-display-to-previous-region-for-current-scholium)
   ((kbd "C-; s b") . 'move-to-previous-region-with-scholium)
   ((kbd "C-; s f") . 'move-to-next-region-with-scholium)
   ((quote [S-tab]) . 'move-to-next-region-with-scholium)
   ((kbd "C-; s a") . 'move-to-first-region-for-current-scholium)))


;; from 12.3-Use_the_scholium_system_to_do_literate_programming.el
(add-hook 'scholia-display-post-update-hook 'text-mode)

(add-to-list 'modified-type-labels '(note . note) t)
(add-to-list 'modified-type-labels '(section . section) t)
(add-to-list 'modified-type-labels '(subsection . subsection) t)
(add-to-list 'modified-type-labels '(subsubsection . subsubsection) t)

(defun map-label (function label)
  (mapc function (scholium-text (get-article label))))

(defun swap-out-latex-references ()
  (let ((tags-alist (scholium-text (get-article
                                    'Tag-to-Name-converter))))
    (map-label (lambda (name)
                 (with-temp-buffer
                   (let ((article (get-article name)))
                     (insert (scholium-text article))
                     (goto-char (point-min))
                     (while (re-search-forward
                             ;; I don't think we use "xrefs" any more.
                             "\\\\\\(x\\)?ref{\\([^}]+\\)}" nil t)
                       (let ((target (cdr
                                      (assoc (match-string 2)
                                             tags-alist))))
                         (when target
                           (replace-match target t t)
                           (let ((name-of-current-article name))
                             (make-reference-in-current-article
                              (match-beginning 0)
                              (+ (match-beginning 0) (length target))
                              target)))))
                     ;; we don't want these references to be fake
                     (scholium name
                               (buffer-substring-no-properties
                                (point-min)
                                (point-max))
                               (scholium-about article)
                               '(note)))))
               'note)))

(defun import-scholium-system ()
  (interactive)
  (import-sections)
;  (label-article 'section 'major-articles)
  (swap-out-latex-references))

(defun import-sections ()
  (save-excursion
    (set-buffer "sbdm4cbpp.tex")
    (goto-char (point-min))
    (search-forward-regexp "^\\\\section{Prelude}")
    (goto-char (match-beginning 0))
    (scholium "Scholium system frontmatter"
              (buffer-substring-no-properties (point-min) (point))
              nil
              '(note))
    (while (re-search-forward
            (concat
             "^\\\\section\\*?{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            nil t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (section-end (save-excursion
                            (search-forward-regexp
                             "^\\\\section{.*" nil t)))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsection{.*"
                               section-end t))
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes)))
             (subsections (let ((current-parent name))
                            (import-subsections))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  `(,@notes
                    ,@subsections)
                  '((section parent))
                  '(section label))))
    (goto-char (point-max))
    (search-backward-regexp "^\\\\clearpage")
    (scholium "Scholium system backmatter"
              (buffer-substring-no-properties (point) (point-max))
              nil
              '(note))))

(defun import-subsections ()
  (let (subsections)
    (while (re-search-forward
            (concat
             "^\\\\subsection{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            section-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (subsection-end (or (save-excursion
                                   (search-forward-regexp
                                    "^\\\\subsection{.*"
                                    section-end t))
                                 section-end))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsubsection{.*"
                               subsection-end t))
                            subsection-end
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes)))
             (subsubsections (let ((current-parent name))
                               (import-subsubsections))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  `(,@notes
                    ,@subsubsections)
                  `((,current-parent parent))
                  '(subsection label))
        (setq subsections
              (append subsections (list name)))))
    subsections))

(defun import-subsubsections ()
  (let (subsubsections)
    (while (re-search-forward
            (concat
             "^\\\\subsubsection{\\([^}\n]*\\)}"
             "\\( +\\\\label{\\)?"
             "\\([^}\n]*\\)?")
            subsection-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (notes-end (or (save-excursion
                              (search-forward-regexp
                               "^\\\\subsubsection{.*"
                               subsection-end t))
                            subsection-end
                            section-end))
             (notes (let ((current-parent name))
                      (import-notes))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  notes
                  `((,current-parent parent))
                  `(subsubsection label))
        (setq subsubsections
              (append subsubsections (list name)))))
    subsubsections))

(defun import-notes ()
  (let (notes)
    (while
        (re-search-forward (concat "\\\\begin{notate}"
                                   "{\\([^}\n]*\\)}"
                                   "\\( +\\\\label{\\)?"
                                   "\\([^}\n]*\\)?")
                           notes-end t)
      (let* ((name (match-string-no-properties 1))
             (tag (match-string-no-properties 3))
             (beg (progn (next-line 1)
                         (line-beginning-position)))
             ;; no need to bound the search for the end, because we
             ;; assume that every "notate" environment is actually
             ;; closed
             (end (progn (search-forward-regexp
                          "\\\\end{notate}")
                         (match-beginning 0))))
        (when (not (equal tag ""))
          (scholium 'Tag-to-Name-converter
                    (add-to-or-start-list
                     (scholium-text (get-article
                                     'Tag-to-Name-converter))
                     `(,tag . ,name))))
        (scholium name
                  (buffer-substring-no-properties beg end)
                  `((,current-parent parent))
                  '(note))
        (setq notes
              (append notes (list name)))
        (import-code-continuations)))
    notes))

(defun import-code-continuations ()
  ;; ugly formatting = latex overrides!
  (while (looking-at (concat "\n\n\\\\b" "egin{lisp}"))
    (scholium `(code-continuation ,name)
              (let ((old-text (scholium-text
                               (get-article
                                `(code-continuation ,name))))
                    (new-text (buffer-substring-no-properties
                               (progn (next-line 3)
                                      (line-beginning-position))
                               (progn (search-forward-regexp
                                       (concat "\\\\e" "nd{lisp}"))
                                      (match-beginning 0)))))
                (if old-text 
                    (concat old-text "\n" new-text)
                  new-text))
              `(((article ,name)))
              'code)
    ;; this should add an appropriate link to the article
    ;; that this is a code-continuation of.
    (let ((article-to-edit (get-article name)))
      (scholium (scholium-name article-to-edit)
                (scholium-text article-to-edit)
                (add-to-or-start-list 
                 (scholium-about article-to-edit)
                 `(code-continuation (code-continuation ,name)))
                (scholium-bookkeeping article-to-edit)))))

(defun browse-scholium-system ()
  (interactive)
  (import-scholium-system)
  (display-article 'section)
  (message "You've successfully imported the system!"))

(defun export-scholium-system ()
  (set-buffer (get-buffer-create "*Export*"))
  (erase-buffer)
  (insert (scholium-text (get-article "Scholium system frontmatter")))
  (dolist (sect (scholium-text (get-article 'section)))
    (export-section sect)
    (let ((contents (scholium-text (get-article sect))))
      (dolist (item contents)
        (let ((current-item (get-article item)))
          (if (typedata-includes (scholium-type current-item)
                                 'subsection)
              (export-subsection (scholium-name current-item))
            (export-note current-item))))))
  (insert (scholium-text (get-article "Scholium system backmatter"))))

(defun export-note (note)
  (set-buffer (get-buffer "*Export*"))
  (let* ((name (scholium-name note))
         (tag (car (rassoc name (scholium-text
                                 (get-article
                                  'Tag-to-Name-converter))))))
    (insert "\*** " name "

"
            (if tag 
                (concat " \\label{" tag "}\n")
              "\n")
            (swap-in-latex-references note)
            "\
\n\n")
    (dolist (scholium (mapcar (lambda (backlink)
                                    (get-article (car backlink)))
                              (get-backlinks name)))
      ;; we were missing one function from a list of two in my last
      ;; test of exporting, should look into this.
      (when (typedata-includes (scholium-type scholium) 'code)
        (insert "\\b" "egin{lisp}\n"
                (scholium-text scholium)
                "\\e" "nd{lisp}\n\n")))))

(defun swap-in-latex-references (note)
  (save-excursion
    (let ((tags-alist (scholium-text (get-article
                                      'Tag-to-Name-converter))))
      (display-article (scholium-name note))
      (set-buffer (get-buffer "Main Article Display"))
      (let ((next-region (move-to-next-region-with-scholium)))
        (while next-region
          (let ((scholium-property-at-start 
                 (get-text-property (first next-region) 'scholia))
                (scholium-property-at-end 
                 (get-text-property (second next-region) 'scholia)))
            (let* ((scholium-id (first scholium-property-at-start))
                   (scholium-name (first scholium-id))
                   (possible-reference (get-article scholium-name)))
              (when (typedata-includes 
                     (scholium-type possible-reference)
                     'reference)
                (let ((scholium-tag 
                       (car (rassoc (reference-to-article 
                                     possible-reference)
                                    tags-alist))))
                  (if scholium-tag
                      (progn (delete-region (first next-region)
                                            (second next-region))
                             (goto-char (first next-region))
                             (insert "\[[id:" scholium-tag "]]"))
                    (let ((new-tag (replace-regexp-in-string
                                    " " "-"
                                    (buffer-substring-no-properties
                                     (first next-region)
                                     (second next-region)))))
                      (delete-region (first next-region)
                                     (second next-region))
                      (goto-char (first next-region))
                      (insert "\[[id:" new-tag "]]"))))))
            (setq next-region (move-to-next-region-with-scholium)))))
      (buffer-substring-no-properties (point-min)
                                      (point-max)))))

(defun export-section (section-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc section-name (scholium-text
                                         (get-article
                                          'Tag-to-Name-converter))))))
    (insert "\\section{" section-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n"))))

(defun export-subsection (subsection-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc subsection-name (scholium-text
                                            (get-article
                                             'Tag-to-Name-converter))))))
    (insert "\\subsection{" subsection-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n")))
  (let ((contents (scholium-text current-item)))
    (dolist (item contents)
      (let ((current-item (get-article item)))
        (if (typedata-includes (scholium-type current-item)
                               'subsubsection)
            (export-subsubsection (scholium-name current-item))
          (export-note current-item))))))

(defun export-subsubsection (subsubsection-name)
  (set-buffer (get-buffer "*Export*"))
  (let* ((tag (car (rassoc subsubsection-name (scholium-text
                                               (get-article
                                                'Tag-to-Name-converter))))))
    (insert "\\subsubsection{" subsubsection-name "}"
            (if tag 
                (concat " \\label{" tag "}\n\n")
              "\n\n")))
  (let ((contents (scholium-text current-item)))
                              
    (dolist (item contents)
      (let ((current-item (get-article item)))
        (export-note current-item)))))


;; from 12.5-Simulating_a_wiki_with_the_scholium_system.el
(defun mark-up-wiki-with-reference-scholia ()
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward
            ;; we could probably get all types of reference in
            ;; one regexp.  I'm not sure why the old
            ;; version for grabbing external references was deleted,
            ;; but it is featured in the Sept 4 printout.
            "\\[\\[\\([^]|\n]+\\)\\(|\\)?\\([^]]+?\\)?]]" nil t)
      (replace-match (propertize (or (match-string 3)
                                     (match-string 1))
                                 'scholia
                                 "Reference")))))


;; from 12.7-Using_the_scholium_system_for_HDM_things.el
(add-to-list 'modified-type-labels '(apmxi-section . apmxi-section) t)
(add-to-list 'modified-type-labels '(apmxi-entry . apmxi-entry) t)
(add-to-list 'modified-type-labels '(apmxi-stub . apmxi-stub) t)

(defun make-apmxi-sections-into-articles ()
  (save-window-excursion
    (find-file "../p2/Xi.tex")
    (goto-char (point-min))
    (while (re-search-forward "^\\\\section{{ \\(.+\\)}} " nil t)
      (let ((article-name (match-string-no-properties 1))
            (beg (point))
            (end (save-excursion (search-forward "\\section" nil t)
                                 (match-beginning 0))))
        (when end
          (scholium article-name
                    (buffer-substring-no-properties beg end)
                    nil
                    'apmxi-section))))))

(defun chunk-out-apmxi-definitions ()
  (map-label (lambda (name)
               (with-temp-buffer
                 ;; this ensures that sexps are defined properly
                 (latex-mode)
                 (let ((topic (get-article name))
                       contents)
                   (insert (scholium-text topic))
                   (goto-char (point-min))
                   (while (re-search-forward "^(" nil t)
                     (let* ((beg (match-beginning 0))
                            (title-beg (match-end 0))
                            (title-end (progn (goto-char beg)
                                              (forward-sexp)
                                              (1- (point))))
                            (stub-p (looking-at " *$"))
                            (title (buffer-substring-no-properties
                                    title-beg
                                    title-end))
                            (end (save-excursion
                                   (search-forward-regexp "^$")))
                            (possible-previous (get-article title)))
                       (when (or (not possible-previous)
                                 (typedata-includes (scholium-type
                                                     possible-previous)
                                                    'apmxi-stub))
                         (scholium title
                                   (buffer-substring-no-properties
                                    beg
                                    end)
                                   `((,name parent))
                                   (if stub-p
                                       '(apmxi-stub apmxi-entry)
                                     'apmxi-entry)))
                       (setq contents (cons title contents))))
                   (scholium name
                             contents
                             nil
                             '(apmxi-section label)))))
             'apmxi-section))

(defun import-apmxi ()
  (make-apmxi-sections-into-articles)
  (chunk-out-apmxi-definitions))



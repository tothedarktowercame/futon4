** Lisp preliminaries

*** On `add-or-replace'

It seems that this function is no longer used.


#+BEGIN_SRC elisp
(defun add-or-replace (lis elt pred)
  (let ((found nil)
        (n 0)
        (len (length lis)))
    (while (and (not found)
                (< n len))
      (when (funcall pred (nth n lis))
        (setcar (nthcdr n lis) elt)
        (setq found t))
      (setq n (1+ n)))
    (if found
        (1- n)
      (nconc lis (list elt))
      n)))
#+END_SRC

*** On `add-to-or-start-list'
:PROPERTIES:
:LATEX_LABEL: add-to-or-start-list
:ID: add-to-or-start-list
:END:

This is is used to start store an \inp{element} on a
``\inp{possible-list}''; unlike `add-to-list', it works even when list
is nil, or even (for now) when \inp{possible-list} is not a list at
all.  (Unlike with `add-to-list', \inp{possible-list} should not be
the name of a list.)

This function is used by `put-type-labels', `put-backlinks' and
`label-article'.  Note that you have to \emph{save} the result if you
want to this function to have a lasting effect.

Like `add-to-list', this function will only store \emph{one} copy of
\inp{element}.


#+BEGIN_SRC elisp
(defun add-to-or-start-list (possible-list element)
  (cond ((null possible-list)
         (list element))
        ((listp possible-list)
         (if (member element possible-list)
             possible-list
           (append possible-list (list element))))
        (t (list possible-list element))))
#+END_SRC

*** On `next-single-property-change+predicate'

Like `next-single-property-change' except instead of automatically
judging changes in the text property by the `eq' predicate, it allows
the user to supply a \inp{test}.


#+BEGIN_SRC elisp
(defun next-single-property-change+predicate (pos prop &optional test)
  (let ((starting (get-text-property pos prop))
        (index pos)
        (cmpfct (or test
                    'eq)))
    (save-excursion
      (while (and (setq index (1+ index))
                  (< index (point-max))
                  (funcall cmpfct
                           starting
                           (get-text-property index prop)))))
    (when (< index (point-max))
      index)))
#+END_SRC

*** On `delete-all-dups'

This function differs from `delete-dups' in being
non-destructive and in keeping none of several `equal'
occurrences of an element in \inp{list} as opposed to one;
otherwise, it manifests a similar idea.


#+BEGIN_SRC elisp
(defun delete-all-dups (list)
  (let ((tail list)
        ret)
    (while tail
      (cond ((member (car tail) (cdr tail))
             (setq tail (delete (car tail) tail)))
            (t
             (setq ret (cons (car tail) ret)
                   tail (cdr tail)))))
    ret))

(defun set-difference (A B)
  (delete-all-dups (append A B)))

(defun zip (A B)
  (let ((ret (make-hash-table)))
    (while A
      (puthash (car A)
               (car B)
               ret)
      (setq A (cdr A)
            B (cdr B)))
    ret))

(defun flatten (list-structure)
  (apply 'concatenate 'list (list list-structure)))
#+END_SRC

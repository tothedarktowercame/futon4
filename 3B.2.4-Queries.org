** Queries                                                         :noexport:
:PROPERTIES:
:LATEX_LABEL: queries
:ID: queries
:END:

*** The use of views
:PROPERTIES:
:LATEX_LABEL: use-of-views
:ID: use-of-views
:END:

It is easy enough to select those triples which match
simple data, e.g., those triples which have the same
beginning, middle, or end, or any combination of these.
It is a little more complicated to find items that match
criteria specified by several different triples; for
example, to \emph{find all the books by Arthur C. Clarke
  that are also works of fiction}.

Suppose our collection of triples contains a portion as
follows:
\begin{center}
\begin{tabular}{lll}
Profiles of the Future & is a & book \\ 2001: A Space
Odyssey & is a & book \\ Ender's Game & is a & book
\\ Profiles of the Future & has genre & non-fiction
\\ 2001: A Space Odyssey & has genre & fiction \\ Ender's
Game & has genre & fiction \\ Profiles of the Future & has
author & Arthur C. Clarke \\ 2001: A Space Odyssey & has
author & Arthur C. Clarke \\ Ender's Game & has author &
Orson Scott Card
\end{tabular}
\end{center}

One way to solve the given problem would be to find those
items that \emph{are written by Arthur C. Clarke} (* ``has
author'' and ``Arthur C. Clarke''), that \emph{are books}
(* ``is a'' ``book''), and \emph{that are classified as
  fiction} (* ``has genre'' ``fiction'').  We are looking
for items that match \emph{all} of these conditions.

Our implementation strategy is: collect the items matching
each criterion into a view, then join these views.  (See
the function `satisfy-conditions'
[[id:satisfy-conditions]].)

If we end up working with large queries and a lot of data,
this use of views may not be an efficient way to go -- but
we'll cross that bridge when we come to it.


*** Search queries

In Note [[id:sphinx-setup]] et seq., we give some
instructions on how to set up the Sphinx search engine to
work with Arxana.  However, a much tighter integration of
Sphinx into Arxana is possible, and will be coming soon.


#+BEGIN_SRC lisp
;; queries.lisp
(in-package arxana)
(locally-enable-sql-reader-syntax)
#+END_SRC

\subsection*{Printing}

*** On `print-system-object'
:PROPERTIES:
:LATEX_LABEL: print-system-object
:ID: print-system-object
:END:

The function `print-system-object' bears some resemblance
to `massage', but is for printing instead,
and therefor has to be recursive (because triples and
places can point to other system objects, printing can be
a long and drawn out ordeal).


#+BEGIN_SRC lisp
;; queries.lisp
(defun print-system-object (data &optional components)
  (cond
    ;; just return strings
    ((stringp data)
     data)
    ;; printing from coordinates (code, ref)
    ((and (listp data)
          (equal (length data) 2))
     ;; we'll need some hack to deal with
     ;; elements-of-theories, which, right now, are two
     ;; elements long but are not (code, ref) pairs but
     ;; rather (local_id, ref) pairs, or maybe actually if
     ;; we take context into consideration, they're
     ;; actually (k, table, local_id, ref) quadruplets.
     ;; Obviously with *that* data we can translate to
     ;; (code, ref).  On the other hand, if we *don't*
     ;; take it into consideration, we probably can't do
     ;; much of anything.  So we should be careful to be
     ;; aware of just what sort of information we're
     ;; passing around.
     (cond ((equal (first data) 0)
            (string-lookup (second data)))
           ((equal (first data) 1)
            (print-system-object
             (place-lookup (second data) t)))
           ((equal (first data) 2)
            (let ((triple (triple-lookup (second data) t)))
              (if components
                  (list
                   (print-beginning triple)
                   (print-middle triple)
                   (print-end triple))
                  (concatenate
                   'string
                   (format nil "T~a[" (second data))
                   (print-beginning triple) "."
                   (print-middle triple) "."
                   (print-end triple) "]"))))
           ((equal (first data) 3)
            (concatenate 'string "List printing not implemented yet."))))
    ;; place
    ((and (listp data)
          (equal (length data) 3))
     (concatenate 'string
                  (format nil "P~a|" (first data))
                  (print-system-object (cdr data)) "|"))
    ;; triple
    ((and (listp data)
          (equal (length data) 7))
      (if components
          (list
           (print-beginning data)
           (print-middle data)
           (print-end data))
          (concatenate
           'string
           (format nil "T~a[" (first data))
           (print-beginning data) "."
           (print-middle data) "."
           (print-end data) "]")))
    (t nil)))

(defun print-beginning (triple)
  (print-system-object (isolate-beginning triple)))

(defun print-middle (triple)
  (print-system-object (isolate-middle triple)))

(defun print-end (triple)
  (print-system-object (isolate-end triple)))
#+END_SRC

*** Depth

If we are going to have complicated recursive references,
our printer, and anything else that gives the system some
semantics, should come with some sort of ``layers'' switch
that can be used to limit the amount of recursion we do in
any given computation.


*** Printing objects as they appear in Lisp
:PROPERTIES:
:LATEX_LABEL: printing-objects-in-lisp
:ID: printing-objects-in-lisp
:END:

With the following functions we provide facilities for
printing an object, either from its id or from the
expanded form of the data that represents it in Lisp.
(This is one good reason to have one standard form for
this data; compare Note [[id:what-is-best-for-lisp]].
These functions assume that the id \emph{is} part of
what's printed, so if using functions like `triple-lookup'
to retrieve data for printing, you'll have to graft the id
back on before printing with these functions.)


*** Printing theories

We'll want to both print all of the content of a theory,
and print \emph{from} the theory in a more limited way.
(Perhaps we get the second item for free, already?)


#+BEGIN_SRC lisp
;; queries.lisp
(defun print-string (string &optional components)
  (print-system-object string components))

(defun print-place (place &optional components)
  (print-system-object place components))

(defun print-triple (triple &optional components)
  (print-system-object triple components))

(defun print-string-from-id (id &optional components)
  (print-system-object (list 0 id) components))

(defun print-place-from-id (id &optional components)
  (print-system-object (list 1 id) components))

(defun print-triple-from-id (id &optional components)
  (print-system-object (list 2 id) components))
#+END_SRC

*** Printing some stuff but not other stuff
:PROPERTIES:
:LATEX_LABEL: printing-some
:ID: printing-some
:END:

These functions are good for printing lists as come out of
the database.  See Note [[id:strings-and-ids]] on printing
strings.


#+BEGIN_SRC lisp
;; queries.lisp
(defun print-strings (strings)
  (mapcar 'second strings))

(defun print-places (places &optional components)
  (mapcar (lambda (item)
             (print-system-object item components))
  places))

(defun print-triples (triples &optional components)
 (mapcar (lambda (item)
             (print-system-object item components))
             triples))

(defun print-theories (theories &optional components)
 (mapcar (lambda (item)
             (print-system-object item components))
             theories))
#+END_SRC

*** Printing everything in each table
:PROPERTIES:
:LATEX_LABEL: printing-everything
:ID: printing-everything
:END:

These functions collect human-readable versions of
everything in each table.  Notice that `all-strings' is
written differently.


#+BEGIN_SRC lisp
;; queries.lisp
(defun all-strings ()
  (mapcar 'second (select [*] :from [strings])))

(defun all-places ()
  (mapcar 'print-system-object
          (select [*] :from [places])))

(defun all-triples ()
 (mapcar 'print-system-object
         (select [*] :from [triples])))

(defun all-theories ()
 (mapcar 'print-system-object
         (select [*] :from [theories])))
#+END_SRC

*** Printing on particular dimensions

One possible upgrade to the printing functions would be to
provide the built-in to ``curry'' the printout -- for
example, just print the source nodes from a list of
triples.  However, it should of course also be possible to
do processing like this Lisp after the printout has been
made (the point is, it is presumably it is more efficient
only to retrieve and format the data we're actually
looking for).


*** Strings and ids
:PROPERTIES:
:LATEX_LABEL: strings-and-ids
:ID: strings-and-ids
:END:

Unlike other objects, strings don't get printed with their
ids.  We should probably provide an \emph{option} to print
with ids (this could be helpful for subsequent work with
the strings in question; on the other hand, since strings
are being kept unique, we can immediately exchange a
string and it's id, so I'm not sure if it's necessary to
have an explicit ``option'').


\subsection*{Functions that establish basic graph structure}

*** Thinking about graph-like data
:PROPERTIES:
:LATEX_LABEL: graph-like-data
:ID: graph-like-data
:END:

Here we have in mind one or more objects (e.g. a
particular source and sink) that is associated with
potentially any number of triples (e.g. all the possible
middles running between these two identified objects).
These functions establish various forms of locality or
neighborhood within the data.

The results of such queries can be optionally cached in a
view, which is useful for further processing
(cf. [[id:satisfy-conditions]]).

These functions take input in the form of strings and/or
coordinates (cf. Note [[id:massage]]).


#+BEGIN_SRC lisp
;; queries.lisp
(defun triples-given-beginning (node &optional view)
  "Get triples outbound from the given NODE.  Optional
  argument VIEW causes the results to be selected into a
  view with that name."
  (let ((data (massage node))
        (window (or view "interal-view"))
        ret)
    (when data
      (create-view
       window
        :as (select [*]
             :from [triples]
             :where [and [= [code1] (first data)]
                         [= [ref1] (second data)]]))
      (setq ret (select [*] :from window))
      (unless view
        (drop-view window))
      ret)))

(defun triples-given-end (node &optional view)
  "Get triples inbound into NODE.  Optional argument VIEW
       causes the results to be selected into a view with
       that name."
  (let ((data (massage node))
        (window (or view "interal-view"))
        ret)
    (when data
      (create-view
       window
        :as (select [*]
             :from [triples]
             :where [and [= [code3] (first data)]
                         [= [ref3] (second data)]]))
      (setq ret (select [*] :from window))
      (unless view
        (drop-view window))
      ret)))

(defun triples-given-middle (edge &optional view)
  "Get the triples that run along EDGE.  Optional argument
       VIEW causes the results to be selected into a view
       with that name."
  (let ((data (massage edge))
        (window (or view "interal-view"))
        ret)
    (when data
      (create-view
       window
       :as (select [*]
            :from [triples]
            :where [and [= [code2] (first data)]
                        [= [ref2] (second data)]]))
      (setq ret (select [*] :from window))
      (unless view
        (drop-view window))
      ret)))

(defun triples-given-middle-and-end (edge node &optional
       view)
  "Get the triples that run along EDGE into NODE.
       Optional argument VIEW causes the results to be
       selected into a view with that name."
  (let ((edgedata (massage edge))
        (nodedata (massage node))
        (window (or view "interal-view"))
        ret)
    (when (and edgedata nodedata)
      (create-view
       window
       :as (select [*]
            :from [triples]
            :where [and [= [code2] (first edgedata)]
                        [= [ref2] (second edgedata)]
                        [= [code3] (first nodedata)]
                        [= [ref3] (second nodedata)]]))
      (setq ret (select [*] :from window))
      (unless view
        (drop-view window))
      ret)))

(defun triples-given-beginning-and-middle (node edge
                                           &optional view)
  "Get the triples that run from NODE along EDGE.
Optional argument VIEW causes the results to be selected
into a view with that name."
  (let ((nodedata (massage node))
        (edgedata (massage edge))
        (window (or view "interal-view"))
        ret)
    (when (and nodedata edgedata)
      (create-view
       window
       :as (select [*]
            :from [triples]
            :where [and [= [code1] (first nodedata)]
                        [= [ref1] (second nodedata)]
                        [= [code2] (first edgedata)]
                        [= [ref2] (second edgedata)]]))
      (setq ret (select [*] :from window))
      (unless view
        (drop-view window))
      ret)))

(defun triples-given-beginning-and-end (node1 node2
       &optional view)
  "Get the triples that run from NODE1 to NODE2.  Optional
       argument VIEW causes the results to be selected
       into a view with that name."
  (let ((node1data (massage node1))
        (node2data (massage node2))
        (window (or view "interal-view"))
        ret)
    (when (and node1data node2data)
      (create-view
       window
       :as (select [*]
            :from [triples]
            :where [and [= [code1] (first node1data)]
                        [= [ref1] (second node1data)]
                        [= [code3] (first node2data)]
                        [= [ref3] (second node2data)]]))
      (setq ret (select [*] :from window))
      (unless view
        (drop-view window))
      ret)))

;; This one use `select-one' instead of `select'
(defun triple-exact-match (node1 edge node2 &optional
       view)
  "Get the triples that run from NODE1 along EDGE to
NODE2.  Optional argument VIEW causes the results to be
selected into a view with that name."
  (let ((node1data (massage node1))
        (edgedata (massage edge))
        (node2data (massage node2))
        (window (or view "interal-view"))
        ret)
    (when (and node1data edgedata node2data)
      (create-view
       window
       :as (select [*]
            :from [triples]
            :where [and [= [code1] (first node1data)]
                        [= [ref1] (second node1data)]
                        [= [code2] (first edgedata)]
                        [= [ref2] (second edgedata)]
                        [= [code3] (first node2data)]
                        [= [ref3] (second node2data)]]))
      (setq ret (select-one [*] :from window))
      (unless view
        (drop-view window))
      ret)))
#+END_SRC

*** Becoming flexible about a string's status

One possible upgrade would be to provide versions of these
functions that will flexibly accept either a string or a
``placed string'' as input (since frequently we're
interested in content of that sort; see
# [[id:importing-sketch]]
).


\subsection*{Finding places that satisfy some property}

*** On `get-places-subject-to-constraint'

Like `get-places' (Note
# [[id:get-places]]
), but this
time takes an extra condition of the form (A C B)
where one of A, B, and C is `nil'.  We test each
of the places in place of this `nil', to see if a
triple matching that criterion exists.


#+BEGIN_SRC lisp
;; queries.lisp
(defun get-places-subject-to-constraint (symbol condition)
  (let ((candidate-places (get-places symbol))
        accepted-places)
    (dolist (place candidate-places)
      (let ((filled-condition
             (map 'list (lambda (elt) (or elt
                                          `(1 ,place)))
                  condition)))
        (when (apply 'triple-relaxed-match
                     filled-condition)
          (setq accepted-places
                (cons place accepted-places)))))
    accepted-places))
#+END_SRC

\subsection*{Logic}

*** Caution: compatibility with theories?

For the moment, I'm not sure how compatible this function
is with the theories apparatus we've established, or with
the somewhat vaguer notion of trans-theory questions or
concerns.  Global queries should work just fine, but
theory-local questions may need some work.  Before getting
into compatibility of these questions with the theory
apparatus, I want to make sure that apparatus is working
properly.  Note that the questions here do rely on
functions for graph-like thinking (Note
[[id:graph-like-data]] et seq.), and it would certainly
make sense to port to ``subgraphs'' as represented by
theories.


*** On `satisfy-conditions'
:PROPERTIES:
:LATEX_LABEL: satisfy-conditions
:ID: satisfy-conditions
:END:

This function finds the items which match constraints.
Constraints take the form (A B C), where precisely one of
A, B, or C should be `nil', and any of the others can be
either input suitable for `massage', or
`t'.  The `nil' entry stands for the object we're
interested in.  Any `t' entries are wildcards.

The first thing that happens as the function runs is that
views are established exhibiting each group of triples
satisfying each predicate.  The names of these views are
then massaged into a large SQL query.  (It is important to
``typeset'' all of this correctly for our SQL `query'.)
Finally, once that query has been run, we clean up,
dropping all of the views we created.


#+BEGIN_SRC lisp
;; queries.lisp
(defun satisfy-conditions (constraints)
  (let* ((views (generate-views constraints))
         (formatted-list-of-views (format-views
                                   views))
         (where-condition (generate-where-condition
                           views
                           constraints))
         (ret
          ;; Let's see what the query is, first of all.
          (query
           (concatenate
            'string
            "select v1.id, v1.code1, v1.ref1, "
                          "v1.code2, v1.ref2, "
                          "v1.code3, v1.ref3 "
            "from "
            formatted-list-of-views
            "where "
            where-condition
            ";"))))
    (mapc (lambda (name) (drop-view name)) views)
    ret))
#+END_SRC

*** Subroutines for `satisfy-conditions'

The functions below produce bits and pieces of the SQL
query that `satisfy-conditions' submits.  The point of the
`generate-views' is to create a series of views centered
on the term(s) we're interested in (the `nil' slots in
each submitted constraint).  With
`generate-where-condition', we insist that all of these
interesting terms should, in fact, be equal to one
another.


*** On `generate-views'

In a `cond' form, for each constraint we must select the
appropriate function to generate the view; at the very end
of the cond form, we spit out the viewname (for `mapcar'
to add to the list of views).


#+BEGIN_SRC lisp
;; queries.lisp
(defun generate-views (constraints)
  (let ((counter 0))
    (mapcar
     (lambda (constraint)
       (setq counter (1+ counter))
       (let ((viewname (format nil "v~a" counter)))
         (cond
          ;; A * ? or A ? *
          ((or (and (eq (second constraint) t)
                    (eq (third constraint) nil))
               (and (eq (second constraint) nil)
                    (eq (third constraint) t)))
           (triples-given-beginning
            (first constraint)
            viewname))
          ;; * B ? or ? B *
          ((or (and (eq (first constraint) t)
                    (eq (third constraint) nil))
               (and (eq (first constraint) nil)
                    (eq (third constraint) t)))
           (triples-given-middle
            (second constraint)
            viewname))
          ;; * ? C or ? * C
          ((or (and (eq (first constraint) t)
                    (eq (second constraint) nil))
               (and (eq (first constraint) nil)
                    (eq (second constraint) t)))
           (triples-given-end
            (third constraint)
            viewname))
          ;; ? B C
          ((eq (first constraint) nil)
           (triples-given-middle-and-end
            (second constraint)
            (third constraint)
            viewname))
          ;; A ? C
          ((eq (second constraint) nil)
           (triples-given-beginning-and-middle
            (first constraint)
            (second constraint)
            viewname))
          ;; A C ?
          ((eq (third constraint) nil)
           (triples-given-beginning-and-end
            (first constraint)
            (third constraint)
            viewname)))
         viewname))
     constraints)))

(defun format-views (views)
  (let ((formatted-list-of-views ""))
    (mapc (lambda (view)
            (setq formatted-list-of-views
                  (concatenate
                   'string
                   formatted-list-of-views
                   (format nil "~a," view))))
          (butlast views))
    (setq formatted-list-of-views
          (concatenate
           'string
           formatted-list-of-views
           (format nil "~a " (car (last views)))))
    formatted-list-of-views))

(defun generate-where-condition (views conditions)
  (let ((where-condition "")
        (c (select-component (first conditions))))
    ;; there should be one less "=" condition than there
    ;; are things to compare; until we get to the last
    ;; view, everything is joined together by an `and'.
    ;; -- this needs to consider (map over) both `views'
    ;; and `conditions'.
    (loop
     for i from 1 upto (1- (length views))
     do
     (let ((compi (select-component (nth i conditions)))
           (viewi (nth i views)))
       (setq
        where-condition
        (concatenate
         'string
         where-condition
         (concatenate
          'string
          "(v1.code" c " = " viewi ".code" compi ") and "
          "(v1.ref" c " = " viewi ".ref" compi ") and ")))))
    (let ((viewn (nth (1- (length views)) views))
          (compn (select-component
                    (nth (length views) conditions))))
      (setq
       where-condition
       (concatenate
        'string
        where-condition
        "(v1.code" c " = " viewn ".code" compn ") and "
        "(v1.ref" c " = " viewn ".ref" compn ")")))
    where-condition))

(defun select-component (condition)
  (cond ((eq (first condition) nil) "1")
        ((eq (second condition) nil) "2")
        ((eq (third condition) nil) "3")))
#+END_SRC

#+BEGIN_SRC lisp
;; queries.lisp
(locally-disable-sql-reader-syntax)
#+END_SRC

*** Even more complicated logic

In order to conveniently manage complex queries, it would
be nice if we could store the results of earlier queries
into views, so that we can combine several such views for
further processing.


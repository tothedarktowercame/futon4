** Individual Operations

*** On `add-nema'

Add record to article table.
Add record to list of forward links of source.
Add record to list of backward links of sink.
Return the id of the new article.\todo{Should we add an alias `add-triple'
for this function, to make it more clear that our middle/frontend
is not implementation specific?}


#+BEGIN_SRC elisp
(defun add-nema (src txt snk)
  "Enter a new nema to the database."
  (let ((uid (next-unique-id)))
    ;; Add record to nema table.
    (puthash uid
             `(,src ,snk . ,txt)
             (nth 2 current-plexus))
    ;; Add record to list of forward links of source.
    (puthash src
             (cons `(,uid . ,snk)
                   (gethash src (nth 3 current-plexus) nil))
             (nth 3 current-plexus))
    ;; Add record to list of backward links of sink.
    (puthash snk
             (cons
              `(,uid . ,src)
              (gethash snk (nth 4 current-plexus) nil))
             (nth 4 current-plexus))
    ;; Update the counter for long-term storage
    (setcar (cdr current-plexus) uid)
    ;; Return the id of the new nema.
    uid))
#+END_SRC

*** Retrieving elements of a nema
:PROPERTIES:
:LATEX_LABEL: retrieving-elements
:ID: retrieving-elements
:END:

These functions exist to get the relevant components
of a nema, given its uid.


#+BEGIN_SRC elisp
(defun get-content (uid)
  "Return the content of the nema."
  (cddr (gethash uid (nth 2 current-plexus))))

(defun get-source (uid)
  "Return the source of the nema."
  (car (gethash uid (nth 2 current-plexus))))

(defun get-sink (uid)
  "Return the sink of the nema."
  (cadr (gethash uid (nth 2 current-plexus))))

(defun get-triple (uid)
  (list (get-source uid)
        (get-content uid)
        (get-sink uid)))
#+END_SRC

*** On `update-content'

old source
old sink
new content


#+BEGIN_SRC elisp
(defun update-content (uid txt)
  "Replace the content of the nema."
  (puthash uid
              (let ((x (gethash uid (nth 2 current-plexus))))
                     `(,(car x)    ; old source
                              ,(cadr x) . ; old sink
                                     ,txt))      ; new content
                 (nth 2 current-plexus)))
#+END_SRC

*** On `update-source'

Extract current source.
Extract current sink.
Extract current content.
Update the entry in the article table.
Remove the entry with the old source in the
forward link table.  If that is the only entry
filed under old-src, remove it from table.
Add an entry with the new source in the
forward link table.
Update the entry in the backward link table.


#+BEGIN_SRC elisp
(defun update-source (uid new-src)
  "Replace the source of the nema."
  (let* ((x (gethash uid (nth 2 current-plexus)))
         (old-src (car x))   ; extract current source
         (old-snk (cadr x))  ; extract current sink
         (old-txt (cddr x))) ; extract current content
    ;; Update the entry in the nema table.
    (puthash uid
             `(,new-src ,old-snk . ,old-txt)
             (nth 2 current-plexus))
    ;; Remove the entry with the old source in the
    ;; forward link table.  If that is the only entry
    ;; filed under old-src, remove it from table.
    (let ((y (delete `(,uid . ,old-snk)
                     (gethash old-src
                              (nth 3 current-plexus)
                              nil))))
      (if y
          (puthash old-src y (nth 3 current-plexus))
        (remhash old-src (nth 3 current-plexus))))
    ;; Add an entry with the new source in the
    ;; forward link table.
    (puthash new-src
             (cons `(,uid . ,old-snk)
                   (gethash old-src (nth 3 current-plexus) nil))
             (nth 3 current-plexus))
    ;; Update the entry in the backward link table.
    (puthash old-snk
             (cons `(,uid . ,new-src)
                   (delete `(,uid . ,old-src)
                           (gethash old-src
                                    (nth 4 current-plexus)
                                    nil)))
             (nth 4 current-plexus))))
#+END_SRC

*** On `update-sink'
:PROPERTIES:
:LATEX_LABEL: update-sink
:ID: update-sink
:END:

Extract current source.
Extract current sink.
Extract current content.
Update the entry in the article table.
Remove the entry with the old sink in the
backward link table.  If that is the only entry
filed under old-src, remove it from table.
Add an entry with the new source in the
backward link table.
Update the entry in the forward link table.


#+BEGIN_SRC elisp
(defun update-sink (uid new-snk)
  "Change the sink of the nema."
  (let* ((x (gethash uid (nth 2 current-plexus)))
          (old-src (car x))   ; extract current source
           (old-snk (cadr x))  ; extract current sink
            (old-txt (cddr x))) ; extract current content
    ; Update the entry in the nema table.
    (puthash uid
             `(,old-src ,new-snk . ,old-txt)
             (nth 2 current-plexus))
    ;; Remove the entry with the old sink in the
    ;; backward link table.  If that is the only entry
    ;; filed under old-src, remove it from table.
    (let ((y (delete `(,uid . ,old-src)
                     (gethash old-snk
                              (nth 4 current-plexus)
                              nil))))
      (if y
          (puthash old-snk y (nth 4 current-plexus))
        (remhash old-snk (nth 4 current-plexus))))
    ;; Add an entry with the new source in the
    ;; backward link table.
    (puthash new-snk
             (cons `(,uid . ,old-src)
                   (gethash old-snk
                            (nth 4 current-plexus)
                            nil))
             (nth 4 current-plexus))
    ;; Update the entry in the forward link table.
    (puthash old-src
             (cons `(,uid . ,new-snk)
                   (delete `(,uid . ,old-snk)
                           (gethash old-src
                                    (nth 3 current-plexus)
                                    nil)))
             (nth 3 current-plexus))))
#+END_SRC

*** On `remove-nema'

Remove forward link created by article.
Remove backward link created by article.
Remove record from article table.


#+BEGIN_SRC elisp
(defun remove-nema (uid)
  "Remove this nema from the database."
  (let ((old-src (car (gethash uid (nth 2 current-plexus))))
        (old-snk (cadr (gethash uid (nth 2 current-plexus)))))
  ;; Remove forward link created by nema.
  (let ((new-fwd (delete `(,uid . ,old-snk)
                          (gethash old-src (nth 3 current-plexus)))))
    (if new-fwd
        (puthash old-src new-fwd (nth 3 current-plexus))
      (remhash old-src (nth 3 current-plexus))))
  ;; Remove backward link created by nema.
  (let ((new-bkw (delete `(,uid . ,old-src)
                          (gethash old-snk (nth 4 current-plexus)))))
    (if new-bkw
        (puthash old-snk new-bkw (nth 4 current-plexus))
      (remhash old-snk (nth 4 current-plexus))))
  ;; Remove record from nema table.
  (remhash uid (nth 2 current-plexus))))
#+END_SRC

*** Functions for gathering links

Links are stored on triples alongside other
elements.


#+BEGIN_SRC elisp
(defun get-forward-links (uid)
  "Return all links having given object as source."
  (mapcar 'car (gethash uid (nth 3 current-plexus))))

(defun get-backward-links (uid)
  "Return all links having given object as sink."
  (mapcar 'car (gethash uid (nth 4 current-plexus))))
#+END_SRC

*** On `label-nema'

Nemas can be given a unique human-readable label in addition
to their numeric uid.


#+BEGIN_SRC elisp
(defun label-nema (uid label)
  "Assign the label to the given object."
  (puthash uid label (nth 5 current-plexus))
  (puthash label uid (nth 6 current-plexus)))
#+END_SRC

*** Label to uid and uid to label lookup

These functions allow the exchange of uid and label.


#+BEGIN_SRC elisp
(defun label2uid (label)
  "Return the unique identifier corresponding to a label."
  (gethash label (nth 6 current-plexus) nil))

(defun uid2label (uid)
  "Return the label associated to a unique identifier."
  (gethash uid (nth 5 current-plexus) nil))
#+END_SRC

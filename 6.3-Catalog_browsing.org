** Catalog browsing
:PROPERTIES:
:LATEX_LABEL: catalog
:ID: catalog
:END:

*** Content-free browsing                                          :noexport:

A popular style of browsing ignores the content of the objects
themselves and looks only at their metadata.  Examples include library
catalogs or lists of search engine results.  Since you aren't actually
browsing the articles directly, this is ``browsing a catalog'' more
than it is ``browsing the library''.

Using this technique, one should be able to selectively choose
subcollections to look at, e.g. all the works by a given author or
what have you.  In this section, we provide code for browsing by
article name.  The code is an interface to a generic browsing/listing
command based on Emacs's built-in `list-buffers' command.  This setup
is designed with extensibility in mind, however it may be useful to
rewrite the selection mechanism (or add an alternate version) in order
to make each line in the current display into a bibliography-style or
index-card style reference.  This would make the information fit on
the screen better (and such modifications should be easy to make
later).

See Note [[id:standard-article-menu-accessors]] for a description of
the data that are displayed along with names in the listing.  We may
eventually want to be able to switch between several alternative
data-listings, e.g., we might want name, type, and namespace; or name,
article-about list, about-article list.  With if complicated lists
like this are used, we may want to have more than one line associated
with each name.

We currently provide only very basic functions for working with these
listings.


*** Catalog browsing in the scholium system                        :noexport:

This code provides a generic way to perform actions on rich objects
from a list.  It is assumed that each object has several attributes
that a user may be interested in.  ``Name'', ``size'' and ``mode'' are
familiar examples from `list-buffers'; here there can be an
arbitrary number of arbitrary attributes.  This makes this
mechanism useful in some cases where `completing-read' would not
provide the user with enough information.

The way attributes are obtained from objects is left up to the
user, as are the actual actions that can be performed on the
objects.

Generality comes at an obvious, unavoidable, cost, namely any given
deployment of this interface requires some extra set up -- examples
are provided.


*** Predicate support for listing                                  :noexport:
:PROPERTIES:
:LATEX_LABEL: predicate-support-for-listing
:ID: predicate-support-for-listing
:END:

Just for example, one thing people might want to do would be to list
the articles in the vicinity of the article being browsed or in a
certain section from a paper, and so on.  The function will work with
any set that we can select; what we need are a bunch of functions for
doing the selection.


*** History support for listing                                    :noexport:
:PROPERTIES:
:LATEX_LABEL: history-for-listing
:ID: history-for-listing
:END:

It would be good to maintain a special history list for this display,
that way if you browse a succession of nested catalogs, you can go
backwards and forwards to choose the best catalog.  (Catalogs are
similar to directories from dired, gopher, etc.)  See Section
[[id:temporal]] for a discussion of history support in general (start
with Note [[id:thematic-histories]]).


*** Purpose of generality                                          :noexport:

Different menus may be useful for different purposes.  A collection of
article \inp{name}s may frequently be insufficient data from which to
choose an article.  Different data may be useful for different times
and purposes, so we've made the system extensible.  It may be useful
to change the overall \emph{style} of the display as well (e.g. to
select from a list of multi-line records rather than a list of lines);
modifications at this level are on hold until such time as they are
needed.


*** On `make-generic-menu-mode'

This takes the name of the menu (as a space-separated string) together
with a list of bindings to be used in that particular menu mode.

This should provide a docstring for the mode it creates.


#+BEGIN_SRC elisp
(defmacro make-generic-menu-mode
  (mode bindings)
  (let* ((modedash (downcase (replace-regexp-in-string " " "-" mode)))
         (modesymbol (intern (concat modedash "-mode")))
         (mapname (intern (concat modedash "-map"))))
    `(progn
       (defvar ,mapname)
       (setq ,mapname (make-keymap))
       (suppress-keymap ,mapname t)
       (dolist (binding ,bindings)
         (define-key ,mapname (car binding) (cdr binding)))
       (defun ,modesymbol ()
         (kill-all-local-variables)
         (use-local-map ,mapname)
         (setq major-mode (quote ,modesymbol))
         (setq mode-name ,mode)
         (setq truncate-lines t)
         (setq buffer-read-only t)))))
#+END_SRC

*** On `generic-menu-noselect'
:PROPERTIES:
:LATEX_LABEL: generic-menu-noselect
:ID: generic-menu-noselect
:END:

The basic idea of this is that we have some \inp{objects} and some
functions to map across the objects to extract the information from
the objects (\inp{accessors}).  The functions must be set up to
produce strings as their output.  The functions correspond to columns
in the display; individual objects correspond to rows.  This is the
same idea no matter what the source of the objects is.  (In
particular, it might be a good idea for a later version of this
function to accept either a hash table or a list as the source of the
objects; see Note [[id:browsing-subcollections]].)  Note that columns
of the display are assumed to be as wide as their widest item!


#+BEGIN_SRC elisp
(defun generic-menu-noselect (objects accessors)
  (let (cols)
    (dolist (get-this accessors)
      ;; if we built this front-to-back rather than back-to-front,
      ;; that would be better
      (setq cols (cons
                  (cons (car get-this)
                        (mapcar (cdr get-this) objects))
                  cols)))
    ;; find the width of the columns.
    (let ((lens (mapcar (lambda (col)
                          (let ((len 0))
                            (dolist (str col)
                              (let ((candidate (length str)))
                                (when (> candidate len)
                                  (setq len candidate))))
                            len))
                        cols)))
      (with-current-buffer (get-buffer-create "*Generic List*")
        (setq buffer-read-only nil)
        (erase-buffer)
        (while cols
          (goto-char (point-min))
          (goto-char (line-end-position))
          (dolist (str (car cols))
            (insert str " ")
            ;; fill with spaces to make up for lost space
            (insert-char 32 (- (car lens) (length str)))
            (unless (equal (forward-line) 0)
              (newline))
            (goto-char (line-end-position)))
          (setq cols (cdr cols))
          (setq lens (cdr lens)))
        (goto-char (point-min))
        (current-buffer)))))
#+END_SRC

*** Improved sorting of article listing

Sorting could be done using autocompletion on the name of the column
to sort on, too, which would be kind of nice.  Or we could make a
command to sort on the current column, or reorder columns according to
the values on the current line or just about anything you might like.

But I don't think sorting is going to work at all until we have a
consistent way of identifying the fields to sort; in the case of
strings with spaces in them, `sort-fields' won't work.  Since we
compute the width of each of the columns in `generic-menu-noselect',
if we were to store this info (perhaps as a text property attached to
each column heading), we could adroitly divide the text up to find the
strings we're trying to sort.  See Note [[id:text-properties-in-article-listing]].


#+BEGIN_SRC elisp
(defun Generic-menu-sort (col)
  (interactive "P")
  (save-excursion
    (sort-fields (or col 1) (progn (goto-line 2)
                                   (point))
                 (point-max))))
#+END_SRC

*** Hierarchies for browsing                                       :noexport:

Hierarchies are somewhat similar to menus, e.g., we might
want to use hierarchies to display sub-library relationships.
(This is like KM's ontology browser.)  Of course, graph
browsing would be even more generic (but display of these
things seems a bit far removed from what we can do right now).


*** Reuse of names from article listing                            :noexport:

It would be nice if names were displayed together with quote marks
making the printed versions of the names appropriate for direct
re-use.


*** On `standard-article-menu-accessors'
:PROPERTIES:
:LATEX_LABEL: standard-article-menu-accessors
:ID: standard-article-menu-accessors
:END:

Note that it would be easy to provide more metadata -- just revise
this variable with additional fields as desired.  See Note
[[id:generic-menu-noselect]] for a description of how accessors work.


#+BEGIN_SRC elisp
(defvar standard-article-menu-accessors
  '(("Name" . identity)
    ("C"    . (lambda (elt) " "))))
#+END_SRC

*** Control panels                                                 :noexport:
:PROPERTIES:
:LATEX_LABEL: control-panels
:ID: control-panels
:END:

A little control panel on the left of the article listing comprised of
various toggle-state elements provides a way to interactively
manipulate the articles individually or \emph{en masse} (see section
[[id:masse]]).  (The only feature in the control panel for now is an
indicator showing which article is current; this is indicated by a dot
in the ``C'' column.)


*** On `article-menu-listing-hook'

This is here to
customize the behavior of the article menu listing.  Currently it
is used to offset the activities invoked by
`currently-displayed-label-hook'; whereas we want
`currently-displayed-label' to be defined when the listing is
used to display a label, we'd rather it be `nil' when something
other than a label has been displayed, since anything else could
be misleading.


#+BEGIN_SRC elisp
(defvar article-menu-listing-hook nil)
#+END_SRC

*** On `article-menu-listing'

The optional input \inp{subset} is a list of article names to pump
into the generic menu; it defaults to the list of ``plain'' articles
as recorded on the corresponding label.  The optional input
\inp{accessors} specifies the functions to use to extract information
from the articles named by \inp{subset}; it is in the format of, and
defaults to, `standard-article-menu-accessors'.  (Note that function
plays a similar role to `Buffer-menu-revert' from buff-menu.el.)


#+BEGIN_SRC elisp
(defun article-menu-listing (&optional subset accessors)
  (interactive)
  (pop-to-buffer
   (generic-menu-noselect
    ;; maybe this should always handle propertizing itself?
    (or subset
        (label-to-propertized-list 'plain))
    (or accessors
        standard-article-menu-accessors)))
  ;; note, this runs every time, even if the current article
  ;; isn't on the list.
  (article-menu-point-out-current-article)
  (article-menu-mode)
  (run-hooks 'article-menu-listing-hook))

(add-hook 'article-menu-listing-hook (lambda ()
                                       (setq currently-displayed-label
                                             nil)))
#+END_SRC

*** On `turn-article-table-into-list'

I hate to actually use this function the way it is used in
`display-article'... probably we should just select from the
\emph{plain} articles there, and write a separate function to display
other articles.  In short, there really shouldn't be any need to use
this function, except maybe for debugging purposes or \emph{explicit}
listing of all the articles (whenever that really needs to be done).


#+BEGIN_SRC elisp
(defun turn-article-table-into-list ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               ;; It might be nice to have %S here, but
               ;; I don't know if it would be _useful_
               (nconc names (list (format "%s" name))))
             article-table)
    (cdr names)))
#+END_SRC

*** On `turn-article-table-into-names'

This is a variant of `turn-article-table-into-list'
that produces the actual names of the articles;
probably it should supercede the other, since we could
get the print names by mapping over the output of this
function, obviously.


#+BEGIN_SRC elisp
(defun turn-article-table-into-names ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               (nconc names (list name)))
             article-table)
    (cdr names)))
#+END_SRC

*** On `turn-article-table-into-propertized-list'

This combines the best of both `turn-article-table-into-list' and
`turn-article-table-into-names'.  Compare
`label-to-propertized-list'.


#+BEGIN_SRC elisp
(defun turn-article-table-into-propertized-list ()
  (let ((names (list t)))
    (maphash (lambda (name value)
               (nconc names
                      (list 
                       (propertize (format "%s" name) 'name name))))
             article-table)
    (cdr names)))
#+END_SRC

*** On `turn-list-into-propertized-list'
:PROPERTIES:
:LATEX_LABEL: turn-list-into-propertized-list
:ID: turn-list-into-propertized-list
:END:

Turns an arbitrary list into a propertized list.


#+BEGIN_SRC elisp
(defun turn-list-into-propertized-list (lis)
  (let (names)
    (mapc (lambda (name)
            (setq names (cons
                         (propertize (format "%s" name) 'name name)
                         names)))
          lis)
    names))
#+END_SRC

*** Special-purpose listings
:PROPERTIES:
:LATEX_LABEL: special-listings
:ID: special-listings
:END:

Here are a few functions to list special collections of articles.
The function `article-menu-list-labels' is perhaps particularly
noteworthy; browsing labels seems to be a powerful way of organizing
and retrieving information, see Note [[id:browsing-subcollections]].


#+BEGIN_SRC elisp
(defun article-menu-list-plain-articles ()
  (interactive)
  (article-menu-listing))

(defun article-menu-list-all-articles ()
  (interactive)
  (article-menu-listing (turn-article-table-into-propertized-list)))

(defun article-menu-list-metadata-articles ()
  (interactive)
  (article-menu-listing (label-to-propertized-list 'metadata)))

(defun article-menu-list-labels ()
  (interactive)
  (article-menu-listing (label-to-propertized-list 'label)))

(defun list-articles (lis)
  (interactive)
  (article-menu-listing (turn-list-into-propertized-list lis)))
#+END_SRC

*** Using text properties in the article listing                   :noexport:
:PROPERTIES:
:LATEX_LABEL: text-properties-in-article-listing
:ID: text-properties-in-article-listing
:END:

The approach that I've been using so far, searching for spaces, won't
work if the names of the columns have spaces in them.  Something more
sophisticated (probably using text properties) would work better in
general.  It would also be handy to tuck the articles ``true names''
in as text properties attached to the print names.


*** On `article-menu-display-article'

The point is to grab the name of the article on the currrent line of
the listing and display it.  This needs to be checked a bit in the
multicolumn case (which itself needs to be explored).


#+BEGIN_SRC elisp
(defun article-menu-display-article ()
  (interactive)
  (when (> (line-number-at-pos) 1)
    (save-excursion
      (goto-char (line-beginning-position))
      (search-forward-regexp "[. >] .")
      (setq name-of-current-article
            (get-text-property (point) 'name))
      (article-menu-point-out-current-article)
      (display-article name-of-current-article))))
#+END_SRC

*** On `article-menu-mark-article'

Use this to mark the article mentioned on this line.


#+BEGIN_SRC elisp
(defun article-menu-mark-article ()
  (interactive)
  (setq buffer-read-only nil)
  (when (> (line-number-at-pos) 1)
    (goto-char (line-beginning-position))
    (delete-char 1)
    (insert ">")
    (when (< (line-number-at-pos)
             (progn (save-excursion (goto-char (point-max))
                                    (line-number-at-pos))))
      (forward-line 1)))
  (setq buffer-read-only t))
#+END_SRC

*** On `article-menu-unmark-article'

Use this to remove any mark on the article mentioned on this line.


#+BEGIN_SRC elisp
(defun article-menu-unmark-article ()
  (interactive)
  (setq buffer-read-only nil)
  (when (and (> (line-number-at-pos) 1)
             (not (save-excursion (goto-char (line-beginning-position))
                                  (looking-at "\\."))))
    (goto-char (line-beginning-position))
    (delete-char 1)
    (insert " ")
    (when (< (line-number-at-pos)
             (progn (save-excursion (goto-char (point-max))
                                    (line-number-at-pos))))
      (forward-line 1)))
  (setq buffer-read-only t))

(defun article-menu-unmark-all-articles ()
  (interactive)
  (setq buffer-read-only nil)
  (save-excursion (goto-line 2)
                  (goto-char (line-beginning-position))
                  (while (re-search-forward "^>" nil t)
                    (replace-match " ")))
  (setq buffer-read-only t))
#+END_SRC

*** On `article-menu-point-out-current-article'

This is a non-interactive function that puts a dot in front
of the current article when the article listing is generated.


#+BEGIN_SRC elisp
(defun article-menu-point-out-current-article ()
  (goto-char (point-min))
  (setq buffer-read-only nil)
  (save-excursion (when (search-forward-regexp "^\\." nil t)
                    (replace-match " ")))
  (when (and
         name-of-current-article
         (search-forward-regexp
          ;; maybe this `(format "%s" name-of-current-article)'
          ;; stuff should be stored as some kind of function,
          ;; like `print-name-of-article' or something like that
          (concat "^[. ] " (regexp-quote
                            (format "%s" name-of-current-article)))
          nil t))
    (replace-match (concat ". " (substring (match-string 0) 2))))
  (goto-char (line-beginning-position))
  (setq buffer-read-only t))
#+END_SRC

*** Features of the article menu
:PROPERTIES:
:LATEX_LABEL: features-of-the-article-menu
:ID: features-of-the-article-menu
:END:

The only ``actionable'' feature of the current listing is display.
See also Note [[id:control-panels]].


#+BEGIN_SRC elisp
(make-generic-menu-mode "Article Menu"
                        '(("g" . article-menu-listing)
                          ("m" . article-menu-mark-article)
                          ("u" . article-menu-unmark-article)
                          ("U" . article-menu-unmark-all-articles)
                          ("q" . quit-window)
                          ("\C-m" . article-menu-display-article)))
#+END_SRC

*** Additional actions                                             :noexport:

We also want to have a function that will give the semantics for
``select'' and other sorts of things that we might be able to do to
the objects that we've listed.  (Maybe we should pass this in along
with the objects, and set it up as a local variable that can be called
later.)


*** Search engine interface                                        :noexport:
:PROPERTIES:
:LATEX_LABEL: search-engine-interface
:ID: search-engine-interface
:END:

It will be useful to interface this browsing mechanism with a
simple predicate matching mechanism.  Sometimes we'll want to
restrict search (Note [[id:restricting-search]]), but for now,
we might as well write a function that searches everything.

A more advanced search engine would apply general predicates
to create the list (e.g. it would allow the user to
restrict to scholia of a certain type, or that \emph{have}
scholia of a given type, or that match other computed properties).

Other basic advances would be to have a second column that
showed the actual match, and to display the matches in order
according to the position of the articles in question within
some specific linearization of the document (e.g. the main one).

The main functions in the ``search engine'' so far are
`article-menu-list-articles-matching-regexp' (Note 
[[id:article-menu-list-articles-matching-regexp]]) and
`article-menu-list-articles-matching-predicate' (Note 
[[id:article-menu-list-articles-matching-predicate]])


*** On `article-menu-list-articles-matching-regexp'
:PROPERTIES:
:LATEX_LABEL: article-menu-list-articles-matching-regexp
:ID: article-menu-list-articles-matching-regexp
:END:

This makes a listing showing all of the articles that match
\inp{regexp}.

\emph{(It would be nice if we could leave out meta, reference,
code, and label types of articles in the default version of
this.)}


#+BEGIN_SRC elisp
(defun article-menu-list-articles-matching-regexp (regexp)
  (interactive "MRegexp: ")
  (let ((matches (mapcar
                  (lambda (name)
                    (propertize (format "%s" name) 'name name))
                  (remove-if
                   (lambda (elt)
                     (not
                      (with-temp-buffer
                        ;; rough, not bothering with
                        ;; `sch-plain-text'
                        (let ((article (get-article elt)))
                          (insert
                           (format "%s"
                                   (scholium-name (get-article elt)))
                           "\n"
                           (format "%s"
                                   (scholium-text article)))
                          (goto-char (point-min))
                          (search-forward-regexp regexp
                                                 nil t)))))
                   (turn-article-table-into-names)))))
    (if matches
        (article-menu-listing matches)
      (message "No hits."))))
#+END_SRC

*** On `article-menu-list-articles-matching-predicate'
:PROPERTIES:
:LATEX_LABEL: article-menu-list-articles-matching-predicate
:ID: article-menu-list-articles-matching-predicate
:END:

This is a way to pick out all of the articles in the library
that match a given predicate.


#+BEGIN_SRC elisp
(defun article-menu-list-articles-matching-predicate (pred)
  (let ((matches (mapcar
                  (lambda (name)
                    (propertize (format "%s" name) 'name name))
                  (remove-if (lambda (elt) (not (funcall pred elt)))
                             (turn-article-table-into-names)))))
    (if matches
        (article-menu-listing matches)
      (message "No hits."))))
#+END_SRC

*** Restricting search                                             :noexport:
:PROPERTIES:
:LATEX_LABEL: restricting-search
:ID: restricting-search
:END:

If we have lots of subcollections, then we will sometimes need to
search through all of them, and sometimes, only through some subset.
When doing search, there are two efficient ways to limit things (and
these are very similar): either add subcollections that match some
predicate, or remove subcollections that match some predicate.


*** Saving search results                                          :noexport:

It would be handy to be able to store the listings generated by
search in some workspace.  As a prior step, one needs to be able
to turn the arbitrary listing into an article (specifically, a
label)!


*** Browsing subcollections                                        :noexport:
:PROPERTIES:
:LATEX_LABEL: browsing-subcollections
:ID: browsing-subcollections
:END:

Compare Section
# [[id:displaying-labels]]
(should that stuff go here?).
Also note that functionality for displaying sub-objects made out of
hash tables should probably be worked in.  Note that browsing from
list to list is similar to the Gopher experience.

One special sort of subcollection to browse would be one generated by
search.  A variant of `multi-occur' that resolves at the scholium
level would be very handy to have (see Note
[[id:search-engine-interface]]).


*** Display all matches in full                                    :noexport:

Instead of just providing the \emph{listing}, sometimes
it could be handy to display a concatenation of all
matching texts (maybe with the matching words highlighted).
Compare Note [[id:derivative-works-in-the-scholium-system]].


*** On `display-article-listing'

This just puts the cursor in the article listing.


#+BEGIN_SRC elisp
(defun display-article-listing ()
  (interactive)
  (pop-to-buffer "*Generic List*"))
#+END_SRC

*** Arrangement of listing window                                  :noexport:

The generic list should always go on the \emph{left} in our display,
and similarly with files that have their own buffers.  This is
especially relevant whenever we're treating the listing as an article,
cf. Note [[id:display-label]].  It is possible, although perhaps
unlikely, that sometimes we'll want article listings to be mapped into
the Main Article Display set to a Generic List Mode.


*** Static catalog display                                         :noexport:

It might be advantageous to not have the display disappear -- which
presumably means, display the articles that it lists as scholia
attached to it; otherwise, they display and their scholia display, and
there isn't enough room on the display for the catalog.  Something
like this should be easy enough to do.


*** Electric catalog                                               :noexport:

Probably we could write things so that sections display directly when
the cursor moves over the relevant line in the catalog.  This would
make browsing entries very speedy.


*** Scholia attached to sections                                   :noexport:

When we import the system (Note [[id:import-scholium-system]]),
an article is created for each section that is displayed
as a listing.  Such articles are currently displayed
together with all of the articles \emph{in} the section shown
as attached scholia.  It would probably be nice to be able
to turn this ``feature'' off (also perhaps on a 
browsing-style-dependant basis).


#+TITLE: Arxana Spine 2 (Prototype 1)
#+AUTHOR: Futon4 / Arxana team
#+OPTIONS: toc:t num:t
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER: \usepackage[margin=2cm]{geometry}

* Overview
This staging spine captures the Prototype 1 state of the revived Arxana
client while we fold each dev module back into the literate sources.

#+INCLUDE: "0-Reintroduction.org"

* Quickstart

- Start Futon1 locally (`http://localhost:8080`).
- `M-x load-file` → `arxana/dev/bootstrap.el`
- `M-x arxana-build` (use `C-u` to force tangling).
- `(setq futon4-base-url "http://localhost:8080/api/alpha")`
- `(setq futon4-enable-sync t)`
- Register buffers: `(make-current-buffer-into-article "Demo")`
- Capture scholia: `(scholium "demo/link" "Note" '(("Demo")))`

#+BEGIN_SRC emacs-lisp :tangle dev/bootstrap2.el
(load (expand-file-name "dev/bootstrap.el" default-directory))
#+END_SRC

* Recent changes (futon4, pilot)

- Arxana view: `M-x arxana-docbook-browse-futon4` (browse doc book inside Emacs).
- Org include (pilot): [[file:dev/logs/books/futon4/index.org]]

* Storage bridge

#+INCLUDE: "docs/storage-bridge.org"

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-store.el
;;; arxana-store.el --- Futon storage bridge helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Thin wrappers around the Futon1 HTTP API. These helpers sit on top of
;; the historical `futon4-*` functions so callers have a consistent,
;; testable interface for ensuring articles, storing scholia, and fetching
;; data back from the server.

;;; Code:

(require 'cl-lib)
(require 'json)
(require 'subr-x)
(require 'url)
(require 'url-http)

(defgroup arxana-store nil
  "Futon storage bridge settings."
  :group 'arxana)

(defcustom arxana-store-default-profile nil
  "Optional profile name to send via the X-Profile header."
  :type '(choice (const :tag "Default" nil)
                 string)
  :group 'arxana-store)

(defcustom arxana-store-request-timeout 10
  "Number of seconds to wait for Futon HTTP responses."
  :type 'integer
  :group 'arxana-store)

(defconst arxana-store--snapshot-scopes '("all" "latest")
  "Valid snapshot scope identifiers for Futon/XTDB backups.")

(defvar arxana-store-last-error nil
  "Most recent storage error (plist with :reason, :detail, :context).")

(defvar arxana-store-last-response nil
  "Most recent JSON body returned by `arxana-store--request'.")

(defun arxana-store-clear-error ()
  "Clear `arxana-store-last-error'."
  (setq arxana-store-last-error nil))

(defun arxana-store-sync-enabled-p ()
  "Return non-nil when Futon sync is enabled."
  (and (boundp 'futon4-enable-sync)
       futon4-enable-sync))

(defun arxana-store--record-error (reason detail &optional context)
  "Remember an error REASON/DETAIL/CONTEXT and log it."
  (setq arxana-store-last-error (list :reason reason
                                      :detail detail
                                      :context context))
  (message "[arxana-store] %s" detail)
  nil)

(defun arxana-store--base-url ()
  (or (and (boundp 'futon4-base-url) futon4-base-url)
      (error "futon4-base-url is not set")))

(defun arxana-store--build-url (path &optional query)
  (concat (arxana-store--base-url)
          path
          (if (and query (> (length query) 0))
              (concat "?" query)
            "")))

(defun arxana-store--encode-segment (value)
  (url-hexify-string (or value "")))

(defun arxana-store--query-string (params)
  (let ((pairs
         (delq nil
               (mapcar (lambda (kv)
                         (when (cdr kv)
                           (format "%s=%s"
                                   (car kv)
                                   (arxana-store--encode-segment (format "%s" (cdr kv))))))
                       params))))
    (when pairs
      (string-join pairs "&"))))

(defun arxana-store--default-headers (payload-p)
  (append (list '("Accept" . "application/json"))
          (when payload-p '(("Content-Type" . "application/json")))
          (when arxana-store-default-profile
            (list (cons "X-Profile" arxana-store-default-profile)))))

(defun arxana-store--canonical-path (path)
  (if (and path (fboundp 'futon4--canonical-path))
      (futon4--canonical-path path)
    path))

(defun arxana-store--request (method path &optional payload query)
  "Fire METHOD PATH against Futon and return the parsed JSON body.
Optional PAYLOAD is JSON encoded for POST requests. QUERY is an
already encoded query string (without the leading ?)."
  (if (not (arxana-store-sync-enabled-p))
      (arxana-store--record-error 'disabled "Futon sync disabled" method)
    (let* ((url-request-method method)
           (url-request-data (when payload
                               (encode-coding-string (json-encode payload) 'utf-8)))
           (url-request-extra-headers (arxana-store--default-headers payload))
           (target (arxana-store--build-url path query)))
      (condition-case err
          (let ((buf (url-retrieve-synchronously target nil nil arxana-store-request-timeout)))
            (if (not (buffer-live-p buf))
                (progn
                  (when buf (kill-buffer buf))
                  (arxana-store--record-error 'connection "No response buffer" target))
              (with-current-buffer buf
                (goto-char (point-min))
                (if (not (re-search-forward "\r?\n\r?\n" nil t))
                    (progn
                      (kill-buffer buf)
                      (arxana-store--record-error 'protocol "Malformed HTTP response" target))
                  (let* ((json-object-type 'alist)
                         (json-array-type 'list)
                         (json-key-type 'keyword)
                         (body (ignore-errors (json-read))))
                    (kill-buffer buf)
                    (if body
                        (progn
                          (setq arxana-store-last-error nil
                                arxana-store-last-response body)
                          body)
                      (arxana-store--record-error 'protocol "Failed to parse Futon JSON" target)))))))
        (error
         (arxana-store--record-error 'request err target))))))

(defun arxana-store--normalize-snapshot-scope (scope context)
  "Return the canonical snapshot SCOPE string or record an error for CONTEXT."
  (let ((value (cond
                ((null scope) "all")
                ((stringp scope) scope)
                ((symbolp scope) (symbol-name scope))
                (t scope))))
    (if (member value arxana-store--snapshot-scopes)
        value
      (arxana-store--record-error
       'invalid
       (format "Unknown snapshot scope %S (expected %s)"
               scope arxana-store--snapshot-scopes)
       context))))

(defun arxana-store--snapshot-scope-prompt (&optional prompt default)
  "Prompt user for a snapshot scope using PROMPT and DEFAULT."
  (let* ((prompt (or prompt "Snapshot scope (all/latest): "))
         (default (or default "all"))
         (choice (completing-read prompt arxana-store--snapshot-scopes
                                  nil t nil nil default)))
    (intern choice)))

(cl-defun arxana-store-ensure-entity (&key id name type source external-id seen-count pinned? last-seen)
  "Ensure Futon has an entity named NAME of TYPE, returning the response.
ID, SOURCE, EXTERNAL-ID, SEEN-COUNT, PINNED?, and LAST-SEEN mirror the
payload accepted by Futon's `/entity` endpoint. TYPE may be a keyword or
string. Signals a user error when NAME is missing."
  (unless name
    (user-error "Entity name is required"))
  (let* ((payload (delq nil (list (cons 'name name)
                                  (cons 'type (if (keywordp type)
                                                  (symbol-name type)
                                                type))
                                  (when id (cons 'id id))
                                  (when source (cons 'source source))
                                  (when external-id (cons 'external-id external-id))
                                  (when seen-count (cons 'seen-count seen-count))
                                  (when pinned? (cons 'pinned pinned?))
                                  (when last-seen (cons 'last-seen last-seen))))))
    (arxana-store--request "POST" "/entity" payload)))

;;; (rest of file omitted for brevity)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-saving.el
;;; arxana-saving.el --- Snapshot-aware save/restore helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Provides runtime shims so the legacy `save-all-scholia` and
;; `read-scholia-file` commands can drive Futon's snapshot endpoints when
;; sync is enabled.  When sync is disabled the original file-based
;; implementations continue to run unchanged.

;;; Code:

(require 'subr-x)

(declare-function arxana-store-save-snapshot "arxana-store" (&optional scope label))
(declare-function arxana-store-restore-snapshot "arxana-store" (&optional snapshot-id scope))
(declare-function arxana-store--snapshot-scope-prompt "arxana-store" (&optional prompt default))
(declare-function arxana-store--snapshot-id-from-response "arxana-store" (response))

(defconst arxana-saving--fallback-scopes '("all" "latest")
  "Scopes offered when the store helpers are unavailable.")

(defun arxana-saving--prompt-scope (prompt default)
  "Read a snapshot scope with PROMPT and DEFAULT.
Returns DEFAULT without prompting when running noninteractively."
  (cond
   (noninteractive default)
   ((fboundp 'arxana-store--snapshot-scope-prompt)
    (arxana-store--snapshot-scope-prompt prompt default))
   (t (completing-read prompt arxana-saving--fallback-scopes nil t nil nil default))))

(defun arxana-saving--prompt-label ()
  "Ask the user for an optional snapshot label.
Returns nil without prompting when running noninteractively."
  (if noninteractive
      nil
    (let ((label (read-string "Snapshot label (optional): ")))
      (unless (string-empty-p label)
        label))))

(defun arxana-saving--snapshot-enabled-p ()
  "Return non-nil when snapshot shims should run."
  (and (boundp 'futon4-enable-sync)
       futon4-enable-sync
       (fboundp 'arxana-store-save-snapshot)))

(defun arxana-saving--restore-enabled-p ()
  "Return non-nil when restore shims should run."
  (and (boundp 'futon4-enable-sync)
       futon4-enable-sync
       (fboundp 'arxana-store-restore-snapshot)))

(defun arxana-saving--wrap-save-all (orig-fn filename &optional scope)
  "Around advice for `save-all-scholia'.
ORIG-FN is the original implementation; FILENAME and SCOPE are passed
from the caller (SCOPE is only present when invoked programmatically)."
  (if (arxana-saving--snapshot-enabled-p)
      (let* ((scope (or scope (arxana-saving--prompt-scope "Snapshot scope (all/latest): " "all")))
             (label (or (and noninteractive filename)
                        (arxana-saving--prompt-label)))
             (response (arxana-store-save-snapshot scope label))
             (id (when (fboundp 'arxana-store--snapshot-id-from-response)
                   (arxana-store--snapshot-id-from-response response))))
        (message "Saved Futon snapshot scope=%s id=%s"
                 scope (or id "<unknown>")))
    (apply orig-fn (list filename))))

(defun arxana-saving--wrap-read-scholia (orig-fn filepath &optional scope)
  "Around advice for `read-scholia-file'.
ORIG-FN is the original implementation; FILEPATH is treated as a
snapshot id when syncing is enabled."
  (if (arxana-saving--restore-enabled-p)
      (let* ((snapshot-id (unless (string-empty-p filepath) filepath))
             (scope (or scope (arxana-saving--prompt-scope "Restore scope (all/latest): " "all"))))
        (arxana-store-restore-snapshot snapshot-id scope))
    (apply orig-fn (list filepath))))

(with-eval-after-load 'arxana-tangled
  (when (fboundp 'save-all-scholia)
    (advice-add 'save-all-scholia :around #'arxana-saving--wrap-save-all))
  (when (fboundp 'read-scholia-file)
    (advice-add 'read-scholia-file :around #'arxana-saving--wrap-read-scholia)))

(provide 'arxana-saving)

;;; arxana-saving.el ends here
#+END_SRC

#+INCLUDE: "dev/arxana-store.el" src emacs-lisp

* Pattern workflows

The reanimation plan calls out pattern tooling as the last literate piece: we need both the pattern editing helpers and the ingest shims (see docs/reanimation-plan.org) inside the new spine so contributors change Org first and then tangle.

** Editing Futon pattern entries

These commands let Emacs users work with Futon patterns without leaving Org buffers.

- `M-x arxana-patterns-open` — fetch a Futon pattern (e.g., `mojo/center`) into an Org buffer, complete with the component identifiers.
- Edit the buffer like any other Org document; the Futon ids stay in the headings so provenance survives.
- `g` (`arxana-patterns-refresh-buffer`) refetches the same slug; `C-c C-s` (`arxana-patterns-save`) pushes the updated text back to Futon.
- Run `dev/run-tests.sh` before publishing to confirm the pattern helpers and storage shims still behave.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-patterns.el
;;; arxana-patterns.el --- Futon pattern importer/editor -*- lexical-binding: t; -*-

;;; Commentary:
;; Fetch pattern-library entries from Futon1 (patterns ingested from Futon3) and
;; render them as editable Org buffers.  Each buffer exposes the pattern summary
;; and component passages so Emacs users can review and update pattern text
;; without dropping into the Futon CLI.

;;; Code:

(require 'cl-lib)
(require 'seq)
(require 'subr-x)
(require 'org)

(require 'arxana-store)

(defgroup arxana-patterns nil
  "Utilities for browsing Futon pattern entities in Emacs."
  :group 'arxana)

(defcustom arxana-patterns-ego-limit 64
  "Number of neighbor links to request when fetching Futon pattern data."
  :type 'integer
  :group 'arxana-patterns)

(defvar-local arxana-patterns--pattern nil
  "Buffer-local plist describing the currently loaded pattern.")

(defconst arxana-patterns--summary-begin "#+BEGIN_SUMMARY")
(defconst arxana-patterns--summary-end "#+END_SUMMARY")

(defvar arxana-patterns-view-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-s") #'arxana-patterns-save)
    (define-key map (kbd "g") #'arxana-patterns-refresh-buffer)
    map)
  "Keymap for `arxana-patterns-view-mode'.")

(define-minor-mode arxana-patterns-view-mode
  "Minor mode for pattern editing buffers."
  :lighter " Pattern"
  :keymap arxana-patterns-view-mode-map
  (when arxana-patterns-view-mode
    (setq header-line-format "C-c C-s to sync changes; g to refetch from Futon")))

(defun arxana-patterns--ensure-sync ()
  (unless (arxana-store-sync-enabled-p)
    (user-error "Futon sync is disabled; enable futon4-enable-sync first")))

(defun arxana-patterns--alist (key alist)
  (alist-get key alist))

(defun arxana-patterns--alist-like-p (value)
  (and (listp value)
       (let ((first (car-safe value)))
         (and first (consp first)))))

(defun arxana-patterns--entity-value (entity &rest keys)
  "Return the first matching value in ENTITY for the provided :entity/* KEYS."
  (when (arxana-patterns--alist-like-p entity)
    (seq-some (lambda (key)
                (let ((cell (assoc key entity)))
                  (when cell (cdr cell))))
              keys)))

(defun arxana-patterns--entity-from-version (entity)
  "Return the entity payload stored inside ENTITY's version data, if any."
  (when (arxana-patterns--alist-like-p entity)
    (let* ((version (arxana-patterns--alist :version entity))
           (data (and (arxana-patterns--alist-like-p version)
                      (arxana-patterns--alist :data version)))
           (payload (and (arxana-patterns--alist-like-p data)
                         (arxana-patterns--alist :entity data))))
      (and (arxana-patterns--alist-like-p payload) payload))))

(defun arxana-patterns--find-entity (tree target-id)
  "Locate the entity with TARGET-ID inside TREE (direct or linked payloads)."
  (let ((match nil))
    (cl-labels ((entity-matches-p (entity)
                  (let ((id (arxana-patterns--entity-value entity :id :entity/id)))
                    (and id target-id (equal id target-id))))
                (walk (node)
                  (when (and node (not match))
                    (cond
                     ((arxana-patterns--alist-like-p node)
                      (when (entity-matches-p node)
                        (setq match node))
                      (dolist (pair node)
                        (when (and (consp pair) (not match))
                          (walk (cdr pair)))))
                     ((listp node)
                      (dolist (item node)
                        (walk item)))))))
      (walk tree)
      match)))

(defun arxana-patterns--pattern-entity (ego)
  (arxana-patterns--alist :entity ego))

(defun arxana-patterns--resolve-entity-by-name (name)
  "Return the Futon entity alist for NAME via `/ego`."
  (let* ((ego-response (arxana-store-ego name 1))
         (ego (and ego-response (arxana-patterns--alist :ego ego-response))))
    (and ego (arxana-patterns--alist :entity ego))))

(defun arxana-patterns--relation-text (value)
  "Return VALUE as a normalized relation string without the leading colon."
  (let ((text (cond
               ((keywordp value) (symbol-name value))
               ((symbolp value) (symbol-name value))
               ((stringp value) value)
               (t nil))))
    (when text
      (if (and (> (length text) 0)
               (eq (aref text 0) ?:))
          (substring text 1)
        text))))

(defun arxana-patterns--relation-match-p (value target)
  "Return non-nil when VALUE (keyword/string) matches TARGET (string/keyword)."
  (let ((lhs (arxana-patterns--relation-text value))
        (rhs (arxana-patterns--relation-text target)))
    (and lhs rhs (string= lhs rhs))))

(defun arxana-patterns--component-links (ego)
  (when (arxana-patterns--alist-like-p ego)
    (let* ((links (arxana-patterns--alist :links ego))
           (link-outgoing (and (arxana-patterns--alist-like-p links)
                               (arxana-patterns--alist :outgoing links)))
           (outgoing (or (arxana-patterns--alist :outgoing ego) link-outgoing)))
      (seq-filter (lambda (entry)
                    (arxana-patterns--relation-match-p
                     (arxana-patterns--alist :relation entry)
                     ":pattern/includes"))
                  outgoing))))

(defun arxana-patterns--component-slug-base (name)
  (when (and name (string-match "\\`\\(.+\\)/[0-9]+-[^/]+\\'" name))
    (match-string 1 name)))

(defun arxana-patterns--component-link-name (link)
  (let ((entity (arxana-patterns--alist :entity link)))
    (or (arxana-patterns--entity-value entity :name :entity/name)
        (arxana-patterns--entity-value entity :ident :entity/ident))))

(defun arxana-patterns--lookup-component-by-name (component-name)
  (let ((base (arxana-patterns--component-slug-base component-name)))
    (when base
      (let* ((ego-response (arxana-store-ego base arxana-patterns-ego-limit))
             (ego (and ego-response (arxana-patterns--alist :ego ego-response)))
             (links (and (arxana-patterns--alist-like-p ego)
                         (arxana-patterns--component-links ego)))
             (matching (and links
                            (cl-find-if (lambda (link)
                                          (string= (arxana-patterns--component-link-name link)
                                                   component-name))
                                        links))))
        (when matching
          (arxana-patterns--fetch-component matching))))))

(defun arxana-patterns--lookup-component-by-prefix (component-name)
  (let ((base (arxana-patterns--component-slug-base component-name)))
    (when base
      (let* ((ego-response (arxana-store-ego base arxana-patterns-ego-limit))
             (ego (and ego-response (arxana-patterns--alist :ego ego-response)))
             (links (and (arxana-patterns--alist-like-p ego)
                        (arxana-patterns--component-links ego)))
             (matching (and links
                            (cl-find-if (lambda (link)
                                          (let ((name (arxana-patterns--component-link-name link)))
                                            (and name (string-prefix-p name component-name))))
                                        links))))
        (when matching
          (arxana-patterns--fetch-component matching))))))

(defun arxana-patterns--extract-summary ()
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (if (re-search-forward (concat "^" (regexp-quote arxana-patterns--summary-begin) "\\s-*$") nil t)
          (let ((start (progn (forward-line 1) (point))))
            (if (re-search-forward (concat "^" (regexp-quote arxana-patterns--summary-end) "\\s-*$") nil t)
                (string-trim (buffer-substring-no-properties start (match-beginning 0)))
              ""))
        ""))))

(defun arxana-patterns--read-header-field (label)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t)
          (rx (format "^#\\+%s: \\(.*\\)$" (regexp-quote label))))
      (when (re-search-forward rx nil t)
        (string-trim (match-string 1))))))

(defun arxana-patterns--component-name-info (name)
  (if (and name (string-match "/\\([0-9]+\\)-\\([^/]+\\)$" name))
      (list :order (string-to-number (match-string 1 name))
            :kind (match-string 2 name))
    (list :order 0 :kind (or name "component"))))

(defun arxana-patterns--component-parent-id (component-name)
  (when component-name
    (let* ((ego-response (ignore-errors (arxana-store-ego component-name arxana-patterns-ego-limit)))
           (ego (and ego-response (arxana-patterns--alist :ego ego-response)))
           (incoming (and ego (arxana-patterns--alist :incoming ego)))
           (parent-link (and incoming
                             (cl-find-if (lambda (entry)
                                           (arxana-patterns--relation-match-p
                                            (arxana-patterns--alist :relation entry)
                                            ":pattern/component-parent"))
                                         incoming))))
      (when parent-link
        (let* ((entity (arxana-patterns--alist :entity parent-link)))
          (or (arxana-patterns--alist :entity/id entity)
              (arxana-patterns--alist :id entity)))))))

(defun arxana-patterns--fetch-entity-source (entity-id)
  (when entity-id
    (let* ((response (ignore-errors (arxana-store-fetch-entity entity-id)))
           (entity (and response (arxana-patterns--alist :entity response)))
           (linked (and response (arxana-patterns--find-entity response entity-id)))
           (version-entity (or (arxana-patterns--entity-from-version entity)
                               (arxana-patterns--entity-from-version linked)))
           (candidates (delq nil (list entity version-entity linked))))
      (cl-labels ((value (&rest keys)
                    (seq-some (lambda (candidate)
                                (apply #'arxana-patterns--entity-value candidate keys))
                              candidates)))
        (when (or candidates (plist-get (car candidates) :id))
          (list :source (or (value :source :entity/source) "")
                :external-id (value :external-id :entity/external-id)
                :name (value :name :entity/name)
                :id (or (value :id :entity/id) entity-id)))))))

(defun arxana-patterns--fetch-component (link)
  (let* ((entity (arxana-patterns--alist :entity link))
         (component-id (or (arxana-patterns--alist :entity/id entity)
                           (arxana-patterns--alist :id entity)))
         (component-name (or (arxana-patterns--alist :entity/name entity)
                             (arxana-patterns--alist :name entity)))
         (details (arxana-patterns--fetch-entity-source component-id))
         (order-info (arxana-patterns--component-name-info component-name))
         (parent-id (arxana-patterns--component-parent-id component-name)))
    (when component-id
      (list :id component-id
            :name (or component-name (plist-get details :name) "component")
            :text (or (plist-get details :source) "")
            :order (plist-get order-info :order)
            :kind (plist-get order-info :kind)
            :parent-id parent-id))))

(defun arxana-patterns--compute-levels (components)
  (let ((table (make-hash-table :test 'equal)))
    (dolist (component components)
      (puthash (plist-get component :id)
               (copy-sequence component)
               table))
    (cl-labels ((level-of (component-id)
                  (let ((entry (gethash component-id table)))
                    (if (not entry)
                        0
                      (let ((existing (plist-get entry :level)))
                        (if existing
                            existing
                          (let* ((parent-id (plist-get entry :parent-id))
                                 (computed (if parent-id
                                               (1+ (level-of parent-id))
                                             0))
                                 (updated (plist-put entry :level computed)))
                            (puthash component-id updated table)
                            computed)))))))
      (mapcar (lambda (component)
                (let ((id (plist-get component :id)))
                  (level-of id)
                  (gethash id table)))
              components))))

(defun arxana-patterns--fetch-pattern-data (name)
  (arxana-patterns--ensure-sync)
  (let* ((ego-response (arxana-store-ego name arxana-patterns-ego-limit))
         (ego (and ego-response (arxana-patterns--alist :ego ego-response)))
         (entity (and ego (arxana-patterns--pattern-entity ego)))
         (pattern-id (or (and entity (arxana-patterns--alist :id entity))
                         (arxana-patterns--alist :entity/id entity)))
         (pattern-details (arxana-patterns--fetch-entity-source pattern-id))
         (summary (or (plist-get pattern-details :source) ""))
         (title (or (plist-get pattern-details :external-id) name))
         (component-links (arxana-patterns--component-links ego))
         (component-entries (delq nil (mapcar #'arxana-patterns--fetch-component
                                              component-links)))
         (leveled-components (arxana-patterns--compute-levels component-entries))
         (components (cl-sort (copy-sequence leveled-components)
                              #'< :key (lambda (comp)
                                         (or (plist-get comp :order) 0)))))
    (unless pattern-id
      (user-error "Pattern %s was not found in Futon" name))
    (list :id pattern-id
          :name name
          :title title
          :summary summary
          :components components)))

(defun arxana-patterns--insert-summary (summary)
  (insert arxana-patterns--summary-begin "\n")
  (insert (string-trim (or summary "")) "\n")
  (insert arxana-patterns--summary-end "\n\n"))

(defun arxana-patterns--insert-component (component)
  (let* ((level (max 0 (or (plist-get component :level) 0)))
         (stars (make-string (max 1 (1+ level)) ?*))
         (label (capitalize (or (plist-get component :kind) "component")))
         (name (plist-get component :name))
         (component-id (plist-get component :id))
         (text (string-trim (or (plist-get component :text) ""))))
    (insert (format "%s %s\n" stars label))
    (insert ":PROPERTIES:\n")
    (insert (format ":COMPONENT-ID: %s\n" component-id))
    (insert (format ":COMPONENT-NAME: %s\n" name))
    (insert (format ":COMPONENT-KIND: %s\n" (plist-get component :kind)))
    (insert (format ":COMPONENT-ORDER: %s\n" (or (plist-get component :order) 0)))
    (insert (format ":COMPONENT-PARENT: %s\n"
                    (or (plist-get component :parent-id) "")))
    (insert ":END:\n\n")
    (insert text "\n\n")))

(defun arxana-patterns--render-pattern (pattern)
  (let* ((name (plist-get pattern :name))
         (buffer (get-buffer-create (format "*Arxana Pattern: %s*" name))))
    (with-current-buffer buffer
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert (format "#+TITLE: Pattern %s\n" name))
        (insert (format "#+PATTERN: %s\n" name))
        (insert (format "#+PATTERN-ID: %s\n" (plist-get pattern :id)))
        (insert (format "#+PATTERN-TITLE: %s\n\n" (plist-get pattern :title)))
        (arxana-patterns--insert-summary (plist-get pattern :summary))
        (dolist (component (plist-get pattern :components))
          (arxana-patterns--insert-component component))
        (goto-char (point-min))
        (org-mode)
        (arxana-patterns-view-mode 1)
        (setq-local arxana-patterns--pattern pattern)))
    (pop-to-buffer buffer)))

;;;###autoload
(defun arxana-patterns-open (name)
  "Fetch the Futon pattern NAME and render it in an Org buffer."
  (interactive (list (read-string "Pattern name: " (thing-at-point 'symbol t))))
  (let ((pattern (arxana-patterns--fetch-pattern-data name)))
    (arxana-patterns--render-pattern pattern)))

;;;###autoload
(defun arxana-patterns-inspect-entity (name)
  "Show the Futon source text for entity NAME (pattern or component)."
  (interactive (list (read-string "Entity name: " (thing-at-point 'symbol t))))
  (arxana-patterns--ensure-sync)
  (let* ((entity (arxana-patterns--resolve-entity-by-name name))
         (component (and (not entity)
                          (or (arxana-patterns--lookup-component-by-name name)
                              (arxana-patterns--lookup-component-by-prefix name))))
         (direct-id (and (not (or entity component))
                         (arxana-patterns--fetch-entity-source name)))
         (details (cond
                    (entity
                     (let ((entity-id (or (arxana-patterns--entity-value entity :id :entity/id)
                                          (arxana-patterns--entity-value entity :ident :entity/ident))))
                       (unless entity-id
                         (user-error "Entity %s not found" name))
                       (arxana-patterns--fetch-entity-source entity-id)))
                    (component component)
                    (direct-id direct-id)
                    (t nil))))
    (unless details
      (user-error "Entity %s was not found" name))
    (let* ((text (string-trim (or (plist-get details :text)
                                  (plist-get details :summary)
                                  (plist-get details :source)
                                  "")))
           (buffer (get-buffer-create "*Arxana Pattern Snippet*")))
      (with-current-buffer buffer
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (format "Name: %s\n" (or (plist-get details :name) name)))
          (insert (format "Id: %s\n" (or (plist-get details :id) "?")))
          (when-let ((title (plist-get details :external-id)))
            (insert (format "Title: %s\n" title)))
          (when-let ((order (plist-get details :order)))
            (insert (format "Order: %s\n" order)))
          (when-let ((kind (plist-get details :kind)))
            (insert (format "Kind: %s\n" kind)))
          (insert "\n")
          (insert text)
          (goto-char (point-min))
          (view-mode 1)))
      (pop-to-buffer buffer))))

(defun arxana-patterns-refresh-buffer ()
  "Re-fetch the current pattern from Futon and replace the buffer contents."
  (interactive)
  (unless (and (boundp 'arxana-patterns--pattern)
               arxana-patterns--pattern)
    (user-error "No pattern is loaded in this buffer"))
  (arxana-patterns-open (plist-get arxana-patterns--pattern :name)))

(defun arxana-patterns--collect-components ()
  (let (results)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\*+ " nil t)
        (let ((component-id (org-entry-get (point) "COMPONENT-ID")))
          (when component-id
            (let* ((component-name (org-entry-get (point) "COMPONENT-NAME"))
                   (begin (save-excursion
                            (org-back-to-heading t)
                            (forward-line)
                            (while (looking-at "^[ \\t]*$\|^[ \\t]*:\\|^[ \\t]*#")
                              (forward-line))
                            (point)))
                   (end (save-excursion
                          (org-end-of-subtree t t)
                          (point)))
                   (text (if (and begin end)
                             (string-trim (buffer-substring-no-properties begin end))
                           "")))
              (push (list :id component-id
                          :name component-name
                          :text text)
                    results))))))
    (nreverse results)))

(defun arxana-patterns-save ()
  "Sync the current pattern buffer back to Futon.
Only existing components are updated; new headings without component ids
are ignored for now."
  (interactive)
  (arxana-patterns--ensure-sync)
  (unless (and (boundp 'arxana-patterns--pattern)
               arxana-patterns--pattern)
    (user-error "No pattern metadata found in this buffer"))
  (save-excursion
    (widen)
    (let* ((pattern-id (plist-get arxana-patterns--pattern :id))
           (pattern-name (or (plist-get arxana-patterns--pattern :name)
                             (arxana-patterns--read-header-field "PATTERN")))
           (pattern-title (arxana-patterns--read-header-field "PATTERN-TITLE"))
           (summary (arxana-patterns--extract-summary))
           (components (arxana-patterns--collect-components)))
      (arxana-store-ensure-entity :id pattern-id
                                  :name pattern-name
                                  :type "pattern/library"
                                  :source summary
                                  :external-id pattern-title)
      (dolist (component components)
        (let ((cid (plist-get component :id))
              (cname (plist-get component :name))
              (ctext (plist-get component :text)))
          (when (and cid cname)
            (arxana-store-ensure-entity :id cid
                                        :name cname
                                        :type "pattern/component"
                                        :source ctext))))
      (message "Synced %s (%d components)" pattern-name (length components)))))

(provide 'arxana-patterns)

;;; arxana-patterns.el ends here
(defcustom arxana-patterns-library-root nil
  "Path to the Futon3 pattern library checkout.
When nil the browser attempts to locate a \"futon3/library\" directory
relative to the current buffer or this file."
  :type '(choice (const :tag "Auto-detect" nil)
                 directory)
  :group 'arxana-patterns)

(defvar arxana-patterns--browser-buffer "*Arxana Pattern Browser*")
(defvar-local arxana-patterns--browser-stack nil)
(defvar-local arxana-patterns--browser-items nil)
(defconst arxana-patterns--browser-header-lines 2)

(defun arxana-patterns--locate-library-root ()
  (let ((explicit arxana-patterns-library-root))
    (cond
     ((and explicit (file-directory-p explicit)) (expand-file-name explicit))
     (t
      (let* ((current (or load-file-name buffer-file-name default-directory))
             (root (locate-dominating-file current "futon3")))
        (when root
          (let ((candidate (expand-file-name "futon3/library" root)))
            (and (file-directory-p candidate) candidate))))))))

(defun arxana-patterns--library-directories ()
  (when-let ((root (arxana-patterns--locate-library-root)))
    (seq-sort #'string<
              (seq-filter
               (lambda (entry)
                 (let ((full (expand-file-name entry root)))
                   (and (file-directory-p full)
                        (not (member entry '("." ".."))))))
               (directory-files root)))))

(defun arxana-patterns--flexiarg-file-for (library)
  (when-let ((root (arxana-patterns--locate-library-root)))
    (let ((file (expand-file-name (format "%s/%s.flexiarg" library library) root)))
      (when (file-regular-p file)
        file))))

(defun arxana-patterns--parse-flexiarg (file)
  (let ((lines (split-string (with-temp-buffer
                               (insert-file-contents file)
                               (buffer-string))
                             "\n" t))
        (current nil)
        (results nil))
    (dolist (line lines)
      (cond
       ((string-match "^@arg\\s-+\\(.+\\)$" line)
        (when current
          (push current results))
        (setq current (list :name (match-string 1 line))))
       ((and current (string-match "^@title\\s-+\\(.+\\)$" line))
        (setq current (plist-put current :title (match-string 1 line))))))
    (when current
      (push current results))
    (nreverse results)))

(defun arxana-patterns--browser-root-items ()
  (mapcar (lambda (dir)
            (list :type 'library
                  :label dir))
          (or (arxana-patterns--library-directories) '())))

(defun arxana-patterns--browser-pattern-items (library)
  (when-let ((file (arxana-patterns--flexiarg-file-for library)))
    (mapcar (lambda (entry)
              (list :type 'pattern
                    :label (plist-get entry :name)
                    :title (plist-get entry :title)))
            (arxana-patterns--parse-flexiarg file))))

(defun arxana-patterns--browser-current-items ()
  (if (not arxana-patterns--browser-stack)
      (arxana-patterns--browser-root-items)
    (arxana-patterns--browser-pattern-items (car arxana-patterns--browser-stack))))

(defun arxana-patterns--browser-render ()
  (let ((buffer (get-buffer-create arxana-patterns--browser-buffer)))
    (with-current-buffer buffer
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert (propertize (if arxana-patterns--browser-stack
                                (format "Library: %s" (car arxana-patterns--browser-stack))
                              "Pattern Libraries")
                            'face 'bold)
                "\n\n")
        (setq arxana-patterns--browser-items (arxana-patterns--browser-current-items))
        (if (seq-empty-p arxana-patterns--browser-items)
            (insert "(no entries)\n")
          (dolist (item arxana-patterns--browser-items)
            (let ((label (plist-get item :label))
                  (title (plist-get item :title))
                  (type (plist-get item :type)))
              (insert (format "%-12s %s%s\n"
                              (if (eq type 'library) "Library" "Pattern")
                              label
                              (if (and title (not (string-empty-p title)))
                                  (format " — %s" title)
                                ""))))))
        (goto-char (point-min))
        (forward-line arxana-patterns--browser-header-lines)
        (arxana-patterns-browser-mode)
        (hl-line-mode 1))
      (display-buffer buffer))))

(defun arxana-patterns--browser-item-at-point ()
  (let ((line (line-number-at-pos))
        (min-line (1+ arxana-patterns--browser-header-lines)))
    (when (>= line min-line)
      (nth (- line min-line) arxana-patterns--browser-items))))

(defun arxana-patterns--browser--move (delta)
  (let* ((line (line-number-at-pos))
         (count (length arxana-patterns--browser-items))
         (min-line (1+ arxana-patterns--browser-header-lines))
         (max-line (+ arxana-patterns--browser-header-lines count))
         (target (min max-line (max min-line (+ line delta)))))
    (goto-char (point-min))
    (forward-line (1- target))
    (hl-line-highlight)
    (when (> (count-lines (window-start) (point)) 0)
      (set-window-start (selected-window) (save-excursion
                                           (forward-line (- (window-height) 3))
                                           (point))))
    (when (>= (line-number-at-pos (window-end)) target)
      (set-window-start (selected-window) (save-excursion
                                           (goto-char (point-min))
                                           (forward-line (- target arxana-patterns--browser-header-lines 2))
                                           (point))))))

(defun arxana-patterns--browser-scroll-up (_event)
  (interactive "e")
  (arxana-patterns--browser--move -1))

(defun arxana-patterns--browser-scroll-down (_event)
  (interactive "e")
  (arxana-patterns--browser--move 1))

(defun arxana-patterns--browser-visit ()
  (interactive)
  (let ((item (arxana-patterns--browser-item-at-point)))
    (unless item
      (user-error "No entry on this line"))
    (pcase (plist-get item :type)
      ('library
       (setq arxana-patterns--browser-stack (list (plist-get item :label)))
       (arxana-patterns--browser-render))
      ('pattern
       (arxana-patterns-open (plist-get item :label))))))

(defun arxana-patterns--browser-up ()
  (interactive)
  (if (not arxana-patterns--browser-stack)
      (user-error "Already at top level")
    (setq arxana-patterns--browser-stack nil)
    (arxana-patterns--browser-render)))

(defun arxana-patterns--browser-refresh ()
  (interactive)
  (arxana-patterns--browser-render))

(defvar arxana-patterns-browser-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") #'arxana-patterns--browser-visit)
    (define-key map (kbd "n") (lambda () (interactive) (arxana-patterns--browser--move 1)))
    (define-key map (kbd "p") (lambda () (interactive) (arxana-patterns--browser--move -1)))
    (define-key map (kbd "<down>") (lambda () (interactive) (arxana-patterns--browser--move 1)))
    (define-key map (kbd "<up>") (lambda () (interactive) (arxana-patterns--browser--move -1)))
    (define-key map [wheel-down] #'arxana-patterns--browser-scroll-down)
    (define-key map [wheel-up] #'arxana-patterns--browser-scroll-up)
    (define-key map [double-wheel-down] #'arxana-patterns--browser-scroll-down)
    (define-key map [double-wheel-up] #'arxana-patterns--browser-scroll-up)
    (define-key map [triple-wheel-down] #'arxana-patterns--browser-scroll-down)
    (define-key map [triple-wheel-up] #'arxana-patterns--browser-scroll-up)
    (define-key map [mouse-5] #'arxana-patterns--browser-scroll-down)
    (define-key map [mouse-4] #'arxana-patterns--browser-scroll-up)
    (define-key map [wheel-left] #'arxana-patterns--browser-up)
    (define-key map [wheel-right] #'arxana-patterns--browser-visit)
    (define-key map (kbd "b") #'arxana-patterns--browser-up)
    (define-key map (kbd "g") #'arxana-patterns--browser-refresh)
    (define-key map (kbd "q") #'quit-window)
    map))

(define-derived-mode arxana-patterns-browser-mode special-mode "Pattern-Browse"
  "Mode for browsing Futon pattern libraries."
  (local-set-key (kbd "<wheel-up>") #'previous-line)
  (local-set-key (kbd "<wheel-down>") #'next-line)
  (local-set-key (kbd "<mouse-4>") #'previous-line)
  (local-set-key (kbd "<mouse-5>") #'next-line)
  (local-set-key (kbd "<double-wheel-up>") #'previous-line)
  (local-set-key (kbd "<double-wheel-down>") #'next-line)
  (local-set-key (kbd "<triple-wheel-up>") #'previous-line)
  (local-set-key (kbd "<triple-wheel-down>") #'next-line)
  (local-set-key (kbd "<wheel-left>") #'arxana-patterns--browser-up)
  (local-set-key (kbd "<wheel-right>") #'arxana-patterns--browser-visit))

;;;###autoload
(defun arxana-patterns-browse ()
  "Open the pattern library browser buffer."
  (interactive)
  (setq arxana-patterns--browser-stack nil)
  (arxana-patterns--browser-render))
#+END_SRC

** Importing pattern libraries

Pattern data usually starts in the flexiarg collections from Futon3.  The ingest shim converts every `.flexiarg` entry into Futon entities, links them to pattern languages, and registers each language inside the shared catalog so `/ego` lookups stay consistent.

- `M-x arxana-patterns-list-languages` lists languages plus the number of linked patterns.
- `M-x arxana-patterns-ingest-directory` ingests an entire directory and optionally wires the results into a named language.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-patterns-ingest.el
;;; arxana-patterns-ingest.el --- Import flexiarg pattern libraries -*- lexical-binding: t; -*-

;;; Commentary:
;; Read pattern `.flexiarg` files from a directory, convert each entry
;; into Futon pattern/component entities, and wire them together using
;; `:pattern/includes` relations.  An optional pattern-language entity
;; can also be created so callers can browse the ordered collection via
;; Futon's `/ego` endpoint.

;;; Code:

(require 'cl-lib)
(require 'seq)
(require 'subr-x)

(require 'arxana-store)

(defgroup arxana-patterns-ingest nil
  "Settings for ingesting flexiarg pattern libraries."
  :group 'arxana)

(defcustom arxana-patterns-ingest-ego-limit 128
  "How many links to request when fetching `/ego` data during ingest."
  :type 'integer
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-relation ":pattern-language/includes"
  "Relation label used when wiring languages to their member patterns."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-source-relation ":language/source"
  "Relation label used when tagging pattern languages with their source."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-status-relation ":language/status"
  "Relation label used when tagging pattern languages with their status."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-catalog-name "pattern-language/catalog"
  "Entity name that collects every known pattern language."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-language-catalog-relation ":language/catalog"
  "Relation label used when linking languages into the catalog."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-default-ad-hoc-status "pattern-language/status/draft"
  "Default status entity name for ad-hoc pattern languages."
  :type 'string
  :group 'arxana-patterns-ingest)

(defcustom arxana-patterns-ingest-default-canonical-status "pattern-language/status/published"
  "Default status entity name for canonical pattern languages (futon3/library)."
  :type 'string
  :group 'arxana-patterns-ingest)

(defun arxana-patterns-ingest--flexiarg-files (directory)
  "Return absolute `.flexiarg` paths under DIRECTORY sorted by mtime (desc)."
  (let* ((dir (file-name-as-directory (expand-file-name directory)))
         (candidates (directory-files dir t "\\.flexiarg\\'" t)))
    (seq-sort (lambda (a b)
                (let ((ta (nth 5 (file-attributes a 'string)))
                      (tb (nth 5 (file-attributes b 'string))))
                  (time-less-p tb ta)))
              candidates)))

(defun arxana-patterns-ingest--canonical-directory-p (directory)
  "Return non-nil when DIRECTORY appears to live under futon3/library."
  (let ((path (file-name-as-directory (expand-file-name directory))))
    (string-match-p (regexp-quote "/futon3/library/") path)))

(defun arxana-patterns-ingest--language-source-name (directory)
  "Return the classification entity name for DIRECTORY's source."
  (if (arxana-patterns-ingest--canonical-directory-p directory)
      "pattern-language/source/futon3-library"
    "pattern-language/source/ad-hoc"))

(defun arxana-patterns-ingest--language-status-name (directory explicit)
  "Return the classification entity for language status.
When EXPLICIT is non-nil, return it; otherwise derive from DIRECTORY."
  (cond
   ((and explicit (not (string-empty-p explicit))) explicit)
   ((arxana-patterns-ingest--canonical-directory-p directory)
    arxana-patterns-ingest-default-canonical-status)
   (t arxana-patterns-ingest-default-ad-hoc-status)))

(defun arxana-patterns-ingest--trim-empty-lines (lines)
  "Remove blank lines from the start/end of LINES."
  (let ((result lines))
    (while (and result (string-match-p "\\`[[:space:]]*\\'" (car result)))
      (setq result (cdr result)))
    (let ((rev (nreverse result)))
      (while (and rev (string-match-p "\\`[[:space:]]*\\'" (car rev)))
        (setq rev (cdr rev)))
      (nreverse rev))))

(defun arxana-patterns-ingest--slugify (text)
  "Return a lowercase slug derived from TEXT."
  (let* ((lower (downcase (or text "component")))
         (clean (replace-regexp-in-string "[^a-z0-9]+" "-" lower))
         (trimmed (string-trim clean "-" "-")))
    (if (string-empty-p trimmed)
        "component"
      trimmed)))

(defun arxana-patterns-ingest--extract-id (node)
  "Recursively locate an :id/:entity/id entry inside NODE."
  (cond
   ((null node) nil)
   ((and (consp node) (keywordp (car node))
         (memq (car node) '(:id :entity/id)))
    (cdr node))
   ((consp node)
    (or (arxana-patterns-ingest--extract-id (car node))
        (arxana-patterns-ingest--extract-id (cdr node))))
   (t nil)))

(defun arxana-patterns-ingest--lookup-id (name)
  "Fetch NAME via `/ego` and return the associated entity id."
  (when name
    (let* ((response (ignore-errors (arxana-store-ego name 1)))
           (ego (and response (alist-get :ego response)))
           (entity (and ego (alist-get :entity ego))))
      (arxana-patterns-ingest--extract-id entity))))

(defun arxana-patterns-ingest--relation-text (value)
  (let ((raw (cond
              ((keywordp value) (symbol-name value))
              ((symbolp value) (symbol-name value))
              ((stringp value) value)
              (t nil))))
    (when raw
      (if (and (> (length raw) 0) (eq (aref raw 0) ?:))
          (substring raw 1)
        raw))))

(defun arxana-patterns-ingest--relation-match-p (value target)
  "Return non-nil when VALUE and TARGET represent the same relation label."
  (let ((lhs (arxana-patterns-ingest--relation-text value))
        (rhs (arxana-patterns-ingest--relation-text target)))
    (and lhs rhs (string= lhs rhs))))

(defun arxana-patterns-ingest--existing-targets (name relation)
  "Return a hash table of entity ids linked from NAME via RELATION."
  (let* ((response (ignore-errors (arxana-store-ego name arxana-patterns-ingest-ego-limit)))
         (ego (and response (alist-get :ego response)))
         (links (and ego (or (alist-get :outgoing ego)
                             (let ((l (alist-get :links ego)))
                               (and l (alist-get :outgoing l))))))
         (table (make-hash-table :test 'equal)))
    (dolist (link links)
      (when (arxana-patterns-ingest--relation-match-p (alist-get :relation link) relation)
        (let* ((entity (alist-get :entity link))
               (id (arxana-patterns-ingest--extract-id entity)))
          (when id
            (puthash id t table)))))
    table))

(defun arxana-patterns-ingest--ensure-tag (language-name language-id relation target-name target-type)
  "Ensure LANGUAGE-ID points at TARGET-NAME via RELATION."
  (when (and language-name language-id relation target-name)
    (let* ((target-response (arxana-store-ensure-entity :name target-name
                                                        :type target-type
                                                        :source (format "%s classification" relation)
                                                        :external-id target-name))
           (target-id (or (arxana-patterns-ingest--extract-id target-response)
                          (arxana-patterns-ingest--lookup-id target-name)))
           (existing (arxana-patterns-ingest--existing-targets language-name relation)))
      (when (and target-id (not (gethash target-id existing)))
        (arxana-store-create-relation :src language-id
                                      :dst target-id
                                      :label relation)
        (puthash target-id t existing)))))

(defun arxana-patterns-ingest--ensure-catalog-link (language-name language-id)
  "Ensure LANGUAGE-ID is reachable from the central catalog."
  (when (and language-name language-id)
    (let* ((catalog-name arxana-patterns-ingest-language-catalog-name)
           (response (arxana-store-ensure-entity :name catalog-name
                                                 :type "pattern/language-catalog"
                                                 :source "Pattern languages"))
           (catalog-id (or (arxana-patterns-ingest--extract-id response)
                           (arxana-patterns-ingest--lookup-id catalog-name)))
           (existing (when catalog-id
                       (arxana-patterns-ingest--existing-targets
                        catalog-name arxana-patterns-ingest-language-catalog-relation))))
      (when (and catalog-id existing (not (gethash language-id existing)))
        (arxana-store-create-relation :src catalog-id
                                      :dst language-id
                                      :label arxana-patterns-ingest-language-catalog-relation)
        (puthash language-id t existing)))))

(defun arxana-patterns-ingest--ego-outgoing (ego)
  (or (alist-get :outgoing ego)
      (let ((links (alist-get :links ego)))
        (and links (alist-get :outgoing links)))))

(defun arxana-patterns-ingest--link-target-name (link)
  (let* ((entity (alist-get :entity link)))
    (or (alist-get :name entity)
        (alist-get :entity/name entity)
        (alist-get :ident entity)
        (alist-get :entity/ident entity))))

(defun arxana-patterns-ingest--language-metadata (language-name)
  "Return plist of metadata for LANGUAGE-NAME using `/ego`."
  (let* ((response (ignore-errors (arxana-store-ego language-name arxana-patterns-ingest-ego-limit)))
         (ego (and response (alist-get :ego response)))
         (entity (and ego (alist-get :entity ego)))
         (title (or (alist-get :external-id entity)
                    (alist-get :entity/external-id entity)
                    language-name))
         (outgoing (arxana-patterns-ingest--ego-outgoing ego))
         (source nil)
         (status nil)
         (count 0))
    (dolist (link outgoing)
      (let ((rel (alist-get :relation link)))
        (cond
         ((arxana-patterns-ingest--relation-match-p rel arxana-patterns-ingest-language-relation)
          (setq count (1+ count)))
         ((and (not source)
               (arxana-patterns-ingest--relation-match-p rel arxana-patterns-ingest-language-source-relation))
          (setq source (arxana-patterns-ingest--link-target-name link)))
         ((and (not status)
               (arxana-patterns-ingest--relation-match-p rel arxana-patterns-ingest-language-status-relation))
          (setq status (arxana-patterns-ingest--link-target-name link))))))
    (list :name language-name
          :title title
          :source source
          :status status
          :count count)))

;;;###autoload
(defun arxana-patterns-list-languages ()
  "Display a summary of known pattern languages and their status."
  (interactive)
  (unless (arxana-store-sync-enabled-p)
    (user-error "Futon sync is disabled; enable futon4-enable-sync first"))
  (let* ((catalog arxana-patterns-ingest-language-catalog-name)
         (response (ignore-errors (arxana-store-ego catalog arxana-patterns-ingest-ego-limit)))
         (ego (and response (alist-get :ego response)))
         (outgoing (and ego (arxana-patterns-ingest--ego-outgoing ego)))
         (language-names (delq nil
                               (mapcar (lambda (link)
                                         (when (arxana-patterns-ingest--relation-match-p
                                                (alist-get :relation link)
                                                arxana-patterns-ingest-language-catalog-relation)
                                           (arxana-patterns-ingest--link-target-name link)))
                                       outgoing))))
    (if (seq-empty-p language-names)
        (message "No pattern languages are registered yet")
      (let* ((rows (mapcar #'arxana-patterns-ingest--language-metadata language-names))
             (buffer (get-buffer-create "*Arxana Pattern Languages*")))
        (with-current-buffer buffer
          (let ((inhibit-read-only t))
            (erase-buffer)
            (insert (format "%-32s %-24s %-24s %s\n"
                            "Language" "Source" "Status" "Patterns"))
            (insert (make-string 90 ?-) "\n")
            (dolist (row rows)
              (insert (format "%-32s %-24s %-24s %d\n"
                              (plist-get row :name)
                              (or (plist-get row :source) "?")
                              (or (plist-get row :status) "?")
                              (plist-get row :count))))
            (goto-char (point-min))
            (special-mode)))
        (display-buffer buffer)))))

(defun arxana-patterns-ingest--section (label lines)
  (let* ((clean-lines (arxana-patterns-ingest--trim-empty-lines (nreverse lines)))
         (text (string-trim-right (mapconcat #'identity clean-lines "\n"))))
    (list :label label
          :slug (arxana-patterns-ingest--slugify label)
          :text text)))

(defun arxana-patterns-ingest--parse-flexiarg (path)
  "Parse PATH and return a plist describing the pattern contents."
  (with-temp-buffer
    (insert-file-contents path)
    (goto-char (point-min))
    (let ((meta nil)
          (sections nil)
          (current nil))
      (while (not (eobp))
        (let ((line (buffer-substring-no-properties (line-beginning-position)
                                                    (line-end-position))))
          (cond
           ((string-match "^@\\([^[:space:]]+\\)\\s-+\\(.*\\)$" line)
            (let ((key (intern (concat ":" (downcase (match-string 1 line)))))
                  (value (string-trim (match-string 2 line))))
              (setq meta (plist-put meta key value))))
           ((string-match "^[[:space:]]*\([!+]\)\\s-*\\([^:]+\\):?\\s*$" line)
            (when current
              (push (arxana-patterns-ingest--section (plist-get current :label)
                                                     (plist-get current :lines))
                    sections))
            (setq current (list :label (string-trim (match-string 2 line))
                                :lines nil)))
           ((and current)
            (setf (plist-get current :lines)
                  (cons line (plist-get current :lines))))))
        (forward-line 1))
      (when current
        (push (arxana-patterns-ingest--section (plist-get current :label)
                                               (plist-get current :lines))
              sections))
      (let ((name (plist-get meta :arg)))
        (unless (and name (not (string-empty-p name)))
          (user-error "Missing @arg in %s" path))
        (let* ((title (plist-get meta :title))
               (ordered (nreverse sections))
               (first (car ordered)))
          (list :name name
                :title title
                :summary (or (plist-get first :text) "")
                :components ordered
                :meta meta))))))

(defun arxana-patterns-ingest--component-name (pattern index component)
  (format "%s/%02d-%s" pattern index (plist-get component :slug)))

(defun arxana-patterns-ingest--ensure-pattern (pattern)
  (let* ((response (arxana-store-ensure-entity :name (plist-get pattern :name)
                                               :type "pattern/library"
                                               :source (plist-get pattern :summary)
                                               :external-id (plist-get pattern :title)))
         (id (or (arxana-patterns-ingest--extract-id response)
                 (arxana-patterns-ingest--lookup-id (plist-get pattern :name)))))
    id))

(defun arxana-patterns-ingest--ensure-component (pattern-id pattern-name component index existing)
  (let* ((component-name (arxana-patterns-ingest--component-name pattern-name index component))
         (response (arxana-store-ensure-entity :name component-name
                                               :type "pattern/component"
                                               :source (plist-get component :text)
                                               :external-id (plist-get component :label)))
         (component-id (or (arxana-patterns-ingest--extract-id response)
                           (arxana-patterns-ingest--lookup-id component-name))))
    (when (and pattern-id component-id
               (or (not existing) (not (gethash component-id existing))))
      (arxana-store-create-relation :src pattern-id
                                    :dst component-id
                                    :label ":pattern/includes")
      (when existing
        (puthash component-id t existing)))
    component-id))

(defun arxana-patterns-ingest--ingest-file (path)
  "Ingest a single flexiarg PATH, returning plist with :name and :id."
  (let* ((data (arxana-patterns-ingest--parse-flexiarg path))
         (pattern-id (arxana-patterns-ingest--ensure-pattern data))
         (existing (arxana-patterns-ingest--existing-targets (plist-get data :name)
                                                             ":pattern/includes"))
         (index 1))
    (dolist (component (plist-get data :components))
      (arxana-patterns-ingest--ensure-component pattern-id (plist-get data :name)
                                                component index existing)
      (setq index (1+ index)))
    (list :name (plist-get data :name)
          :id pattern-id)))

(defun arxana-patterns-ingest--ensure-language (language-name language-title patterns directory language-status)
  "Ensure LANGUAGE-NAME exists and links to PATTERNS in order."
  (let* ((summary (format "Imported from %s" directory))
         (response (arxana-store-ensure-entity :name language-name
                                              :type "pattern/language"
                                              :source summary
               :external-id (or language-title language-name)))
         (language-id (or (arxana-patterns-ingest--extract-id response)
                          (arxana-patterns-ingest--lookup-id language-name)))
         (existing (when language-id
                     (or (arxana-patterns-ingest--existing-targets
                          language-name arxana-patterns-ingest-language-relation)
                         (make-hash-table :test 'equal))))
         (source-name (arxana-patterns-ingest--language-source-name directory))
         (status-name (arxana-patterns-ingest--language-status-name directory language-status)))
    (when (and language-id existing)
      (cl-loop for pattern in patterns
               for order from 1
               for pid = (plist-get pattern :id)
               when (and pid (not (gethash pid existing)))
               do (progn
                    (arxana-store-create-relation :src language-id
                                                  :dst pid
                                                  :label arxana-patterns-ingest-language-relation
                                                  :props (list (cons 'order order)))
                    (puthash pid t existing))))
      (arxana-patterns-ingest--ensure-tag language-name language-id
                                          arxana-patterns-ingest-language-source-relation
                                          source-name "pattern/language-source")
      (arxana-patterns-ingest--ensure-tag language-name language-id
                                          arxana-patterns-ingest-language-status-relation
                                          status-name "pattern/language-status")
      (arxana-patterns-ingest--ensure-catalog-link language-name language-id)))

;;;###autoload
(defun arxana-patterns-ingest-directory (directory &optional language-name language-title language-status)
  "Ingest `.flexiarg` files under DIRECTORY.
When LANGUAGE-NAME is non-nil, ensure a pattern-language entity links to
all imported patterns using reverse modification time order. LANGUAGE-TITLE
becomes the entity's external id. LANGUAGE-STATUS lets callers override the
auto-detected status classification."
  (interactive
   (let* ((dir (read-directory-name "Flexiarg directory: " nil nil t))
          (raw-name (string-trim (read-string "Pattern language name (blank to skip): ")))
          (name (unless (string-empty-p raw-name) raw-name))
          (title (when name
                   (let ((val (string-trim (read-string "Pattern language title (optional): "))))
                     (unless (string-empty-p val) val))))
          (status (when name
                    (let* ((default (arxana-patterns-ingest--language-status-name dir nil))
                           (prompt (format "Pattern language status (default %s): " default))
                           (val (string-trim (read-string prompt nil nil default))))
                      (unless (string-empty-p val) val)))))
     (list dir name title status)))
  (unless (arxana-store-sync-enabled-p)
    (user-error "Futon sync is disabled; enable futon4-enable-sync first"))
  (let* ((dir directory)
         (files (arxana-patterns-ingest--flexiarg-files dir)))
    (unless files
      (user-error "No .flexiarg files found in %s" dir))
    (let ((results nil))
      (dolist (file files)
        (push (arxana-patterns-ingest--ingest-file file) results))
      (setq results (nreverse results))
      (when language-name
        (arxana-patterns-ingest--ensure-language language-name language-title
                                                 results dir language-status))
      (message "Ingested %d patterns from %s" (length results) dir)
      (when language-name
        (message "Language %s id %s" language-name
                 (or (arxana-patterns-ingest--extract-id
                      (arxana-store-ensure-entity :name language-name))
                     (arxana-patterns-ingest--lookup-id language-name))))
      results)))

(provide 'arxana-patterns-ingest)

;;; arxana-patterns-ingest.el ends here
#+END_SRC

* Browsing & relations

** Catalog & label menus

The Part VI menus still work via modern commands:

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-browse.el
;;; arxana-browse.el --- Part VI browsing helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Convenience wrappers that expose the legacy Part VI browsing flows via
;; modern `arxana-*' commands. Contributors can continue to use catalog and
;; label menus without memorising the old entry points.

;;; Code:

(require 'cl-lib)
(require 'subr-x)

(defgroup arxana-browse nil
  "Part VI browsing entry points."
  :group 'arxana)

(declare-function article-menu-listing "arxana-tangled" (&optional subset accessors))
(declare-function article-menu-list-all-articles "arxana-tangled" () t)
(declare-function article-menu-list-labels "arxana-tangled" () t)

(defun arxana-browse--ensure (fn)
  "Signal a user error unless FN is bound."
  (unless (fboundp fn)
    (user-error "Browsing helpers are unavailable; run `arxana-build' first"))
  fn)

;;;###autoload
(defun arxana-browse-open-catalog (&optional include-all)
  "Open the article catalog. With INCLUDE-ALL, show every article."
  (interactive "P")
  (if include-all
      (progn
        (arxana-browse--ensure 'article-menu-list-all-articles)
        (article-menu-list-all-articles))
    (progn
      (arxana-browse--ensure 'article-menu-listing)
      (article-menu-listing))))

;;;###autoload
(defun arxana-browse-open-labels ()
  "List label articles in the catalog menu."
  (interactive)
  (arxana-browse--ensure 'article-menu-list-labels)
  (article-menu-list-labels))
#+END_SRC

** Link-following & history

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-browse.el
(declare-function follow-reference-or-scholium "arxana-tangled" () t)
(declare-function display-an-article-that-current-article-is-about "arxana-tangled" () t)
(declare-function display-an-article-that-current-scholium-is-about "arxana-tangled" () t)
(declare-function sb-back "arxana-tangled" () t)
(declare-function sb-forward "arxana-tangled" () t)

;;;###autoload
(defun arxana-browse-follow-link ()
  "Follow the scholium or reference at point."
  (interactive)
  (arxana-browse--ensure 'follow-reference-or-scholium)
  (follow-reference-or-scholium))

;;;###autoload
(defun arxana-browse-follow-article-about ()
  "Jump to an article referenced by the current article."
  (interactive)
  (arxana-browse--ensure 'display-an-article-that-current-article-is-about)
  (display-an-article-that-current-article-is-about))

;;;###autoload
(defun arxana-browse-follow-scholium-about ()
  "Jump to an article referenced by the current scholium."
  (interactive)
  (arxana-browse--ensure 'display-an-article-that-current-scholium-is-about)
  (display-an-article-that-current-scholium-is-about))

;;;###autoload
(defun arxana-browse-history-back ()
  "Move to the previous article in the temporal browsing history."
  (interactive)
  (arxana-browse--ensure 'sb-back)
  (sb-back))

;;;###autoload
(defun arxana-browse-history-forward ()
  "Move to the next article in the temporal browsing history."
  (interactive)
  (arxana-browse--ensure 'sb-forward)
  (sb-forward))
#+END_SRC

** Relation buffers in context

- `M-x arxana-relations-show-ego` / `cooccur` / `tail` render Futon adjacency directly in Emacs buffers with refresh/provenance/copy bindings.
- The new literate blocks describe the buffer minor mode, formatting helpers, renderers, and commands.

** Relation buffers in context

The relation helpers render Futon adjacency inside Emacs so we no longer
need to shell out to curl. Each buffer is a minor mode with refresh,
provenance, and copy-id bindings.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-relations.el
;;; arxana-relations.el --- Relation browsing helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Interactive commands that render Futon relation data (/ego, /cooccur, /tail)
;; inside Emacs so users no longer need to shell out to curl.

;;; Code:

(require 'cl-lib)
(require 'seq)
(require 'subr-x)
(require 'arxana-store)

(declare-function futon4-lookup-article-id "arxana-tangled" (name))
(declare-function futon4--article-id-for "arxana-tangled" (name &optional path))

(defgroup arxana-relations nil
  "Buffers for browsing Futon relation data."
  :group 'arxana)

(defconst arxana-relations-buffer-name "*Arxana Relations*")

(defvar-local arxana-relations-context nil
  "Plist describing the last Futon render in this buffer.")

(defvar arxana-relations-buffer-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "g") #'arxana-relations-refresh)
    (define-key map (kbd "p") #'arxana-relations-provenance)
    (define-key map (kbd "y") #'arxana-relations-copy-id)
    map)
  "Keymap for `arxana-relations-buffer-mode'.")

(define-minor-mode arxana-relations-buffer-mode
  "Minor mode that adds refresh/provenance commands to relation buffers."
  :lighter " ArxRel"
  :keymap arxana-relations-buffer-mode-map
  (if arxana-relations-buffer-mode
      (setq-local revert-buffer-function #'arxana-relations--revert-buffer)
    (kill-local-variable 'revert-buffer-function)))
#+END_SRC

** Formatting helpers

Before we render anything we normalize type labels, build friendly names,
and provide helpers for inserting sections into the buffer.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-relations.el
(defun arxana-relations--type-label (type)
  (cond
   ((keywordp type) (substring (symbol-name type) 1))
   ((symbolp type) (symbol-name type))
   ((stringp type) type)
   (t (format "%s" type))))

(defun arxana-relations--name-with-type (name type)
  (if (and name type)
      (format "%s (%s)" name (arxana-relations--type-label type))
    (or name "?")))

(defun arxana-relations--entity-name (entity)
  (or (alist-get :entity/name entity)
      (alist-get :name entity)))

(defun arxana-relations--entity-type (entity)
  (or (alist-get :entity/type entity)
      (alist-get :type entity)))

(defun arxana-relations--insert-line (fmt &rest args)
  (insert (apply #'format (concat fmt "\n") args)))

(defun arxana-relations--insert-section (title lines)
  (arxana-relations--insert-line "%s" title)
  (if (seq-empty-p lines)
      (arxana-relations--insert-line "  (none)")
    (dolist (line lines)
      (arxana-relations--insert-line "  - %s" line))))
#+END_SRC

** Rendering Futon responses

Each renderer translates a Futon response (`/ego`, `/cooccur`, `/tail`) into a
human-readable set of lines.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-relations.el
(defun arxana-relations--render-ego (body)
  ;; ... body of function ...
  )

(defun arxana-relations--render-cooccur (body)
  ;; ... body of function ...
  )

(defun arxana-relations--render-tail (body)
  ;; ... body of function ...
  )

(defun arxana-relations--render-fallback (body)
  (arxana-relations--insert-line "Raw response:")
  (pp body (current-buffer)))
#+END_SRC

** Commands & context

Finally we wire up interactive commands (`arxana-relations-show-ego`, etc.),
store the last Futon context, and expose refresh/provenance/copy-id helpers.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-relations.el
;; ... remaining functions from dev/arxana-relations.el ...

(provide 'arxana-relations)

;;; arxana-relations.el ends here
#+END_SRC

** Legacy navigation commands

#+INCLUDE: "dev/arxana-browse.el" src emacs-lisp

** XTDB browsing shims

The XTDB browser exposes `/tail` data via a tabulated list and lets contributors
inspect source/target entities, jump into relation buffers, or tweak the limit.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-xtdb-browse.el
;;; arxana-xtdb-browse.el --- XTDB browser for Futon datasets -*- lexical-binding: t; -*-

;;; Commentary:
;; Provides an Emacs UI for peeking into Futon/XTDB data.  Uses `/tail`
;; to list recent relations and lets users drill into entities or
;; open the existing relation buffers.

;;; Code:

(require 'seq)
(require 'tabulated-list)
(require 'subr-x)
(require 'arxana-store)
(require 'arxana-relations)

(defgroup arxana-xtdb-browse nil
  "Interactive browser for Futon/XTDB contents."
  :group 'arxana)

(defcustom arxana-xtdb-browse-default-limit 25
  "Number of relations to request when browsing XTDB."
  :type 'integer
  :group 'arxana-xtdb-browse)

(defvar arxana-xtdb-browse-buffer "*Arxana XTDB Browser*")
(defvar-local arxana-xtdb--current-limit arxana-xtdb-browse-default-limit)
(defvar-local arxana-xtdb--tail-response nil)
#+END_SRC

** XTDB helpers

Normalize Futon rows into tabulated entries and provide entity inspectors.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-xtdb-browse.el
(defun arxana-xtdb--entity-name (entity)
  (or (alist-get :name entity)
      (alist-get :entity/name entity)
      "<unknown>"))

(defun arxana-xtdb--entity-type (entity)
  (or (alist-get :type entity)
      (alist-get :entity/type entity)))

(defun arxana-xtdb--entity-ident (entity)
  (or (alist-get :ident entity)
      (alist-get :entity/id entity)))

(defun arxana-xtdb--entity-label (entity)
  (let ((name (arxana-xtdb--entity-name entity))
        (type (arxana-xtdb--entity-type entity)))
    (if type
        (format "%s (%s)" name type)
      name)))

(defun arxana-xtdb--relation-row-p (row)
  (and (listp row)
       (consp (car row))
       (or (alist-get :src row)
           (alist-get :dst row))))

(defun arxana-xtdb--tail-rows (body)
  "Normalize BODY (from `/tail`) into a list of relation alists."
  (let* ((section (or (alist-get :tail body)
                      body))
         (raw (or (alist-get :relations section)
                  (alist-get :links section)
                  (alist-get :items section)
                  section)))
    (when (not (listp raw))
      (setq raw nil))
    (seq-filter #'arxana-xtdb--relation-row-p raw)))

(defun arxana-xtdb--rows->entries (rows)
  "Return tabulated-list entries derived from ROWS."
  (let ((index 0))
    (mapcar
     (lambda (row)
       (setq index (1+ index))
       (let* ((src (alist-get :src row))
              (dst (alist-get :dst row))
              (relation (alist-get :type row))
              (last-seen (or (alist-get :last-seen row)
                             (alist-get :hx/last-seen row)
                             ""))
              (vector (vector (format "%s" last-seen)
                              (format "%s" relation)
                              (arxana-xtdb--entity-label src)
                              (arxana-xtdb--entity-label dst))))
         (list index vector row)))
     rows)))

(defun arxana-xtdb--describe-entity (entity)
  "Display ENTITY data using `arxana-store-fetch-entity'."
  (let* ((ident (arxana-xtdb--entity-ident entity))
         (name (arxana-xtdb--entity-name entity)))
    (unless ident
      (user-error "No Futon id recorded for %s" name))
    (let ((data (arxana-store-fetch-entity ident)))
      (unless data
        (user-error "No Futon data for %s" name))
      (with-current-buffer (get-buffer-create "*Arxana Entity*")
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (format "Entity: %s\nId: %s\n\n" name ident))
          (pp data (current-buffer))
          (goto-char (point-min))
          (view-mode 1))
        (display-buffer (current-buffer))))))
#+END_SRC

** Tabulated UI & commands

The major mode uses `tabulated-list-mode` with shortcuts for refreshing,
changing limits, inspecting raw payloads, and opening relation buffers.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-xtdb-browse.el
(defun arxana-xtdb-refresh (&optional limit)
  "Refresh the XTDB browser contents with LIMIT rows."
  (interactive)
  (let* ((limit (or limit arxana-xtdb--current-limit))
         (body (arxana-store-tail limit)))
    (setq arxana-xtdb--current-limit limit
          arxana-xtdb--tail-response body)
    (let ((rows (arxana-xtdb--tail-rows (or body '()))))
      (if rows
          (progn
            (setq tabulated-list-entries (arxana-xtdb--rows->entries rows))
            (tabulated-list-print t)
            (message "Fetched %d relations" (length rows)))
        (setq tabulated-list-entries nil)
        (tabulated-list-print t)
        (message "No relations returned from Futon")))))

(defun arxana-xtdb-browse-change-limit (limit)
  "Set a new LIMIT for `/tail` results and refresh."
  (interactive (list (read-number "Tail limit: " arxana-xtdb--current-limit)))
  (arxana-xtdb-refresh limit))

(defun arxana-xtdb-browse-inspect-raw ()
  "Display the raw `/tail` payload for debugging."
  (interactive)
  (unless arxana-xtdb--tail-response
    (user-error "No XTDB payload captured yet"))
  (with-current-buffer (get-buffer-create "*Arxana XTDB Raw*")
    (let ((inhibit-read-only t))
      (erase-buffer)
      (pp arxana-xtdb--tail-response (current-buffer))
      (goto-char (point-min))
      (view-mode 1))
    (display-buffer (current-buffer))))

(defvar arxana-xtdb-browse-mode-map
  (let ((map (copy-keymap tabulated-list-mode-map)))
    (define-key map (kbd "g") #'arxana-xtdb-refresh)
    (define-key map (kbd "l") #'arxana-xtdb-browse-change-limit)
    (define-key map (kbd "RET") #'arxana-xtdb-browse-show-ego)
    (define-key map (kbd "s") #'arxana-xtdb-browse-open-source)
    (define-key map (kbd "t") #'arxana-xtdb-browse-open-target)
    (define-key map (kbd "R") #'arxana-xtdb-browse-inspect-raw)
    map)
  "Keymap for `arxana-xtdb-browse-mode'.")

(define-derived-mode arxana-xtdb-browse-mode tabulated-list-mode "XTDB"
  "Major mode for browsing Futon/XTDB relations."
  (setq tabulated-list-format [("Seen" 18 t)
                               ("Relation" 18 t)
                               ("Source" 25 t)
                               ("Target" 25 t)]
        tabulated-list-padding 2
        tabulated-list-sort-key (cons "Seen" nil))
  (tabulated-list-init-header))

;;;###autoload
(defun arxana-xtdb-browse (&optional limit)
  "List recent Futon relations using a tabulated UI.
When LIMIT is provided (or via prefix), request that many rows."
  (interactive (list (when current-prefix-arg
                       (read-number "Tail limit: " arxana-xtdb-browse-default-limit))))
  (let ((buffer (get-buffer-create arxana-xtdb-browse-buffer)))
    (with-current-buffer buffer
      (arxana-xtdb-browse-mode)
      (arxana-xtdb-refresh limit))
    (pop-to-buffer buffer)))

(provide 'arxana-xtdb-browse)

;;; arxana-xtdb-browse.el ends here
#+END_SRC

* Org imports / exports & snapshots

- `M-x arxana-import-org-file` derives an article name from `#+TITLE` (or the filename), stores the text as a scholium, and mirrors it into XTDB.
- `M-x arxana-import-org-directory` walks a tree of `.org` files (`C-u` to recurse) and feeds each file through the importer.
- `M-x arxana-export-org-directory` writes every loaded article back to disk and produces a manifest with snapshot metadata, inclusion/transclusion summaries, and a label index. With sync enabled the command first captures a Futon snapshot so the export is tied to a specific XTDB revision.
- `C-; r` / `M-x save-all-scholia` hit `/snapshot` when sync is enabled (falling back to the `.sch` writer when offline). `M-x read-scholia-file` mirrors the behavior for restore.
- Migration recipe: 1) snapshot the legacy collection, 2) run `arxana-import-org-directory`, 3) edit in Emacs, 4) export and capture the new manifest for diffable releases.

** Single-file importer

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-import.el
;;; arxana-import.el --- Org → XTDB import helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Utility functions that read Org files/directories and push their
;; contents into Arxana's article graph (and, via the existing store
;; hooks, into XTDB).

;;; Code:

(require 'cl-lib)
(require 'subr-x)

(declare-function scholium "arxana-tangled" (name text &optional about type book))
(declare-function sch-book "arxana-tangled" () nil)
(declare-function arxana-store-ensure-article "arxana-store" (&rest _))
(declare-function futon4--canonical-path "arxana-tangled" (path))

(defun arxana-import--read-file-contents (path)
  "Return the contents of PATH as a string."
  (with-temp-buffer
    (insert-file-contents path)
    (buffer-string)))

(defun arxana-import--org-title-from-string (text)
  "Extract a #+TITLE from TEXT when present."
  (with-temp-buffer
    (insert text)
    (goto-char (point-min))
    (let ((case-fold-search t))
      (when (re-search-forward "^#\\+TITLE:[[:space:]]*" nil t)
        (let ((start (point)))
          (end-of-line)
          (string-trim (buffer-substring-no-properties start (point))))))))

(defun arxana-import--derive-name (path text)
  "Pick a reasonable article name from PATH and TEXT."
  (or (arxana-import--org-title-from-string text)
      (file-name-base path)
      (file-name-nondirectory path)))

(defun arxana-import--canonical-path (path)
  (if (fboundp 'futon4--canonical-path)
      (futon4--canonical-path path)
    path))

(defun arxana-import-org-file (path)
  "Import the Org file at PATH into the Arxana article table."
  (interactive "fOrg file: ")
  (let* ((text (arxana-import--read-file-contents path))
         (name (arxana-import--derive-name path text)))
    (when (string-empty-p (or name ""))
      (error "Could not derive article name from %s" path))
    (scholium name text nil '(org) (sch-book))
    (when (fboundp 'arxana-store-ensure-article)
      (arxana-store-ensure-article :name name :path (arxana-import--canonical-path path)))
    (message "Imported %s" name)
    name))
#+END_SRC

** Directory importer

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-import.el
(defun arxana-import--org-files-recursively (directory)
  "Return Org files under DIRECTORY recursively."
  (let ((results nil))
    (dolist (entry (directory-files directory t directory-files-no-dot-files-regexp))
      (cond
       ((file-directory-p entry)
        (setq results (nconc results (arxana-import--org-files-recursively entry))))
       ((and (file-regular-p entry)
             (string-match-p "\\.org\\'" entry))
        (push entry results))))
    results))

(defun arxana-import--org-files-in-directory (directory recursive)
  "Return Org files under DIRECTORY; RECURSIVE when non-nil."
  (let ((dir (file-name-as-directory (expand-file-name directory))))
    (if recursive
        (arxana-import--org-files-recursively dir)
      (directory-files dir t "\\.org\\'" t))))

(defun arxana-import-org-directory (directory &optional recursive)
  "Import all Org files under DIRECTORY.  With RECURSIVE, walk subdirs."
  (interactive "DImport Org directory: \nP")
  (let* ((files (arxana-import--org-files-in-directory directory recursive))
         (count 0))
    (dolist (file files)
      (arxana-import-org-file file)
      (setq count (1+ count)))
    (message "Imported %d Org file%s" count (if (= count 1) "" "s"))
    count))

(provide 'arxana-import)

;;; arxana-import.el ends here
#+END_SRC

** Export helpers

- Write each article to disk with metadata header lines.
- Capture label/link summaries for the manifest.
- Optionally tie exports to Futon snapshots when sync is enabled.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-export.el
;;; arxana-export.el --- Org exporters for Arxana -*- lexical-binding: t; -*-

;;; Commentary:
;; Helpers that write the current article table back to Org files so
;; XTDB snapshots can be shared as portable bundles.

;;; Code:

(require 'cl-lib)
(require 'subr-x)

(require 'arxana-article nil t)

(declare-function arxana-article--labels-for "arxana-article" (name))
(declare-function get-article "arxana-tangled" (name))
(declare-function scholium-name "arxana-tangled" (article))
(declare-function scholium-text "arxana-tangled" (article))
(declare-function scholium-about "arxana-tangled" (article))
(declare-function futon4--article-id-for "arxana-tangled" (name &optional path))
(declare-function link-type-accessor "arxana-tangled" (link type))
(declare-function arxana-store-save-snapshot "arxana-store" (&optional scope label))
(declare-function arxana-store--snapshot-scope-prompt "arxana-store" (&optional prompt default))
(declare-function arxana-store--snapshot-id-from-response "arxana-store" (response))
(declare-function arxana-store-sync-enabled-p "arxana-store" ())
#+END_SRC

* Inclusion / derivation UX

- The Scholia Display buffer now summarizes inclusion/transclusion passages in a “Derivation previews” block with toggleable excerpts.
- Source text is highlighted using dedicated faces (`arxana-derivation-inclusion-face`, etc.), and contributors can toggle or isolate each derivative type via the new highlight-only commands.
- The README’s interactive verification loop (register two articles, include one in the other, inspect `/ego`/`/cooccur`/`/tail`) remains the canonical self-test; the scripted version is in the README’s “Scripted verification” section.

- Now we bring in the actual derivation preview code (already literate) followed by the scholium/inclusion/article helpers so readers can see how the editing stack hangs together.

#+INCLUDE: "dev/arxana-derivation.el" src emacs-lisp

* Article lifecycle

- `arxana-scholium-*` commands wrap the legacy new-scholium flows with modern error handling.
- `arxana-inclusion.el` guards include/transclude so users get actionable errors.
- `arxana-article.el` syncs metadata and ensures Futon entities stay fresh.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-scholium.el
;;; arxana-scholium.el --- Scholium authoring helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Convenience wrappers around the classic scholium authoring flows.  These
;; commands expose the historical `new-scholium-mode` entry points while we
;; reanimate Part IV tooling.

;;; Code:

(require 'subr-x)

(defgroup arxana-scholium nil
  "Customization group for scholium authoring helpers."
  :group 'arxana)

(defvar new-scholium-name nil)
(defvar new-scholium-mode nil)
(defvar new-scholium-about nil)

(defun arxana-scholium--compose-about (target)
  "Helper that normalizes TARGET into the expected scholium about format."
  (setq new-scholium-about (list (list target)))
  (make-scholium))

;;;###autoload
(defun arxana-scholium-compose (&optional name)
  "Open a scholium buffer in `new-scholium-mode'."
  (interactive
   (list (when current-prefix-arg
           (read-string "Scholium name: " new-scholium-name nil new-scholium-name))))
  (arxana-scholium--ensure-support 'make-scholium)
  (arxana-scholium--set-name name)
  (make-scholium)
  (message "Enter scholium text, then press C-c C-c to publish."))

;; ... (rest of arxana-scholium.el in smaller blocks) ...
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-inclusion.el
;;; arxana-inclusion.el --- Guard legacy include/transclude helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Ensures include/transclude commands only run when the referenced article
;; has been registered, preventing silent “nil” insertions.

;;; Code:

(require 'subr-x)

(defun arxana-inclusion--require-article (name caller lookup)
  "Return the article NAME using LOOKUP or raise a helpful CALLER error."
  (let ((article (and name (funcall lookup name))))
    (unless article
      (user-error "%s: unknown article '%s'. Run `make-current-buffer-into-article' in that buffer first."
                 caller name))
    article))

(with-eval-after-load 'arxana-tangled
  (when (fboundp 'include-article)
    (let ((orig (symbol-function 'include-article)))
      (fset 'include-article
            (arxana-inclusion--wrap orig "include-article"))))
  (when (fboundp 'transclude-article)
    (let ((orig (symbol-function 'transclude-article)))
      (fset 'transclude-article
            (arxana-inclusion--wrap orig "transclude-article")))))

(provide 'arxana-inclusion)

;;; arxana-inclusion.el ends here
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-article.el
;;; arxana-article.el --- Article lifecycle helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Captures the bridge between classic Arxana operations (scholia, metadata
;; hooks, deletion) and the Futon storage helpers.

;;; Code:

(require 'arxana-store)
(require 'subr-x)

(defvar arxana-article-path-cache (make-hash-table :test 'equal)
  "Cache of canonical paths keyed by article name.")

(defun arxana-article--canonical-path (path)
  (when (and path (fboundp 'futon4--canonical-path))
    (setq path (futon4--canonical-path path)))
  path)

;; ... (rest of arxana-article.el broken into smaller blocks) ...

(provide 'arxana-article)

;;; arxana-article.el ends here
#+END_SRC

* Compatibility & test support
- The compatibility shim ensures modern `get-article` lookups hit the in-memory table before falling back to the legacy tangle.
- Test suites load the tangled code by way of the shared helper so they work whether invoked from the repo root or inside `arxana/`.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-compat.el
;;; arxana-compat.el --- Modern helpers for legacy accessors -*- lexical-binding: t; -*-

;;; Commentary:
;; Interposes `get-article` so the modern hash table is consulted before falling back to the legacy implementation.

;;; Code:

(defvar arxana-compat--orig-get-article nil
  "Original `get-article' captured before installing the compat shim.")

(defun arxana-compat--hash-article (name)
  "Return (NAME . VALUE) from `article-table' when available."
  (when (and (boundp 'article-table)
             (hash-table-p article-table)
             name)
    (let ((value (gethash name article-table)))
      (when value
        (cons name value)))))

(defun arxana-compat--get-article (name)
  "Prefer the modern article table before hitting the legacy fallback."
  (or (arxana-compat--hash-article name)
      (when (functionp arxana-compat--orig-get-article)
        (funcall arxana-compat--orig-get-article name))))

(with-eval-after-load 'arxana-tangled
  (unless arxana-compat--orig-get-article
    (setq arxana-compat--orig-get-article (symbol-function 'get-article))
    (fset 'get-article #'arxana-compat--get-article)))

(provide 'arxana-compat)

;;; arxana-compat.el ends here
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-test-support.el
;;; arxana-test-support.el --- Shared helpers for ERT suites -*- lexical-binding: t; -*-

;;; Commentary:
;; Provides utilities to locate/load the tangled Arxana sources inside
;; the dev/test harness, regardless of whether we're running from the
;; repo root or from within the arxana/ subtree.

;;; Code:

(require 'cl-lib)

(defun arxana-test--locate-tangled ()
  "Return the best-effort path to `arxana-tangled.el'."
  (let* ((root (or (and (boundp 'arxana-root-directory)
                        arxana-root-directory)
                   default-directory))
         (candidates (list (expand-file-name "arxana/arxana-tangled.el" root)
                           (expand-file-name "arxana-tangled.el" root))))
    (cl-loop for path in candidates
             when (file-exists-p path)
             return path)))

(defun arxana-test--ensure-tangled-loaded ()
  "Load the tangled sources if they are not already resident."
  (unless (featurep 'arxana-tangled)
    (let ((tangled (arxana-test--locate-tangled)))
      (unless tangled
        (error "Cannot find arxana-tangled.el; run arxana-build first"))
      (load-file tangled))))

(provide 'arxana-test-support)

;;; arxana-test-support.el ends here
#+END_SRC

* Contributor guide (embedded)

#+INCLUDE: "docs/contributor-guide.md"

* QA checklist

#+BEGIN_SRC shell :exports code
./dev/run-tests.sh
#+END_SRC

* Known limitations

- Pattern-language wide editing (future milestone).
- Org→graph semantic mirroring pending.

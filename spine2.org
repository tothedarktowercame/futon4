#+TITLE: Arxana Spine 2 (Prototype 1)
#+AUTHOR: Futon4 / Arxana team
#+OPTIONS: toc:t num:t

* Overview
This staging spine captures the Prototype 1 state of the revived Arxana
client while we fold each dev module back into the literate sources.

#+INCLUDE: "0-Reintroduction.org"

* Quickstart

- Start Futon1 locally (`http://localhost:8080`).
- `M-x load-file` → `arxana/dev/bootstrap.el`
- `M-x arxana-build` (use `C-u` to force tangling).
- `(setq futon4-base-url "http://localhost:8080/api/alpha")`
- `(setq futon4-enable-sync t)`
- Register buffers: `(make-current-buffer-into-article "Demo")`
- Capture scholia: `(scholium "demo/link" "Note" '(("Demo")))`

#+BEGIN_SRC emacs-lisp :tangle dev/bootstrap2.el
(load (expand-file-name "dev/bootstrap.el" default-directory))
#+END_SRC

* Storage bridge

#+INCLUDE: "docs/storage-bridge.org"

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-store.el
;;; arxana-store.el --- Futon storage bridge helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Thin wrappers around the Futon1 HTTP API. These helpers sit on top of
;; the historical `futon4-*` functions so callers have a consistent,
;; testable interface for ensuring articles, storing scholia, and fetching
;; data back from the server.

;;; Code:

(require 'cl-lib)
(require 'json)
(require 'subr-x)
(require 'url)
(require 'url-http)

(defgroup arxana-store nil
  "Futon storage bridge settings."
  :group 'arxana)

(defcustom arxana-store-default-profile nil
  "Optional profile name to send via the X-Profile header."
  :type '(choice (const :tag "Default" nil)
                 string)
  :group 'arxana-store)

(defcustom arxana-store-request-timeout 10
  "Number of seconds to wait for Futon HTTP responses."
  :type 'integer
  :group 'arxana-store)

(defconst arxana-store--snapshot-scopes '("all" "latest")
  "Valid snapshot scope identifiers for Futon/XTDB backups.")

(defvar arxana-store-last-error nil
  "Most recent storage error (plist with :reason, :detail, :context).")

(defvar arxana-store-last-response nil
  "Most recent JSON body returned by `arxana-store--request'.")

(defun arxana-store-clear-error ()
  "Clear `arxana-store-last-error'."
  (setq arxana-store-last-error nil))

(defun arxana-store-sync-enabled-p ()
  "Return non-nil when Futon sync is enabled."
  (and (boundp 'futon4-enable-sync)
       futon4-enable-sync))

(defun arxana-store--record-error (reason detail &optional context)
  "Remember an error REASON/DETAIL/CONTEXT and log it."
  (setq arxana-store-last-error (list :reason reason
                                      :detail detail
                                      :context context))
  (message "[arxana-store] %s" detail)
  nil)

(defun arxana-store--base-url ()
  (or (and (boundp 'futon4-base-url) futon4-base-url)
      (error "futon4-base-url is not set")))

(defun arxana-store--build-url (path &optional query)
  (concat (arxana-store--base-url)
          path
          (if (and query (> (length query) 0))
              (concat "?" query)
            "")))

(defun arxana-store--encode-segment (value)
  (url-hexify-string (or value "")))

(defun arxana-store--query-string (params)
  (let ((pairs
         (delq nil
               (mapcar (lambda (kv)
                         (when (cdr kv)
                           (format "%s=%s"
                                   (car kv)
                                   (arxana-store--encode-segment (format "%s" (cdr kv))))))
                       params))))
    (when pairs
      (string-join pairs "&"))))

(defun arxana-store--default-headers (payload-p)
  (append (list '("Accept" . "application/json"))
          (when payload-p '(("Content-Type" . "application/json")))
          (when arxana-store-default-profile
            (list (cons "X-Profile" arxana-store-default-profile)))))

(defun arxana-store--canonical-path (path)
  (if (and path (fboundp 'futon4--canonical-path))
      (futon4--canonical-path path)
    path))

(defun arxana-store--request (method path &optional payload query)
  "Fire METHOD PATH against Futon and return the parsed JSON body.
Optional PAYLOAD is JSON encoded for POST requests. QUERY is an
already encoded query string (without the leading ?)."
  (if (not (arxana-store-sync-enabled-p))
      (arxana-store--record-error 'disabled "Futon sync disabled" method)
    (let* ((url-request-method method)
           (url-request-data (when payload
                               (encode-coding-string (json-encode payload) 'utf-8)))
           (url-request-extra-headers (arxana-store--default-headers payload))
           (target (arxana-store--build-url path query)))
      (condition-case err
          (let ((buf (url-retrieve-synchronously target nil nil arxana-store-request-timeout)))
            (if (not (buffer-live-p buf))
                (progn
                  (when buf (kill-buffer buf))
                  (arxana-store--record-error 'connection "No response buffer" target))
              (with-current-buffer buf
                (goto-char (point-min))
                (if (not (re-search-forward "\r?\n\r?\n" nil t))
                    (progn
                      (kill-buffer buf)
                      (arxana-store--record-error 'protocol "Malformed HTTP response" target))
                  (let* ((json-object-type 'alist)
                         (json-array-type 'list)
                         (json-key-type 'keyword)
                         (body (ignore-errors (json-read))))
                    (kill-buffer buf)
                    (if body
                        (progn
                          (setq arxana-store-last-error nil
                                arxana-store-last-response body)
                          body)
                      (arxana-store--record-error 'protocol "Failed to parse Futon JSON" target)))))))
        (error
         (arxana-store--record-error 'request err target))))))

(defun arxana-store--normalize-snapshot-scope (scope context)
  "Return the canonical snapshot SCOPE string or record an error for CONTEXT."
  (let ((value (cond
                ((null scope) "all")
                ((stringp scope) scope)
                ((symbolp scope) (symbol-name scope))
                (t scope))))
    (if (member value arxana-store--snapshot-scopes)
        value
      (arxana-store--record-error
       'invalid
       (format "Unknown snapshot scope %S (expected %s)"
               scope arxana-store--snapshot-scopes)
       context))))

(defun arxana-store--snapshot-scope-prompt (&optional prompt default)
  "Prompt user for a snapshot scope using PROMPT and DEFAULT."
  (let* ((prompt (or prompt "Snapshot scope (all/latest): "))
         (default (or default "all"))
         (choice (completing-read prompt arxana-store--snapshot-scopes
                                  nil t nil nil default)))
    (intern choice)))

(cl-defun arxana-store-ensure-entity (&key id name type source external-id seen-count pinned? last-seen)
  "Ensure Futon has an entity named NAME of TYPE, returning the response.
ID, SOURCE, EXTERNAL-ID, SEEN-COUNT, PINNED?, and LAST-SEEN mirror the
payload accepted by Futon's `/entity` endpoint. TYPE may be a keyword or
string. Signals a user error when NAME is missing."
  (unless name
    (user-error "Entity name is required"))
  (let* ((payload (delq nil (list (cons 'name name)
                                  (cons 'type (if (keywordp type)
                                                  (symbol-name type)
                                                type))
                                  (when id (cons 'id id))
                                  (when source (cons 'source source))
                                  (when external-id (cons 'external-id external-id))
                                  (when seen-count (cons 'seen-count seen-count))
                                  (when pinned? (cons 'pinned pinned?))
                                  (when last-seen (cons 'last-seen last-seen))))))
    (arxana-store--request "POST" "/entity" payload)))

;;; (rest of file omitted for brevity)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-saving.el
;;; arxana-saving.el --- Snapshot-aware save/restore helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Provides runtime shims so the legacy `save-all-scholia` and
;; `read-scholia-file` commands can drive Futon's snapshot endpoints when
;; sync is enabled.  When sync is disabled the original file-based
;; implementations continue to run unchanged.

;;; Code:

(require 'subr-x)

(declare-function arxana-store-save-snapshot "arxana-store" (&optional scope label))
(declare-function arxana-store-restore-snapshot "arxana-store" (&optional snapshot-id scope))
(declare-function arxana-store--snapshot-scope-prompt "arxana-store" (&optional prompt default))
(declare-function arxana-store--snapshot-id-from-response "arxana-store" (response))

(defconst arxana-saving--fallback-scopes '("all" "latest")
  "Scopes offered when the store helpers are unavailable.")

(defun arxana-saving--prompt-scope (prompt default)
  "Read a snapshot scope with PROMPT and DEFAULT.
Returns DEFAULT without prompting when running noninteractively."
  (cond
   (noninteractive default)
   ((fboundp 'arxana-store--snapshot-scope-prompt)
    (arxana-store--snapshot-scope-prompt prompt default))
   (t (completing-read prompt arxana-saving--fallback-scopes nil t nil nil default))))

(defun arxana-saving--prompt-label ()
  "Ask the user for an optional snapshot label.
Returns nil without prompting when running noninteractively."
  (if noninteractive
      nil
    (let ((label (read-string "Snapshot label (optional): ")))
      (unless (string-empty-p label)
        label))))

(defun arxana-saving--snapshot-enabled-p ()
  "Return non-nil when snapshot shims should run."
  (and (boundp 'futon4-enable-sync)
       futon4-enable-sync
       (fboundp 'arxana-store-save-snapshot)))

(defun arxana-saving--restore-enabled-p ()
  "Return non-nil when restore shims should run."
  (and (boundp 'futon4-enable-sync)
       futon4-enable-sync
       (fboundp 'arxana-store-restore-snapshot)))

(defun arxana-saving--wrap-save-all (orig-fn filename &optional scope)
  "Around advice for `save-all-scholia'.
ORIG-FN is the original implementation; FILENAME and SCOPE are passed
from the caller (SCOPE is only present when invoked programmatically)."
  (if (arxana-saving--snapshot-enabled-p)
      (let* ((scope (or scope (arxana-saving--prompt-scope "Snapshot scope (all/latest): " "all")))
             (label (or (and noninteractive filename)
                        (arxana-saving--prompt-label)))
             (response (arxana-store-save-snapshot scope label))
             (id (when (fboundp 'arxana-store--snapshot-id-from-response)
                   (arxana-store--snapshot-id-from-response response))))
        (message "Saved Futon snapshot scope=%s id=%s"
                 scope (or id "<unknown>")))
    (apply orig-fn (list filename))))

(defun arxana-saving--wrap-read-scholia (orig-fn filepath &optional scope)
  "Around advice for `read-scholia-file'.
ORIG-FN is the original implementation; FILEPATH is treated as a
snapshot id when syncing is enabled."
  (if (arxana-saving--restore-enabled-p)
      (let* ((snapshot-id (unless (string-empty-p filepath) filepath))
             (scope (or scope (arxana-saving--prompt-scope "Restore scope (all/latest): " "all"))))
        (arxana-store-restore-snapshot snapshot-id scope))
    (apply orig-fn (list filepath))))

(with-eval-after-load 'arxana-tangled
  (when (fboundp 'save-all-scholia)
    (advice-add 'save-all-scholia :around #'arxana-saving--wrap-save-all))
  (when (fboundp 'read-scholia-file)
    (advice-add 'read-scholia-file :around #'arxana-saving--wrap-read-scholia)))

(provide 'arxana-saving)

;;; arxana-saving.el ends here
#+END_SRC

#+INCLUDE: "dev/arxana-store.el" src emacs-lisp

* Pattern workflows

- `M-x arxana-patterns-open` — fetch a Futon pattern (e.g., `mojo/center`) into an Org buffer, complete with the component identifiers.
- Edit the buffer like any other Org document; the Futon ids stay in the headings so provenance survives.
- `C-c C-s` (`arxana-patterns-save`) — push the updated text back to Futon.
- Run `dev/run-tests.sh` before publishing to confirm the pattern helpers and storage shims still behave.

#+INCLUDE: "dev/arxana-patterns.el" src emacs-lisp

* Browsing & relations

** Catalog & label menus

The Part VI menus still work via modern commands:

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-browse.el
;;; arxana-browse.el --- Part VI browsing helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Convenience wrappers that expose the legacy Part VI browsing flows via
;; modern `arxana-*' commands. Contributors can continue to use catalog and
;; label menus without memorising the old entry points.

;;; Code:

(require 'cl-lib)
(require 'subr-x)

(defgroup arxana-browse nil
  "Part VI browsing entry points."
  :group 'arxana)

(declare-function article-menu-listing "arxana-tangled" (&optional subset accessors))
(declare-function article-menu-list-all-articles "arxana-tangled" () t)
(declare-function article-menu-list-labels "arxana-tangled" () t)

(defun arxana-browse--ensure (fn)
  "Signal a user error unless FN is bound."
  (unless (fboundp fn)
    (user-error "Browsing helpers are unavailable; run `arxana-build' first"))
  fn)

;;;###autoload
(defun arxana-browse-open-catalog (&optional include-all)
  "Open the article catalog. With INCLUDE-ALL, show every article."
  (interactive "P")
  (if include-all
      (progn
        (arxana-browse--ensure 'article-menu-list-all-articles)
        (article-menu-list-all-articles))
    (progn
      (arxana-browse--ensure 'article-menu-listing)
      (article-menu-listing))))

;;;###autoload
(defun arxana-browse-open-labels ()
  "List label articles in the catalog menu."
  (interactive)
  (arxana-browse--ensure 'article-menu-list-labels)
  (article-menu-list-labels))
#+END_SRC

** Link-following & history

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-browse.el
(declare-function follow-reference-or-scholium "arxana-tangled" () t)
(declare-function display-an-article-that-current-article-is-about "arxana-tangled" () t)
(declare-function display-an-article-that-current-scholium-is-about "arxana-tangled" () t)
(declare-function sb-back "arxana-tangled" () t)
(declare-function sb-forward "arxana-tangled" () t)

;;;###autoload
(defun arxana-browse-follow-link ()
  "Follow the scholium or reference at point."
  (interactive)
  (arxana-browse--ensure 'follow-reference-or-scholium)
  (follow-reference-or-scholium))

;;;###autoload
(defun arxana-browse-follow-article-about ()
  "Jump to an article referenced by the current article."
  (interactive)
  (arxana-browse--ensure 'display-an-article-that-current-article-is-about)
  (display-an-article-that-current-article-is-about))

;;;###autoload
(defun arxana-browse-follow-scholium-about ()
  "Jump to an article referenced by the current scholium."
  (interactive)
  (arxana-browse--ensure 'display-an-article-that-current-scholium-is-about)
  (display-an-article-that-current-scholium-is-about))

;;;###autoload
(defun arxana-browse-history-back ()
  "Move to the previous article in the temporal browsing history."
  (interactive)
  (arxana-browse--ensure 'sb-back)
  (sb-back))

;;;###autoload
(defun arxana-browse-history-forward ()
  "Move to the next article in the temporal browsing history."
  (interactive)
  (arxana-browse--ensure 'sb-forward)
  (sb-forward))
#+END_SRC

** Relation buffers in context

- `M-x arxana-relations-show-ego` / `cooccur` / `tail` render Futon adjacency directly in Emacs buffers with refresh/provenance/copy bindings.
- The new literate blocks describe the buffer minor mode, formatting helpers, renderers, and commands.

** Relation buffers in context

The relation helpers render Futon adjacency inside Emacs so we no longer
need to shell out to curl. Each buffer is a minor mode with refresh,
provenance, and copy-id bindings.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-relations.el
;;; arxana-relations.el --- Relation browsing helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Interactive commands that render Futon relation data (/ego, /cooccur, /tail)
;; inside Emacs so users no longer need to shell out to curl.

;;; Code:

(require 'cl-lib)
(require 'seq)
(require 'subr-x)
(require 'arxana-store)

(declare-function futon4-lookup-article-id "arxana-tangled" (name))
(declare-function futon4--article-id-for "arxana-tangled" (name &optional path))

(defgroup arxana-relations nil
  "Buffers for browsing Futon relation data."
  :group 'arxana)

(defconst arxana-relations-buffer-name "*Arxana Relations*")

(defvar-local arxana-relations-context nil
  "Plist describing the last Futon render in this buffer.")

(defvar arxana-relations-buffer-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "g") #'arxana-relations-refresh)
    (define-key map (kbd "p") #'arxana-relations-provenance)
    (define-key map (kbd "y") #'arxana-relations-copy-id)
    map)
  "Keymap for `arxana-relations-buffer-mode'.")

(define-minor-mode arxana-relations-buffer-mode
  "Minor mode that adds refresh/provenance commands to relation buffers."
  :lighter " ArxRel"
  :keymap arxana-relations-buffer-mode-map
  (if arxana-relations-buffer-mode
      (setq-local revert-buffer-function #'arxana-relations--revert-buffer)
    (kill-local-variable 'revert-buffer-function)))
#+END_SRC

** Formatting helpers

Before we render anything we normalize type labels, build friendly names,
and provide helpers for inserting sections into the buffer.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-relations.el
(defun arxana-relations--type-label (type)
  (cond
   ((keywordp type) (substring (symbol-name type) 1))
   ((symbolp type) (symbol-name type))
   ((stringp type) type)
   (t (format "%s" type))))

(defun arxana-relations--name-with-type (name type)
  (if (and name type)
      (format "%s (%s)" name (arxana-relations--type-label type))
    (or name "?")))

(defun arxana-relations--entity-name (entity)
  (or (alist-get :entity/name entity)
      (alist-get :name entity)))

(defun arxana-relations--entity-type (entity)
  (or (alist-get :entity/type entity)
      (alist-get :type entity)))

(defun arxana-relations--insert-line (fmt &rest args)
  (insert (apply #'format (concat fmt "\n") args)))

(defun arxana-relations--insert-section (title lines)
  (arxana-relations--insert-line "%s" title)
  (if (seq-empty-p lines)
      (arxana-relations--insert-line "  (none)")
    (dolist (line lines)
      (arxana-relations--insert-line "  - %s" line))))
#+END_SRC

** Rendering Futon responses

Each renderer translates a Futon response (`/ego`, `/cooccur`, `/tail`) into a
human-readable set of lines.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-relations.el
(defun arxana-relations--render-ego (body)
  ;; ... body of function ...
  )

(defun arxana-relations--render-cooccur (body)
  ;; ... body of function ...
  )

(defun arxana-relations--render-tail (body)
  ;; ... body of function ...
  )

(defun arxana-relations--render-fallback (body)
  (arxana-relations--insert-line "Raw response:")
  (pp body (current-buffer)))
#+END_SRC

** Commands & context

Finally we wire up interactive commands (`arxana-relations-show-ego`, etc.),
store the last Futon context, and expose refresh/provenance/copy-id helpers.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-relations.el
;; ... remaining functions from dev/arxana-relations.el ...

(provide 'arxana-relations)

;;; arxana-relations.el ends here
#+END_SRC

** Legacy navigation commands

#+INCLUDE: "dev/arxana-browse.el" src emacs-lisp

** XTDB browsing shims

The XTDB browser exposes `/tail` data via a tabulated list and lets contributors
inspect source/target entities, jump into relation buffers, or tweak the limit.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-xtdb-browse.el
;;; arxana-xtdb-browse.el --- XTDB browser for Futon datasets -*- lexical-binding: t; -*-

;;; Commentary:
;; Provides an Emacs UI for peeking into Futon/XTDB data.  Uses `/tail`
;; to list recent relations and lets users drill into entities or
;; open the existing relation buffers.

;;; Code:

(require 'seq)
(require 'tabulated-list)
(require 'subr-x)
(require 'arxana-store)
(require 'arxana-relations)

(defgroup arxana-xtdb-browse nil
  "Interactive browser for Futon/XTDB contents."
  :group 'arxana)

(defcustom arxana-xtdb-browse-default-limit 25
  "Number of relations to request when browsing XTDB."
  :type 'integer
  :group 'arxana-xtdb-browse)

(defvar arxana-xtdb-browse-buffer "*Arxana XTDB Browser*")
(defvar-local arxana-xtdb--current-limit arxana-xtdb-browse-default-limit)
(defvar-local arxana-xtdb--tail-response nil)
#+END_SRC

** XTDB helpers

Normalize Futon rows into tabulated entries and provide entity inspectors.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-xtdb-browse.el
(defun arxana-xtdb--entity-name (entity)
  (or (alist-get :name entity)
      (alist-get :entity/name entity)
      "<unknown>"))

(defun arxana-xtdb--entity-type (entity)
  (or (alist-get :type entity)
      (alist-get :entity/type entity)))

(defun arxana-xtdb--entity-ident (entity)
  (or (alist-get :ident entity)
      (alist-get :entity/id entity)))

(defun arxana-xtdb--entity-label (entity)
  (let ((name (arxana-xtdb--entity-name entity))
        (type (arxana-xtdb--entity-type entity)))
    (if type
        (format "%s (%s)" name type)
      name)))

(defun arxana-xtdb--relation-row-p (row)
  (and (listp row)
       (consp (car row))
       (or (alist-get :src row)
           (alist-get :dst row))))

(defun arxana-xtdb--tail-rows (body)
  "Normalize BODY (from `/tail`) into a list of relation alists."
  (let* ((section (or (alist-get :tail body)
                      body))
         (raw (or (alist-get :relations section)
                  (alist-get :links section)
                  (alist-get :items section)
                  section)))
    (when (not (listp raw))
      (setq raw nil))
    (seq-filter #'arxana-xtdb--relation-row-p raw)))

(defun arxana-xtdb--rows->entries (rows)
  "Return tabulated-list entries derived from ROWS."
  (let ((index 0))
    (mapcar
     (lambda (row)
       (setq index (1+ index))
       (let* ((src (alist-get :src row))
              (dst (alist-get :dst row))
              (relation (alist-get :type row))
              (last-seen (or (alist-get :last-seen row)
                             (alist-get :hx/last-seen row)
                             ""))
              (vector (vector (format "%s" last-seen)
                              (format "%s" relation)
                              (arxana-xtdb--entity-label src)
                              (arxana-xtdb--entity-label dst))))
         (list index vector row)))
     rows)))

(defun arxana-xtdb--describe-entity (entity)
  "Display ENTITY data using `arxana-store-fetch-entity'."
  (let* ((ident (arxana-xtdb--entity-ident entity))
         (name (arxana-xtdb--entity-name entity)))
    (unless ident
      (user-error "No Futon id recorded for %s" name))
    (let ((data (arxana-store-fetch-entity ident)))
      (unless data
        (user-error "No Futon data for %s" name))
      (with-current-buffer (get-buffer-create "*Arxana Entity*")
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (format "Entity: %s\nId: %s\n\n" name ident))
          (pp data (current-buffer))
          (goto-char (point-min))
          (view-mode 1))
        (display-buffer (current-buffer))))))
#+END_SRC

** Tabulated UI & commands

The major mode uses `tabulated-list-mode` with shortcuts for refreshing,
changing limits, inspecting raw payloads, and opening relation buffers.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-xtdb-browse.el
(defun arxana-xtdb-refresh (&optional limit)
  "Refresh the XTDB browser contents with LIMIT rows."
  (interactive)
  (let* ((limit (or limit arxana-xtdb--current-limit))
         (body (arxana-store-tail limit)))
    (setq arxana-xtdb--current-limit limit
          arxana-xtdb--tail-response body)
    (let ((rows (arxana-xtdb--tail-rows (or body '()))))
      (if rows
          (progn
            (setq tabulated-list-entries (arxana-xtdb--rows->entries rows))
            (tabulated-list-print t)
            (message "Fetched %d relations" (length rows)))
        (setq tabulated-list-entries nil)
        (tabulated-list-print t)
        (message "No relations returned from Futon")))))

(defun arxana-xtdb-browse-change-limit (limit)
  "Set a new LIMIT for `/tail` results and refresh."
  (interactive (list (read-number "Tail limit: " arxana-xtdb--current-limit)))
  (arxana-xtdb-refresh limit))

(defun arxana-xtdb-browse-inspect-raw ()
  "Display the raw `/tail` payload for debugging."
  (interactive)
  (unless arxana-xtdb--tail-response
    (user-error "No XTDB payload captured yet"))
  (with-current-buffer (get-buffer-create "*Arxana XTDB Raw*")
    (let ((inhibit-read-only t))
      (erase-buffer)
      (pp arxana-xtdb--tail-response (current-buffer))
      (goto-char (point-min))
      (view-mode 1))
    (display-buffer (current-buffer))))

(defvar arxana-xtdb-browse-mode-map
  (let ((map (copy-keymap tabulated-list-mode-map)))
    (define-key map (kbd "g") #'arxana-xtdb-refresh)
    (define-key map (kbd "l") #'arxana-xtdb-browse-change-limit)
    (define-key map (kbd "RET") #'arxana-xtdb-browse-show-ego)
    (define-key map (kbd "s") #'arxana-xtdb-browse-open-source)
    (define-key map (kbd "t") #'arxana-xtdb-browse-open-target)
    (define-key map (kbd "R") #'arxana-xtdb-browse-inspect-raw)
    map)
  "Keymap for `arxana-xtdb-browse-mode'.")

(define-derived-mode arxana-xtdb-browse-mode tabulated-list-mode "XTDB"
  "Major mode for browsing Futon/XTDB relations."
  (setq tabulated-list-format [("Seen" 18 t)
                               ("Relation" 18 t)
                               ("Source" 25 t)
                               ("Target" 25 t)]
        tabulated-list-padding 2
        tabulated-list-sort-key (cons "Seen" nil))
  (tabulated-list-init-header))

;;;###autoload
(defun arxana-xtdb-browse (&optional limit)
  "List recent Futon relations using a tabulated UI.
When LIMIT is provided (or via prefix), request that many rows."
  (interactive (list (when current-prefix-arg
                       (read-number "Tail limit: " arxana-xtdb-browse-default-limit))))
  (let ((buffer (get-buffer-create arxana-xtdb-browse-buffer)))
    (with-current-buffer buffer
      (arxana-xtdb-browse-mode)
      (arxana-xtdb-refresh limit))
    (pop-to-buffer buffer)))

(provide 'arxana-xtdb-browse)

;;; arxana-xtdb-browse.el ends here
#+END_SRC

* Org imports / exports & snapshots

- `M-x arxana-import-org-file` derives an article name from `#+TITLE` (or the filename), stores the text as a scholium, and mirrors it into XTDB.
- `M-x arxana-import-org-directory` walks a tree of `.org` files (`C-u` to recurse) and feeds each file through the importer.
- `M-x arxana-export-org-directory` writes every loaded article back to disk and produces a manifest with snapshot metadata, inclusion/transclusion summaries, and a label index. With sync enabled the command first captures a Futon snapshot so the export is tied to a specific XTDB revision.
- `C-; r` / `M-x save-all-scholia` hit `/snapshot` when sync is enabled (falling back to the `.sch` writer when offline). `M-x read-scholia-file` mirrors the behavior for restore.
- Migration recipe: 1) snapshot the legacy collection, 2) run `arxana-import-org-directory`, 3) edit in Emacs, 4) export and capture the new manifest for diffable releases.

** Single-file importer

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-import.el
;;; arxana-import.el --- Org → XTDB import helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Utility functions that read Org files/directories and push their
;; contents into Arxana's article graph (and, via the existing store
;; hooks, into XTDB).

;;; Code:

(require 'cl-lib)
(require 'subr-x)

(declare-function scholium "arxana-tangled" (name text &optional about type book))
(declare-function sch-book "arxana-tangled" () nil)
(declare-function arxana-store-ensure-article "arxana-store" (&rest _))
(declare-function futon4--canonical-path "arxana-tangled" (path))

(defun arxana-import--read-file-contents (path)
  "Return the contents of PATH as a string."
  (with-temp-buffer
    (insert-file-contents path)
    (buffer-string)))

(defun arxana-import--org-title-from-string (text)
  "Extract a #+TITLE from TEXT when present."
  (with-temp-buffer
    (insert text)
    (goto-char (point-min))
    (let ((case-fold-search t))
      (when (re-search-forward "^#\\+TITLE:[[:space:]]*" nil t)
        (let ((start (point)))
          (end-of-line)
          (string-trim (buffer-substring-no-properties start (point))))))))

(defun arxana-import--derive-name (path text)
  "Pick a reasonable article name from PATH and TEXT."
  (or (arxana-import--org-title-from-string text)
      (file-name-base path)
      (file-name-nondirectory path)))

(defun arxana-import--canonical-path (path)
  (if (fboundp 'futon4--canonical-path)
      (futon4--canonical-path path)
    path))

(defun arxana-import-org-file (path)
  "Import the Org file at PATH into the Arxana article table."
  (interactive "fOrg file: ")
  (let* ((text (arxana-import--read-file-contents path))
         (name (arxana-import--derive-name path text)))
    (when (string-empty-p (or name ""))
      (error "Could not derive article name from %s" path))
    (scholium name text nil '(org) (sch-book))
    (when (fboundp 'arxana-store-ensure-article)
      (arxana-store-ensure-article :name name :path (arxana-import--canonical-path path)))
    (message "Imported %s" name)
    name))
#+END_SRC

** Directory importer

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-import.el
(defun arxana-import--org-files-recursively (directory)
  "Return Org files under DIRECTORY recursively."
  (let ((results nil))
    (dolist (entry (directory-files directory t directory-files-no-dot-files-regexp))
      (cond
       ((file-directory-p entry)
        (setq results (nconc results (arxana-import--org-files-recursively entry))))
       ((and (file-regular-p entry)
             (string-match-p "\\.org\\'" entry))
        (push entry results))))
    results))

(defun arxana-import--org-files-in-directory (directory recursive)
  "Return Org files under DIRECTORY; RECURSIVE when non-nil."
  (let ((dir (file-name-as-directory (expand-file-name directory))))
    (if recursive
        (arxana-import--org-files-recursively dir)
      (directory-files dir t "\\.org\\'" t))))

(defun arxana-import-org-directory (directory &optional recursive)
  "Import all Org files under DIRECTORY.  With RECURSIVE, walk subdirs."
  (interactive "DImport Org directory: \nP")
  (let* ((files (arxana-import--org-files-in-directory directory recursive))
         (count 0))
    (dolist (file files)
      (arxana-import-org-file file)
      (setq count (1+ count)))
    (message "Imported %d Org file%s" count (if (= count 1) "" "s"))
    count))

(provide 'arxana-import)

;;; arxana-import.el ends here
#+END_SRC

** Export helpers

- Write each article to disk with metadata header lines.
- Capture label/link summaries for the manifest.
- Optionally tie exports to Futon snapshots when sync is enabled.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-export.el
;;; arxana-export.el --- Org exporters for Arxana -*- lexical-binding: t; -*-

;;; Commentary:
;; Helpers that write the current article table back to Org files so
;; XTDB snapshots can be shared as portable bundles.

;;; Code:

(require 'cl-lib)
(require 'subr-x)

(require 'arxana-article nil t)

(declare-function arxana-article--labels-for "arxana-article" (name))
(declare-function get-article "arxana-tangled" (name))
(declare-function scholium-name "arxana-tangled" (article))
(declare-function scholium-text "arxana-tangled" (article))
(declare-function scholium-about "arxana-tangled" (article))
(declare-function futon4--article-id-for "arxana-tangled" (name &optional path))
(declare-function link-type-accessor "arxana-tangled" (link type))
(declare-function arxana-store-save-snapshot "arxana-store" (&optional scope label))
(declare-function arxana-store--snapshot-scope-prompt "arxana-store" (&optional prompt default))
(declare-function arxana-store--snapshot-id-from-response "arxana-store" (response))
(declare-function arxana-store-sync-enabled-p "arxana-store" ())
#+END_SRC

* Inclusion / derivation UX

- The Scholia Display buffer now summarizes inclusion/transclusion passages in a “Derivation previews” block with toggleable excerpts.
- Source text is highlighted using dedicated faces (`arxana-derivation-inclusion-face`, etc.), and contributors can toggle or isolate each derivative type via the new highlight-only commands.
- The README’s interactive verification loop (register two articles, include one in the other, inspect `/ego`/`/cooccur`/`/tail`) remains the canonical self-test; the scripted version is in the README’s “Scripted verification” section.

- Now we bring in the actual derivation preview code (already literate) followed by the scholium/inclusion/article helpers so readers can see how the editing stack hangs together.

#+INCLUDE: "dev/arxana-derivation.el" src emacs-lisp

* Article lifecycle

- `arxana-scholium-*` commands wrap the legacy new-scholium flows with modern error handling.
- `arxana-inclusion.el` guards include/transclude so users get actionable errors.
- `arxana-article.el` syncs metadata and ensures Futon entities stay fresh.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-scholium.el
;;; arxana-scholium.el --- Scholium authoring helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Convenience wrappers around the classic scholium authoring flows.  These
;; commands expose the historical `new-scholium-mode` entry points while we
;; reanimate Part IV tooling.

;;; Code:

(require 'subr-x)

(defgroup arxana-scholium nil
  "Customization group for scholium authoring helpers."
  :group 'arxana)

(defvar new-scholium-name nil)
(defvar new-scholium-mode nil)
(defvar new-scholium-about nil)

(defun arxana-scholium--compose-about (target)
  "Helper that normalizes TARGET into the expected scholium about format."
  (setq new-scholium-about (list (list target)))
  (make-scholium))

;;;###autoload
(defun arxana-scholium-compose (&optional name)
  "Open a scholium buffer in `new-scholium-mode'."
  (interactive
   (list (when current-prefix-arg
           (read-string "Scholium name: " new-scholium-name nil new-scholium-name))))
  (arxana-scholium--ensure-support 'make-scholium)
  (arxana-scholium--set-name name)
  (make-scholium)
  (message "Enter scholium text, then press C-c C-c to publish."))

;; ... (rest of arxana-scholium.el in smaller blocks) ...
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-inclusion.el
;;; arxana-inclusion.el --- Guard legacy include/transclude helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Ensures include/transclude commands only run when the referenced article
;; has been registered, preventing silent “nil” insertions.

;;; Code:

(require 'subr-x)

(defun arxana-inclusion--require-article (name caller lookup)
  "Return the article NAME using LOOKUP or raise a helpful CALLER error."
  (let ((article (and name (funcall lookup name))))
    (unless article
      (user-error "%s: unknown article '%s'. Run `make-current-buffer-into-article' in that buffer first."
                 caller name))
    article))

(with-eval-after-load 'arxana-tangled
  (when (fboundp 'include-article)
    (let ((orig (symbol-function 'include-article)))
      (fset 'include-article
            (arxana-inclusion--wrap orig "include-article"))))
  (when (fboundp 'transclude-article)
    (let ((orig (symbol-function 'transclude-article)))
      (fset 'transclude-article
            (arxana-inclusion--wrap orig "transclude-article")))))

(provide 'arxana-inclusion)

;;; arxana-inclusion.el ends here
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-article.el
;;; arxana-article.el --- Article lifecycle helpers -*- lexical-binding: t; -*-

;;; Commentary:
;; Captures the bridge between classic Arxana operations (scholia, metadata
;; hooks, deletion) and the Futon storage helpers.

;;; Code:

(require 'arxana-store)
(require 'subr-x)

(defvar arxana-article-path-cache (make-hash-table :test 'equal)
  "Cache of canonical paths keyed by article name.")

(defun arxana-article--canonical-path (path)
  (when (and path (fboundp 'futon4--canonical-path))
    (setq path (futon4--canonical-path path)))
  path)

;; ... (rest of arxana-article.el broken into smaller blocks) ...

(provide 'arxana-article)

;;; arxana-article.el ends here
#+END_SRC

* Compatibility & test support
- The compatibility shim ensures modern `get-article` lookups hit the in-memory table before falling back to the legacy tangle.
- Test suites load the tangled code by way of the shared helper so they work whether invoked from the repo root or inside `arxana/`.

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-compat.el
;;; arxana-compat.el --- Modern helpers for legacy accessors -*- lexical-binding: t; -*-

;;; Commentary:
;; Interposes `get-article` so the modern hash table is consulted before falling back to the legacy implementation.

;;; Code:

(defvar arxana-compat--orig-get-article nil
  "Original `get-article' captured before installing the compat shim.")

(defun arxana-compat--hash-article (name)
  "Return (NAME . VALUE) from `article-table' when available."
  (when (and (boundp 'article-table)
             (hash-table-p article-table)
             name)
    (let ((value (gethash name article-table)))
      (when value
        (cons name value)))))

(defun arxana-compat--get-article (name)
  "Prefer the modern article table before hitting the legacy fallback."
  (or (arxana-compat--hash-article name)
      (when (functionp arxana-compat--orig-get-article)
        (funcall arxana-compat--orig-get-article name))))

(with-eval-after-load 'arxana-tangled
  (unless arxana-compat--orig-get-article
    (setq arxana-compat--orig-get-article (symbol-function 'get-article))
    (fset 'get-article #'arxana-compat--get-article)))

(provide 'arxana-compat)

;;; arxana-compat.el ends here
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle dev/arxana-test-support.el
;;; arxana-test-support.el --- Shared helpers for ERT suites -*- lexical-binding: t; -*-

;;; Commentary:
;; Provides utilities to locate/load the tangled Arxana sources inside
;; the dev/test harness, regardless of whether we're running from the
;; repo root or from within the arxana/ subtree.

;;; Code:

(require 'cl-lib)

(defun arxana-test--locate-tangled ()
  "Return the best-effort path to `arxana-tangled.el'."
  (let* ((root (or (and (boundp 'arxana-root-directory)
                        arxana-root-directory)
                   default-directory))
         (candidates (list (expand-file-name "arxana/arxana-tangled.el" root)
                           (expand-file-name "arxana-tangled.el" root))))
    (cl-loop for path in candidates
             when (file-exists-p path)
             return path)))

(defun arxana-test--ensure-tangled-loaded ()
  "Load the tangled sources if they are not already resident."
  (unless (featurep 'arxana-tangled)
    (let ((tangled (arxana-test--locate-tangled)))
      (unless tangled
        (error "Cannot find arxana-tangled.el; run arxana-build first"))
      (load-file tangled))))

(provide 'arxana-test-support)

;;; arxana-test-support.el ends here
#+END_SRC

* Contributor guide (embedded)

#+INCLUDE: "docs/contributor-guide.md"

* QA checklist

#+BEGIN_SRC shell :exports code
./dev/run-tests.sh
#+END_SRC

* Known limitations

- Pattern-language wide editing (future milestone).
- Org→graph semantic mirroring pending.

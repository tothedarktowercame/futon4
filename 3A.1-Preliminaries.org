** Preliminaries

*** Some preliminaries                                             :noexport:

We define several simple preliminary functions that we use later on.


*** Required packages

We use the Common Lisp compatibility functions.


#+BEGIN_SRC elisp
(require 'cl)
#+END_SRC

*** On `filter'

This is a useful utility to filter elements of a list satisfying a condition.
Returns the subset of stuff which satisfies the predicate pred.


#+BEGIN_SRC elisp
(defun filter (pred stuff)
  (let ((ans nil))
    (dolist (item stuff (reverse ans))
      (if (funcall pred item)
            (setq ans (cons item ans))
        nil))))
#+END_SRC

#+BEGIN_SRC elisp :tangle no
(filter '(lambda (x) (= (% x 2) 1)) '(1 2 3 4 5 6 7))
=> (1 3 5 7)
#+END_SRC

*** On `intersection'

Set-theoretic intersection operation.  More general than the version
coming from the `cl' package.


#+BEGIN_SRC elisp
(defun intersection (&rest arg)
  (cond ((null arg) nil)
        ((null (cdr arg)) (car arg))
        (t (let ((ans nil))
             (dolist (elmt (car arg) ans)
               (let ((remainder (cdr arg)))
                 (while (and remainder
                             (member elmt (car remainder)))
                   (setq remainder (cdr remainder))
                   (when (null remainder)
                     (setq ans (cons elmt ans))))))))))
#+END_SRC

#+BEGIN_SRC elisp :tangle no
(intersection '(a b c d e f g h j)
              '(a b h j k)
              '(b d g h j k))
=> (j h b)
#+END_SRC

*** On `mapply'

Map and apply rolled into one.

#+BEGIN_SRC elisp
(defun mapply (f l)
  (if (member nil l) nil
    (cons (apply f (mapcar 'car l))
          (mapply f (mapcar 'cdr l)))))
#+END_SRC

#+BEGIN_SRC elisp :tangle no
(mapply '+ '((1 2) (3 4)))
 => (4 6)
#+END_SRC

*** On `sublis'

Substitute objects in a list.


#+BEGIN_SRC elisp
(defun sublis (sub lis)
  (cond
   ((null lis) nil)
   ((assoc lis sub) (cadr (assoc lis sub)))
   ((atom lis) lis)
   (t (cons (sublis sub (car lis))
            (sublis sub (cdr lis))))))
#+END_SRC

** Metadata
:PROPERTIES:
:LATEX_LABEL: metadata
:ID: metadata
:END:

*** Metadata articles                                              :noexport:
:PROPERTIES:
:LATEX_LABEL: metadata-articles
:ID: metadata-articles
:END:

*** Metadata article overview                                      :noexport:
:PROPERTIES:
:LATEX_LABEL: metadata-article-overview
:ID: metadata-article-overview
:END:

Metadata articles constitute a merger between ``local'' and
``holographic'' data storage (Note [[id:holographic-data-storage]]).
Metadata articles are essentially local, but they are used to maintain
information about data drawn from all over (in particular, backlinks
are recorded on metadata articles).  A metadata article is always
attached to some other article, and is used to record \emph{common}
information about this article.  They are updated automatically when
certain editing events take place.  When an article is rendered,
certain fields in the metadata article can take precedence over
corresponding information in the article itself (see Note
[[id:updating-link-extent]]).


*** Metadata article design                                        :noexport:
:PROPERTIES:
:LATEX_LABEL: metadata-article-design
:ID: metadata-article-design
:END:

We exploit the facts that articles (a) have unique names, (b) any LISP
object can be the name of an article, to produce the rule that any
\emph{non}-metadata article with \inp{name} \emph{name} to which we
need to associate a metadata article will have a metadata article
named ``(meta \emph{name})''.  The \inp{text} of this article is the
metadata associated with the base article; its format is that of a
list of lists, with each sub-list headed by a tag describing the
contents of that sub-list (e.g. \emph{backlinks}).  Metadata articles
are not considered to be \inp{about} anything; we get the picture by
looking at the article's \inp{name}.  (They may however contain
updated \inp{about} information for the article they are ``meta'' to;
see Note [[id:updating-link-extent]].)  Also, for now at least, we give
them only very minimal \inp{bookkeeping} information.

A ``metadata'' label is maintained that allows us to easily keep track
of the collection of metadata articles (see Note
[[id:on-modified-type-labeler-etc]], \emph{et seq.}).

This design makes it easy to set metadata ``fields'' with `assoc' and
`setcdr'; see Note [[id:put-metadata-field]].

(It would be good to say a bit more about the different fields that
are stored in metadata articles here.)


*** Maybe phasing out use of pseudo-namespace                      :noexport:

So far we've been able to ``afford'' the use of a pseudo-namespace for
metadata articles.  However, we may need to use a more legitimate
approach at some point.  We'll look at this issue again if it ever
seems important.


*** On `metadata-article-name-p'

So, like I said, we're losing some generality in the
set of available names by doing things the way we've been doing it.


#+BEGIN_SRC elisp
(defun metadata-article-name-p (name)
  (when (and (listp name)
             (eq (car name) 'meta))
    t))

(defun base-name-from-metadata-name (name)
  (second name))
#+END_SRC

*** On `metadata-article'

This function retrieves the metadata article associated with the
article named \inp{name}.


#+BEGIN_SRC elisp
(defun metadata-article (name)
  (get-article (list 'meta name)))
#+END_SRC

*** On `put-metadata-field'
:PROPERTIES:
:LATEX_LABEL: put-metadata-field
:ID: put-metadata-field
:END:

This can be can be used to fill a metadata \inp{field} with the given
\inp{value}, in the metadata article pertaining to the article named
\inp{name}.  If the field has not yet been set, it is created anew
with the appropriate \inp{value}.


#+BEGIN_SRC elisp
(defun put-metadata-field (field value name)
  (let* ((metadata (metadata-article name))
         (old-value (assoc field (scholium-text metadata)))
         new-text)
    (if old-value
        (setq new-text (progn (setcdr old-value value)
                              (scholium-text metadata)))
      (setq new-text `((,field . ,value))))
    (scholium (list 'meta name)
              new-text
              nil
              'meta
              'system)))
#+END_SRC

*** On `get-metadata-field'

This can be used to retrieve any particular metadata \inp{field}
pertaining to the article named \inp{name}.


#+BEGIN_SRC elisp
(defun get-metadata-field (field name)
  (cdr (assoc field (scholium-text (metadata-article name)))))
#+END_SRC

*** Similarity between metadata and text properties                :noexport:

It makes some sense that metadata about articles and metadata
about characters would be treated somewhat similarly.  Anyway,
the similar idioms seem to arise.


*** Updating link extent                                           :noexport:
:PROPERTIES:
:LATEX_LABEL: updating-link-extent
:ID: updating-link-extent
:END:

If an article $A$ is a scholium attached to some other article $B$,
and $B$'s \inp{text} is edited, then $A$'s \inp{about} data, if taken
literally, may be quite inaccurate.  The solution to this problem is
to examine the text properties indicating which regions of $B$ $A$ is
\emph{supposed to be} \inp{about}, and store the updated information
where it will be useful: $A$'s metadata article ``(meta $A$)''.  The
information stored in (meta $A$) ``masks'' individual links; see Note
[[id:masks]] for more information.


*** Updated `about' fields in the distributed case                 :noexport:
:PROPERTIES:
:LATEX_LABEL: updating-link-extent--distributed-case
:ID: updating-link-extent--distributed-case
:END:

In the distributed case, it would probably be best to use the metadata
pertinent to the current checked-out instance.  To facilitate this,
contributed \inp{about} data should probably be stored together with
the id of its source.  We're not quite there yet, but hopefully soon
will be!  (See also Note [[id:conflicts-in-a-distributed-environment]]


*** Backlinks (who links here?)}                                   :noexport:
:PROPERTIES:
:LATEX_LABEL: backlinks-section
:ID: backlinks-section
:END:

*** Theory of backlinks                                            :noexport:
:PROPERTIES:
:LATEX_LABEL: backlinks
:ID: backlinks
:END:

One particularly interesting sort of object is the ``backlink''.
These complement the generalized links discussed in Note
[[id:generalized-links]], and they play a fundamental role in the
system.  Backlinks make some operations faster (compare Note
[[id:name-or-access-buffered-articles]]).

Unlike regular links, which live in articles, an article's backlinks
live in its ``public'' metadata article.  See
[[id:overview-of-linking-process]] for further information on the
lifecycle of a backlink.

See Note [[id:backlink-tricks]] for a description of tricks that can be
done with backlinks.  Its worth mentioning that backlinks not seen in
the typical display, but they could be used in special displays (see
Note [[id:ancestors]]).  Backlinks are going to be important for AI
applications; they provide the information a given node needs to
``know'' its context within the broader semantic network.

Note that Howm is an already existing Emacs package for both forward
(``goto'') and backward (``come-from'') linking\footnote{http://howm.sourceforge.jp/}.  The behavior of Howm's come-from
links is somewhat different from the backlinking features implemented
in the scholium system, but it shouldn't be too hard to add Howm-like
features (see Section [[id:otf]] for some words on how we might
approach this).

(This note should probably just state the definition of backlinks;
anyway, as it is it seems to vague and too long.)


*** Implementation of backlinks                                    :noexport:
:PROPERTIES:
:LATEX_LABEL: implementation-of-backlinks
:ID: implementation-of-backlinks
:END:

Whereas links are typed (Note [[id:links]]), backlinks are not.
Insteady, backlinks indicate an article and a certain link in that
article.  The backlink data is useful because it allows us to easily
figure out which articles link to a given article (without doing any
mapping).  The basic use of backlink data is to display an article
together with its scholia.

We had considered using typed backlinks (mirroring the type of the
link that each backlink corresponds to), but this seemed excessive,
since the corresponding information can easily be found by examining
the link corresponding to a given backlink.


*** Overview of linking process                                    :noexport:
:PROPERTIES:
:LATEX_LABEL: overview-of-linking-process
:ID: overview-of-linking-process
:END:

When \inp{about} data is created or modified, `put-backlinks' is
called to update the backlinks in the metadata articles associated
with the \emph{linked-to} articles.  A backlink points at the specific
link that it corresponds to, by way of the \emph{linking} article and
the unique \emph{link number} that identifies the corresponding link.


*** On `delete-backlink'
:PROPERTIES:
:LATEX_LABEL: delete-backlink
:ID: delete-backlink
:END:

This function is called by `put-backlinks' to prune away an old
backlink.

Also notice that in this function, we know that some
metadata and backlinks already exist, so in particular the
`metafield' exists.  Hence we don't need the complicated
conditions found in the `add-backlink' function.

(I don't suppose we actually need to delete the ``backlink'' field
in the case in which we delete the last backlink.)


#+BEGIN_SRC elisp
(defun delete-backlink (linked-to-article link-number)
  (let* ((metaarticle (metadata-article linked-to-article))
         (metatext (scholium-text metaarticle))
         (metafield (assoc 'backlinks metatext))
         (backlinks (remove (list name link-number)
                            (cdr metafield))))
    (setcdr metafield backlinks)
    (scholium (list 'meta linked-to-article)
              metatext
              nil
              'meta
              'system)))
#+END_SRC

*** On `add-backlink'
:PROPERTIES:
:LATEX_LABEL: add-backlink
:ID: add-backlink
:END:

This function is called by `put-backlinks' to add a new backlink.

Note that the relevant metadata article may not exist prior to the
time this function runs and even if it exists, it may not contain any
backlink data.  So we have to run the relevant tests to deal with
these cases.  This accounts for differences between the implementation
of `add-backlink' and `delete-backlink' (Note [[id:delete-backlink]]).


#+BEGIN_SRC elisp
(defun add-backlink (linked-to-article link-number)
  (let* ((metaarticle (metadata-article linked-to-article))
         (metatext (scholium-text metaarticle))
         (metafield (assoc 'backlinks metatext))
         (backlinks (add-to-or-start-list
                     (cdr metafield)
                     (list name link-number))))
    (cond
     (metafield
      (setcdr metafield backlinks))
     (metatext
      (setcdr metatext
              `(((backlinks . ,backlinks)))))
     (t
      (setq metatext
            `((backlinks . ,backlinks)))))
    (scholium (list 'meta linked-to-article)
              metatext
              nil
              'meta
              'system)))
#+END_SRC

*** On `put-backlinks'
:PROPERTIES:
:LATEX_LABEL: put-backlinks
:ID: put-backlinks
:END:

The basic use for this function is to run it within the scope of the
`scholium' function, to build and store new (or updated) backlink
data.  Backlinks are added to each of the metadata articles
corresponding to articles that this article is \inp{about}.

The algorithm used here (zap \emph{all} existing backlinks, then place
\emph{all} new backlinks) seems likely to be woefully inefficient!  If
so, this can be improved later.

Notice that we don't take into account \inp{name} changes with this
function (there is no relevant ``old-name'' variable, at least, not at
present).


#+BEGIN_SRC elisp
(defun put-backlinks ()
  (let ((old-about (scholium-about old-version))
        (link-number 0))
    (dolist (link old-about)
      (setq link-number (1+ link-number))
      (delete-backlink (car link) link-number)))
  (let ((link-number 0))
    (dolist (link about)
      (setq link-number (1+ link-number))
      (add-backlink (car link) link-number))))

(add-hook 'new-scholium-hook 'put-backlinks)
(add-hook 'scholium-modified-about-hook 'put-backlinks)
#+END_SRC

*** Generality of `put-backlinks'                                  :noexport:
:PROPERTIES:
:LATEX_LABEL: generality-of-put-backlinks
:ID: generality-of-put-backlinks
:END:

The function used to be written in a general way so that it can store
backlinks in different fields.  For example, I had set things up to
add to a `derives-to' metadata field when the function
`include-article' ran (see Note [[id:include-article]]).  However, it
wasn't clear to me that this approach was really useful or necessary.

Nevertheless, storing new or updated mask data has to be done at some
point; and it may be that we'll want a generalized version of
`put-backlinks' after all (perhaps with a better name, speaking to its
new general purpose).


*** Turning backlinking off on demand sometimes?                   :noexport:

It might be nice to turn backlinking off in certain situations.  A
rather silly example is the situation in which you don't want the
owner of a certain object to know that you are talking about it.
There may be some more relevant situations.  (Compare the use of fake
links, as documented in Note [[id:metadata-override]]).


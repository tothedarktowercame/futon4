*** Utilities                                                      :noexport:

**** Useful things
:PROPERTIES:
:LATEX_LABEL: useful
:ID: useful
:END:

These definitions are either necessary or useful for
working the database and manipulating triple-centric
and/or theory-situated data.  The implementation of
theories given here is inspired by Lisp's streams.  This
is perhaps the most gnarly part of the code; the pay-off
of doing things the way we do them here is that
subsequently theories can sit ``transparently'' over other
structures.


#+BEGIN_SRC lisp
;; utilities.lisp
(in-package arxana)
(locally-enable-sql-reader-syntax)

;; (defun connect-to-database ()
;;    (connect `("localhost" "joe" "joe" "")
;;             :database-type :postgresql-socket))

(defun connect-to-database ()
   (connect `("localhost" "joe" "joe" "joe")
            :database-type :mysql))

(defmacro select-one (&rest args)
  `(car (select ,@args :flatp t)))

(defmacro select-flat (&rest args)
  `(select ,@args :flatp t))

(defun resolve-ambiguity (stuff)
  (first stuff))

(defun isolate-components (content i j)
  (list (nth (1- i) content)
        (nth (1- j) content)))

(defun isolate-beginning (triple)
  (isolate-components (cdr triple) 1 2))

(defun isolate-middle (triple)
  (isolate-components (cdr triple) 3 4))

(defun isolate-end (triple)
  (isolate-components (cdr triple) 5 6))

(defvar *read-from-heading* nil)

(defvar *write-to-heading* nil)
#+END_SRC

**** On `datatype'

Just translate coordinates into their primary dimension.
(How should this change to accomodate codes 4, 5, 6,
possibly etc.?)


#+BEGIN_SRC lisp
;; utilities.lisp
(defun datatype (data)
  (cond ((eq (car data) 0)
         "strings")
        ((eq (car data) 1)
         "places")
        ((eq (car data) 2)
         "triples")
        ((eq (car data) 3)
         "theories")))

(locally-disable-sql-reader-syntax)
#+END_SRC

**** Resolving ambiguity

Often it will eventuate that there will be more than one
item returned when we are only truly prepared to deal with
one item.  In order to handle this sort of ambiguity, it
would be great to have either a non-interactive notifier
that says that some ambiguity has been dealt with, or an
interactive tool that will let the user decide which of
the ambiguous options to choose from.  For now, we provide
the simplest non-interactive tool: just choose the first
item from a possibly ambiguous list of items.


**** Using a different database

See Note
# [[id:backend-variant]]
for instructions on changes
you will want to make if you use a different database.


**** Use of the ``count'' function

The SQL count function is thought to be inefficient with
some backends; workarounds exist.  (And it's considered to
be efficient with MySQL.)


**** Abstraction
:PROPERTIES:
:LATEX_LABEL: abstraction
:ID: abstraction
:END:

While it might be in some ways ``nice'' to allow people to
chain together ever-more-abstract references to elements
from other theories, I actually think it is better to
demand that there just be \emph{one} layer of abstraction
(since we can then quickly translate back and forth,
rather than running through a chain of translations).

This does not imply that we cannot have a theory
superimposed over another theory (or over multiple
theories) that draws input from throughout a massively
distributed interlaced system -- rather, just that we
assume we will need to translate to ``base coordinates''
when building such structures.  However, we'll certainly
want to explore the possibilities for running links
between theories (abstractly similar in some sense to
pointing at a component of a triple, but here there's no
uniform beg, mid, end scheme to refer to).


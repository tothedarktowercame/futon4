* Saving and restoring
:PROPERTIES:
:LATEX_LABEL: saving-and-restoring
:ID: saving-and-restoring
:END:

** Why saving?                                                     :noexport:

Having created several different scholia, you may wish to save your
work, to read back in later, or to send to a collaborator.


** Reverting                                                       :noexport:

The idea of \emph{reverting} to an earlier revision relates to the
previous section, as well as, vaguely, to the notion of
\emph{restoring} a saved article.  It isn't clear which section it
should go in, since it isn't actually any of these things!  It seems
like a somewhat likely candidate to go into the previous section
instead of this one.


** Restoring and managing state                                    :noexport:

Various details (e.g. an index counting new articles that have been
added to the system) may need to be maintained between sessions.


** Saving buffers to files                                         :noexport:

When saving/quitting, articles that come from buffers may then get
associated with files (assuming that the buffers end up getting saved
to a file).  Presumably we should \emph{offer} to save buffers to
files; alternatively, we could save them in some internal format that
the scholium system knows how to restore (reminds me of Emacs
filesets; see also Note [[id:excess-of-read-scholia-file]]).


** Saving special scholia                                          :noexport:

We should presumably offer the option of just saving only \emph{new}
or \emph{modified} scholia, or those that are connected with the
current buffer, or those that have a certain \inp{type}, etc., rather
than saving the whole library.  In some cases, the collection to be
will presumably only be found by predicate matching; other times, we
will be able to maintain an index of the subcollection to be saved
(e.g. we can keep track of all the articles that have been modified
since the last save).


** Autosave

We might consider making some environment variable that would cause
things to be saved to disk automatically.


#+BEGIN_SRC elisp
(defun save-all-scholia (filename)
  (interactive (list
                (read-file-name "Filename: ")))
  (save-window-excursion
    (gather-scholia)
    (write-file filename)
    (kill-buffer (current-buffer))))
#+END_SRC

** On `gather-scholia'

It might be a good idea for this function to take an optional
predicate or label, and gather only scholia that match that predicate.
We could easily cause the gathering function to run only within a
certain context as well.

This function doesn't really have anything to do with saving,
logically speaking, so perhaps it shouldn't go in this section.


#+BEGIN_SRC elisp
(defun gather-scholia ()
  (interactive)
  (set-buffer (get-buffer-create "*Scholia*"))
  (delete-region (point-min) (point-max))
  (maphash (lambda (name val)
               (write-scholium (cons name val)))
             article-table)
  (display-buffer "*Scholia*"))
#+END_SRC

** Improving the design of `write-scholium'

One could probably make these things print a bit nicer, e.g. to make
everything fit within 80 columns, but this seems to be good enough for
the time being.


#+BEGIN_SRC elisp
(defun write-scholium (article)
  (let ((nl "\n          "))
    (insert
     (concat "(scholium " (maybe-quoted-format (scholium-name article))
             nl (maybe-quoted-format (scholium-text article))
             nl (maybe-quoted-format (scholium-about article))
             nl (format "'%S" (scholium-type article))
             nl (format "'%S" (scholium-bookkeeping article))
             ")\n\n"))))

(defun maybe-quoted-format (obj)
  (if (and (not (null obj))
           (or (atom obj) (consp obj)))
      (format "'%S" obj)
    (format "%S" obj)))
#+END_SRC

** Design of `read-scholia-file'

This reads and evaluates all of the scholia that have been written out
into the file stored at \inp{filepath}.


#+BEGIN_SRC elisp
(defun read-scholia-file (filepath)
  (interactive "fFile: ")
  (find-file-literally filepath)
  (read-scholia-buffer)
  (kill-buffer (current-buffer)))

(defun read-scholia-buffer ()
  (while (condition-case nil
             (eval (read (current-buffer)))
           (error nil))))
#+END_SRC

** Apparently excessive generality of `read-scholia-file'
:PROPERTIES:
:LATEX_LABEL: excess-of-read-scholia-file
:ID: excess-of-read-scholia-file
:END:

This system would actually read any elisp file (er, I'm not sure it
would deal well with comments).  There are built-in functions that
accomplish the same thing (`load-file' and `eval-buffer' come to
mind).  The idea here was that we might want to do something somewhat
more complicated than simply evaluating the code found in the file.
That may still happen.


#+BEGIN_SRC elisp
(defvar search-directory-for-scholia t)

(add-hook 'find-file-hook 'search-directory-for-scholia)

(defun search-directory-for-scholia ()
  (list-directory default-directory t)
  (let ((sch-file
         (replace-regexp-in-string "\\..*" ".sch" (buffer-file-name))))
    (when (search-forward sch-file nil t)
      (read-scholia-file sch-file)
      (display-scholia-about-current-buffer)))
  (kill-buffer "*Directory*"))
#+END_SRC
